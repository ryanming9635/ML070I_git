C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Output\Main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Main.c LARGE OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Include\) DEBUG OBJECTEXTE
                    -ND CODE LISTINCLUDE SYMBOLS PRINT(.\Source\Main.lst) TABS(2) OBJECT(.\Output\Main.obj)

line level    source

   1          /*****************************************************************************/
   2          /*                                                                                              */
   3          /*  TELI ML070I   MCU                                             */
   4          /*                                                                                              */
   5          /*****************************************************************************/
   6          
   7          #include <math.h>
   1      =1  /*--------------------------------------------------------------------------
   2      =1  MATH.H
   3      =1  
   4      =1  Prototypes for mathematic functions.
   5      =1  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =1  Copyright (c) 2008-2016 ARM Germany GmbH
   7      =1  All rights reserved.
   8      =1  --------------------------------------------------------------------------*/
   9      =1  
  10      =1  #ifndef __MATH_H__
  11      =1  #define __MATH_H__
  12      =1  
  13      =1  #if defined __CX2__ && (__CX2__ >= 558 || __CX2__ == 556 && __CX2_MINOR__ >= 207)
           =1 #ifndef HUGE_VAL
           =1 #define HUGE_VAL __inf__
           =1 #endif // HUGE_VAL
           =1 
           =1 #ifndef NAN
           =1 #define NAN __nan__
           =1 #endif // NAN
           =1 
           =1 #pragma SAVE
           =1 #pragma FUNCTIONS(STATIC)
           =1 /* intrinsic functions are reentrant, but need static attribute */
           =1 extern int    abs  (int   val);
           =1 #pragma RESTORE
           =1 #endif
  28      =1  
  29      =1  #pragma SAVE
  30      =1  #pragma REGPARMS
  31      =1  #if !defined (__CX2__)
  32      =1  extern char  cabs  (char  val);
  33      =1  extern int    abs  (int   val);
  34      =1  extern long  labs  (long  val);
  35      =1  #endif
  36      =1  
  37      =1  extern float fabs  (float val);
  38      =1  extern float sqrt  (float val);
  39      =1  extern float exp   (float val);
  40      =1  extern float log   (float val);
  41      =1  extern float log10 (float val);
  42      =1  extern float sin   (float val);
  43      =1  extern float cos   (float val);
  44      =1  extern float tan   (float val);
  45      =1  extern float asin  (float val);
  46      =1  extern float acos  (float val);
  47      =1  extern float atan  (float val);
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 2   

  48      =1  extern float sinh  (float val);
  49      =1  extern float cosh  (float val);
  50      =1  extern float tanh  (float val);
  51      =1  extern float atan2 (float y, float x);
  52      =1  
  53      =1  extern float ceil  (float val);
  54      =1  extern float floor (float val);
  55      =1  extern float modf  (float val, float *n);
  56      =1  extern float fmod  (float x, float y);
  57      =1  extern float pow   (float x, float y);
  58      =1  
  59      =1  #if defined (__CX2__)
           =1 extern float frexp (float val, int *exp);
           =1 extern float ldexp (float val, int exp);
           =1 #endif
  63      =1  
  64      =1  #pragma RESTORE
  65      =1  
  66      =1  #endif
   8          #include <stdio.h>
   1      =1  /*--------------------------------------------------------------------------
   2      =1  STDIO.H
   3      =1  
   4      =1  Prototypes for standard I/O functions.
   5      =1  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =1  All rights reserved.
   7      =1  --------------------------------------------------------------------------*/
   8      =1  
   9      =1  #ifndef __STDIO_H__
  10      =1  #define __STDIO_H__
  11      =1  
  12      =1  #ifndef EOF
  13      =1   #define EOF -1
  14      =1  #endif
  15      =1  
  16      =1  #ifndef NULL
  17      =1   #define NULL ((void *) 0)
  18      =1  #endif
  19      =1  
  20      =1  #ifndef _SIZE_T
  21      =1   #define _SIZE_T
  22      =1   typedef unsigned int size_t;
  23      =1  #endif
  24      =1  
  25      =1  #pragma SAVE
  26      =1  #pragma REGPARMS
  27      =1  extern char _getkey (void);
  28      =1  extern char getchar (void);
  29      =1  extern char ungetchar (char);
  30      =1  extern char putchar (char);
  31      =1  extern int printf   (const char *, ...);
  32      =1  extern int sprintf  (char *, const char *, ...);
  33      =1  extern int vprintf  (const char *, char *);
  34      =1  extern int vsprintf (char *, const char *, char *);
  35      =1  extern char *gets (char *, int n);
  36      =1  extern int scanf (const char *, ...);
  37      =1  extern int sscanf (char *, const char *, ...);
  38      =1  extern int puts (const char *);
  39      =1  
  40      =1  #pragma RESTORE
  41      =1  
  42      =1  #endif
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 3   

  43      =1  
   9          
  10          #include "Config.h"
   1      =1  /*****************************************************************************/
   2      =1  /*                                                                                              */
   3      =1  /*  TELI ML070I   MCU                                             */
   4      =1  /*                                                                                              */
   5      =1  /*****************************************************************************/
   6      =1  
   7      =1  #ifndef __CONFIG_H__
   8      =1  #define __CONFIG_H__
   9      =1  
  10      =1  //#define INTERNAL_MCU -- defined by Project Compiler session
  11      =1  //#define   HS      
  12      =1  //#define   E_Wintek  
  13      =1  //#define   AWT 
  14      =1  //#define Holtz
  15      =1  
  16      =1  
  17      =1  
  18      =1  //#define QUAD
  19      =1  /*
  20      =1  #ifdef QUAD
  21      =1    #define AWT_ML072Q
  22      =1  #else
  23      =1    #define AWT_ML072S
  24      =1  #endif
  25      =1  */
  26      =1  //#define SUPPORT_SVIDEO                     //andy Awt 20090914
  27      =1  //#define SUPPORT_COMPONENT     // support component analog to decoder//andy Awt 20090914
  28      =1  
  29      =1  //#define SUPPORT_DTV           // support DTV input through component( to ADC ).//andy Awt 20090914
  30      =1  //#define SUPPORT_PC          // support PC function
  31      =1  //#define SUPPORT_DVI       // support DVI input
  32      =1  //#define SUPPORT_SDCARD
  33      =1  
  34      =1  //#define SUPPORT_RS485
  35      =1  //-----------------------------------------------------------------------------
  36      =1  //    Firmware Version
  37      =1  //-----------------------------------------------------------------------------
  38      =1  #define FWVER     0x0001      // Rev 0001
  39      =1  
  40      =1  #define MCU_FW_Major      0x00      
  41      =1  #define MCU_FW_Sub0     0x00      
  42      =1  #define MCU_FW_Sub1     0x01      
  43      =1  //-----------------------------------------------------------------------------
  44      =1  //    Compiler
  45      =1  //-----------------------------------------------------------------------------
  46      =1  #define KEILC           // Keil C 5.0
  47      =1  //-----------------------------------------------------------------------------
  48      =1  //    MPU Clock
  49      =1  //-----------------------------------------------------------------------------
  50      =1  #ifndef INTERNAL_MCU
  51      =1  //#define CLOCK_11M         // 11.0592MHz
  52      =1  #define CLOCK_22M         // 22.1184MHz
  53      =1  #else                 // INTERNAL_MCU
           =1 #define CLOCK_27M         // 27MHz
           =1 #define REG_START_ADDRESS 0xc000    // register start 0xc000, for page0, 0xc100-page1 
           =1 #endif
  57      =1  //-----------------------------------------------------------------------------
  58      =1  //    TW88 Version
  59      =1  //-----------------------------------------------------------------------------
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 4   

  60      =1  #define TW8816
  61      =1  //-----------------------------------------------------------------------------
  62      =1  //    Options for Backlight control
  63      =1  //-----------------------------------------------------------------------------
  64      =1  //#define BACKLIGHT_CCFL
  65      =1  //#define BACKLIGHT_LED
  66      =1  #define BACKLIGHT_PWM
  67      =1  
  68      =1  //-----------------------------------------------------------------------------
  69      =1  //    Panel Resolution
  70      =1  //-----------------------------------------------------------------------------
  71      =1  // ---- Select Default Panel
  72      =1  //
  73      =1  //#define UXGA            // 1600 x 1200
  74      =1  //#define SXGA              // 1280 x 1024
  75      =1  //#define XGA  // 1024 x 768
  76      =1  /*
  77      =1  #ifdef XGA
  78      =1    #define LVDS          
  79      =1    #define PWIDTH  1024
  80      =1    #define PHEIGHT 768
  81      =1  #endif
  82      =1  //#define SVGA            //  800 x 600
  83      =1  #define VGA             //  640 x 480
  84      =1  #ifdef VGA
  85      =1    #define PWIDTH  640
  86      =1    #define PHEIGHT 480
  87      =1    //#define HITACHI_640_B_160   //--> 640 x 160
  88      =1    #define AND_640_480
  89      =1  #endif
  90      =1  //#define WXGA            // 1280 x 768 (15:9) // 1366 x 768 (16:9)
  91      =1  #ifdef WXGA
  92      =1      //#define WX_SHARP_LQ106K1LA
  93      =1    #define PWIDTH  1280
  94      =1    #define PHEIGHT 768
  95      =1  #endif
  96      =1  //#define WSVGA           // 1024 x 600 *** only video mode
  97      =1  #ifdef WSVGA
  98      =1    #define PWIDTH  1024
  99      =1    #define PHEIGHT 600
 100      =1    #define UNIDEN_1024_600
 101      =1  #endif
 102      =1  */
 103      =1  //#define WVGA            //  800 x 480
 104      =1  //#ifdef WVGA
 105      =1    //#define PWIDTH  800
 106      =1    //#define PHEIGHT 480//600
 107      =1    // If WVGA, you have to select panel.
 108      =1    //#define AU_10INCH
 109      =1    //#define WVGA_TPO
 110      =1    //#define SAMSUNG_10INCH
 111      =1    //#define SAMSUNG_TICONLESS_10INCH
 112      =1    //#define SHARP_TICONLESS_7INCH
 113      =1    //#define AU_TICONLESS_7INCH
 114      =1    //#define AU_G084SN05V8_8_4INCH 
 115      =1  //  #define HSD070IDW1_7INCH
 116      =1    //#define INNOLUX_AT080TN03
 117      =1    //#define AU_TICONLESS_7INCH_CCFL
 118      =1    //#define CMO     // CHIMEI panel
 119      =1    //#define AU_TICONLESS_10INCH
 120      =1    //#define HITACHI_T01
 121      =1    //#define HITACHI_TX23D12
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 5   

 122      =1    //#define HITACHI_TX18D24
 123      =1    //#define HITACHI_TX18D16
 124      =1    //#define TMD_LTA070A320F
 125      =1    //#define TMD_LTA080B
 126      =1  //#endif  //WVGA
 127      =1  //#define HVGA            //  480 x 320
 128      =1  //#define QVGA            //  320 x 240 *** only video mode
 129      =1  /*
 130      =1  #ifdef QVGA
 131      =1    #define PWIDTH  320
 132      =1    #define PHEIGHT 240
 133      =1    //#define HITACHI_TX09D73
 134      =1    //#define AU_DELTARGB
 135      =1    //#define SHARP_LQ050Q5DR01
 136      =1    //#define SHARP_LQ035
 137      =1    //#define TMD
 138      =1  #endif
 139      =1  
 140      =1  //#define WQVGA           //  480 x 234 *** only video mode
 141      =1  #ifdef WQVGA
 142      =1    #define PWIDTH  480
 143      =1    #define PHEIGHT 240
 144      =1    // If WQVGA, you have to select panel 
 145      =1      #define ANALOG_7INCH
 146      =1    //#define PWIDTH  400
 147      =1    //#define PHEIGHT 240
 148      =1    //#define SHARP_LQ043T3DX02   //  400 x 237
 149      =1    //#define LG_ANALOG
 150      =1    //#define TMD_ANALOG        //TMD_LTA05B352A
 151      =1    //#define T_51945GD       // Optorex Panel
 152      =1  #endif  // WQVGA
 153      =1  */
 154      =1  //if LVDS pannel disable TICONLESS
 155      =1  
 156      =1  //-----------------------------------------------------------------------------
 157      =1  //---- Add Support One more panel with DIPSW#1
 158      =1  //---- Ex. Add Analog AU 7" Panel with Default Panel for evalution
 159      =1  //#define ADD_ANALOGPANEL   // Added Analog panel(AU7") from default set panel(expect WQVGA) with DIP #1 sw
             -itch.(DIP#1=L:ANALOG, H:DEFAULT)
 160      =1                // It can't support WQVGA and ADD_ANALOGPANEL same time!!
 161      =1    //#define ADD_ANALOG_7INCH
 162      =1    //#define ADD_TMD_LTA05B352A
 163      =1                    
 164      =1  //---- Support Wide panel function
 165      =1  /*
 166      =1  #if (defined WXGA) || (defined WSVGA) || (defined WVGA) || (defined WQVGA)
 167      =1  #define WIDE_SCREEN         // Can support 4 display mode, i.e. Normal, Wide, Full, Zoom
 168      =1  #endif                // Tested panasonic WVGA panel.
 169      =1  */
 170      =1  //-----------------------------------------------------------------------------
 171      =1  //    Panel Vendor Specific
 172      =1  //-----------------------------------------------------------------------------
 173      =1  /*
 174      =1  //-----------------------------------------------------------------------------
 175      =1  //    TV Tuner
 176      =1  //-----------------------------------------------------------------------------
 177      =1  #define PHILIPS       0
 178      =1  #define ALPS        1   // ALPS, LG
 179      =1  #define TEMIC       2
 180      =1  #define TVAVA       3
 181      =1  #define LGTUNER       4
 182      =1  #define SAMSUNGMUTITUNER  5
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 6   

 183      =1  
 184      =1  #define TVTunerDevice   4
 185      =1  //-----------------------------------------------------------------------------
 186      =1  //    IR Remote Controller Type
 187      =1  //-----------------------------------------------------------------------------
 188      =1  //#define REMO_RC5          // RC5 style
 189      =1  #define TECHWELL_REMOCON
 190      =1  //#define REMO_NEC          // NEC style
 191      =1  //#define PHILIPS_REMOCON // New remocon 
 192      =1  */
 193      =1  
 194      =1  //-----------------------------------------------------------------------------
 195      =1  //    I2C Device Access Address Mapping
 196      =1  //-----------------------------------------------------------------------------
 197      =1  #define EEPROMI2CAddress  0xa0  // EEPROM (24C16)
 198      =1  #define TW88I2CAddress    0x8a  // TW880x
 199      =1  
 200      =1  /*
 201      =1  #define MSPI2CAddress   0x80  // MSP
 202      =1  #define ALC106I2CAddress    0x4A  // MSP
 203      =1  */
 204      =1  #define  AD5110I2CAddress    0x5E//0x58
 205      =1  
 206      =1  //-----------------------------------------------------------------------------
 207      =1  //    AD5110 Command Operation Truth table
 208      =1  //-----------------------------------------------------------------------------
 209      =1  
 210      =1  #define AD5110_CMD_No_Operation           0
 211      =1  #define AD5110_CMD_Write_RDAC_To_EEPROM       1
 212      =1  #define AD5110_CMD_Write_Data_To_RDAC       2
 213      =1  #define AD5110_CMD_Shutdown             3
 214      =1  #define AD5110_CMD_Soft_Refresh_RDAC    4
 215      =1  #define AD5110_CMD_Read_RDAC        5
 216      =1  #define AD5110_CMD_Read_EEPROM              6
 217      =1  
 218      =1  
 219      =1  
 220      =1  //-----------------------------------------------------------------------------
 221      =1  //    Options for Possible Inputs
 222      =1  //-----------------------------------------------------------------------------
 223      =1  
 224      =1  
 225      =1  
 226      =1  
 227      =1  
 228      =1  //-----------------------------------------------------------------------------
 229      =1  //    Options for Possible Standards
 230      =1  //    Default:NTSC
 231      =1  //-----------------------------------------------------------------------------
 232      =1  /*
 233      =1  #define SUPPORT_PAL     
 234      =1  #define SUPPORT_SECAM
 235      =1  #define SUPPORT_NTSC4   
 236      =1  #define SUPPORT_PALM  
 237      =1  #define SUPPORT_PALN    
 238      =1  #define SUPPORT_PAL60   
 239      =1  */
 240      =1  
 241      =1  //#define ID_CHECK_BY_FW        // in Video mode, check input system ID by firmware
 242      =1  
 243      =1  //-----------------------------------------------------------------------------
 244      =1  //    Options for Debugging/Release
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 7   

 245      =1  //-----------------------------------------------------------------------------
 246      =1  //#define SUPPORT_PATTERN       // support LCD test pattern
 247      =1  
 248      =1  /*
 249      =1  #ifndef WQVGA
 250      =1    #ifndef QVGA
 251      =1    #define SUPPORT_OSDPOSITIONMOVE
 252      =1    #endif
 253      =1  #endif
 254      =1  */
 255      =1  #define SERIAL              // include serial communication routines
 256      =1  //#define USE_HI3521_UART2
 257      =1  
 258      =1  //#define SUPPORT_DEBUG       // Support to use Read & Write in debug OSD Window by remocon.
 259      =1  
 260      =1  //#define DEBUG           // include debug information
 261      =1  #if 0///def DEBUG
           =1   //#define DEBUG_MAIN
           =1   //#define DEBUG_TIME
           =1   //#define DEBUG_KEYREMO
           =1   //#define DEBUG_TW88
           =1   //#define DEBUG_DECODER
           =1   //#define DEBUG_I2C
           =1   //#define DEBUG_EEP
           =1   //#define DEBUG_OSD
           =1   //#define DEBUG_AUDIO
           =1   //#define DEBUG_SETPANEL
           =1   //#define DEBUG_DTV
           =1   #define DEBUG_PC
           =1   //#define DEBUG_PC_MEAS
           =1   #define DEBUG_PC_COLOR
           =1   //#define DEBUG_COMPONENT
           =1   //#define DEBUG_BANK
           =1   //#define DEBUG_PAUSE
           =1   //#define DEBUG_MCU
           =1 #endif
 281      =1  
 282      =1  //#define AUTOCALC_PC         // in PC mode, Enable Auto Calcuration
 283      =1  //#define SUPPORT_USERCOLORFROMTXT  // Use color setting of text file in Color mode=USER MODE which is as B
             -rightness(Reg10), Contast(Reg11),
 284      =1                    //    Sat_U(Reg13),Sat_V(Reg14),Sharpness(Reg12,Reg78)                  
 285      =1  //#define SUPPORT_GAMMA
 286      =1  
 287      =1  //#define CHIP_MANUAL_TEST      // DIPSW#1
 288      =1  
 289      =1  //#ifndef INTERNAL_MCU
 290      =1  //#define NO_INITIALIZE       // After Power switch turn on with DIP SW4 Enable(Low), or pressed MENU button 
             -for internal MCU
 291      =1                                      //     micom works to access only I2C bus by serial command.
 292      =1  //#endif
 293      =1  
 294      =1  //#define SUPPORT_KRS_OSDDEMO   // For KRS Company Demo 
 295      =1  //#define SUPPORT_LINE_OSDDEMO
 296      =1  
 297      =1  //-----------------------------------------------------------------------------
 298      =1  //    Special Features
 299      =1  //-----------------------------------------------------------------------------
 300      =1  
 301      =1  //#ifndef INTERNAL_MCU
 302      =1  //#define SUPPORT_DELTA_RGB
 303      =1  //#endif
 304      =1  //#define SUPPORT_SELECTKEY     // choose the keymap of using select key or left,right key.
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 8   

 305      =1  //-----------------------------------------------------------------------------
 306      =1  
 307      =1  //#define HS_NEWOSDMENU     //Weylis -@121008 for Hor. Style OSD
 308      =1  //#define HS_NEWOSDMENU_2     //Weylis -@121008 for Hor. Style OSD(2 line)
 309      =1  #endif  //__CONFIG_H__
  11          
  12          #include "reg.h"
   1      =1  //
   2      =1  //Registers.h : Register declaration
   3      =1  //
   4      =1  
   5      =1  #ifndef __REGISTERS__
   6      =1  #define __REGISTERS__
   7      =1  
   8      =1  #ifdef INTERNAL_MCU
           =1 /*  BYTE Registers  */
           =1 sfr P0    = 0x80;
           =1 sfr P1    = 0x90;
           =1 sfr P2    = 0xA0;
           =1 sfr P3    = 0xB0;
           =1 sfr PSW   = 0xD0;
           =1 sfr ACC   = 0xE0;
           =1 sfr B     = 0xF0;
           =1 sfr SP    = 0x81;
           =1 sfr DPL   = 0x82;
           =1 sfr DPH   = 0x83;
           =1 sfr PCON  = 0x87;
           =1 sfr TCON  = 0x88;
           =1 sfr TMOD  = 0x89;
           =1 sfr TL0   = 0x8A;
           =1 sfr TL1   = 0x8B;
           =1 sfr TH0   = 0x8C;
           =1 sfr TH1   = 0x8D;
           =1 sfr IE    = 0xA8;
           =1 sfr IP    = 0xB8;
           =1 sfr SCON  = 0x98;
           =1 sfr SBUF  = 0x99;
           =1 
           =1 //sfr P4    = 0xd8;
           =1 
           =1 /*  8052 Extensions  */
           =1 sfr EXIF  = 0x91;   // external interrupt 2,3,4,5 flags should be cleared by software
           =1 sfr T2CON = 0xC8;
           =1 sfr RCAP2L = 0xCA;
           =1 sfr RCAP2H = 0xCB;
           =1 sfr TL2   = 0xCC;
           =1 sfr TH2   = 0xCD;
           =1 sfr EICON = 0xD8;
           =1 sfr EIE   = 0xE8;
           =1 sfr EIP   = 0xF8;
           =1 
           =1 /*  TW88 Core Extension */
           =1 sfr BANKREG   = 0x9A;
           =1 sfr SPICONTROL  = 0x9B;
           =1 sfr T0HIGH    = 0x9C;
           =1 sfr T0LOW     = 0x9D;
           =1 sfr T1HIGH    = 0x9E;
           =1 sfr T1LOW     = 0x9F;
           =1 sfr T2HIGH    = 0x93;
           =1 sfr T2LOW     = 0x94;
           =1 
           =1 /*  BIT Registers  */
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 9   

           =1 /*  PSW  */
           =1 sbit CY    = 0xD7;
           =1 sbit AC    = 0xD6;
           =1 sbit F0    = 0xD5;
           =1 sbit RS1   = 0xD4;
           =1 sbit RS0   = 0xD3;
           =1 sbit OV    = 0xD2;
           =1 sbit P     = 0xD0;
           =1 
           =1 /*  TCON  */
           =1 sbit TF1   = 0x8F;
           =1 sbit TR1   = 0x8E;
           =1 sbit TF0   = 0x8D;
           =1 sbit TR0   = 0x8C;
           =1 sbit IE1   = 0x8B;
           =1 sbit IT1   = 0x8A;
           =1 sbit IE0   = 0x89;
           =1 sbit IT0   = 0x88;
           =1 
           =1 /*  IE  */
           =1 sbit EA    = 0xAF;
           =1 sbit ES    = 0xAC;
           =1 sbit ET1   = 0xAB;
           =1 sbit EX1   = 0xAA;
           =1 sbit ET0   = 0xA9;
           =1 sbit EX0   = 0xA8;
           =1 
           =1 /*  EIE  */
           =1 sbit EWDI  = 0xEC;    // Watch dog timer interrupt enable
           =1 sbit EX5   = 0xEB;    // external interrupt 5 enable
           =1 sbit EX4   = 0xEA;    // external interrupt 4 enable
           =1 sbit EX3   = 0xE9;    // external interrupt 3 enable
           =1 sbit EX2   = 0xE8;    // external interrupt 2 enable
           =1 
           =1 /*  IP  */
           =1 sbit PS    = 0xBC;
           =1 sbit PT1   = 0xBB;
           =1 sbit PX1   = 0xBA;
           =1 sbit PT0   = 0xB9;
           =1 sbit PX0   = 0xB8;
           =1 
           =1 /*  EIP  */
           =1 sbit PWDI  = 0xFC;    // Watch dog timer interrupt priority
           =1 sbit PX5   = 0xFB;    // external interrupt5 priority
           =1 sbit PX4   = 0xFA;    // external interrupt4 priority
           =1 sbit PX3   = 0xF9;    // external interrupt3 priority
           =1 sbit PX2   = 0xF8;    // external interrupt2 priority
           =1 
           =1 /*  P3  */
           =1 sbit RD    = 0xB7;
           =1 sbit WR    = 0xB6;
           =1 sbit T1    = 0xB5;
           =1 sbit T0    = 0xB4;
           =1 sbit INT1  = 0xB3;
           =1 sbit INT0  = 0xB2;
           =1 sbit TXD   = 0xB1;
           =1 sbit RXD   = 0xB0;
           =1 
           =1 /*  SCON  */
           =1 sbit SM0   = 0x9F;
           =1 sbit SM1   = 0x9E;
           =1 sbit SM2   = 0x9D;
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 10  

           =1 sbit REN   = 0x9C;
           =1 sbit TB8   = 0x9B;
           =1 sbit RB8   = 0x9A;
           =1 sbit TI    = 0x99;
           =1 sbit RI    = 0x98;
           =1 
           =1 /*  8052 Extensions  */
           =1 /*  IE  */
           =1 sbit ET2   = 0xAD;
           =1 
           =1 /*  IP  */
           =1 sbit PT2   = 0xBD;
           =1 
           =1 /*  P1  */
           =1 sbit T2EX  = 0x91;
           =1 sbit T2    = 0x90;
           =1              
           =1 /*  T2CON  */
           =1 sbit TF2   = 0xCF;
           =1 sbit EXF2  = 0xCE;
           =1 sbit RCLK  = 0xCD;
           =1 sbit TCLK  = 0xCC;
           =1 sbit EXEN2 = 0xCB;
           =1 sbit TR2   = 0xCA;
           =1 sbit C_T2  = 0xC9;
           =1 sbit CP_RL2= 0xC8;
           =1 
           =1 sfr CHPENR = 0xF6;
           =1 sfr CHPCON = 0xBF;
           =1 sfr SFRAL  = 0xC4;
           =1 sfr SFRAH  = 0xC5;
           =1 sfr SFRFD  = 0xC6;
           =1 sfr SFRCN  = 0xC7;
           =1 
           =1 sbit P0_0  = 0x80;
           =1 sbit P0_1  = 0x81;
           =1 sbit P0_2  = 0x82;
           =1 sbit P0_3  = 0x83;
           =1 sbit P0_4  = 0x84;
           =1 sbit P0_5  = 0x85;
           =1 sbit P0_6  = 0x86;
           =1 sbit P0_7  = 0x87;
           =1 
           =1 sbit P1_0  = 0x90;
           =1 sbit P1_1  = 0x91;
           =1 sbit P1_2  = 0x92;
           =1 sbit P1_3  = 0x93;
           =1 sbit P1_4  = 0x94;
           =1 sbit P1_5  = 0x95;
           =1 sbit P1_6  = 0x96;
           =1 sbit P1_7  = 0x97;
           =1 
           =1 sbit P2_0  = 0xa0;
           =1 sbit P2_1  = 0xa1;
           =1 sbit P2_2  = 0xa2;
           =1 sbit P2_3  = 0xa3;
           =1 sbit P2_4  = 0xa4;
           =1 sbit P2_5  = 0xa5;
           =1 sbit P2_6  = 0xa6;
           =1 sbit P2_7  = 0xa7;
           =1 
           =1 sbit P3_0  = 0xb0;
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 11  

           =1 sbit P3_1  = 0xb1;
           =1 sbit P3_2  = 0xb2;
           =1 sbit P3_3  = 0xb3;
           =1 sbit P3_4  = 0xb4;
           =1 sbit P3_5  = 0xb5;
           =1 sbit P3_6  = 0xb6;
           =1 sbit P3_7  = 0xb7;
           =1 
           =1 #else // external MCU=WINBOND
 189      =1  /*  BYTE Registers  */
 190      =1  sfr P0    = 0x80;
 191      =1  sfr P1    = 0x90;
 192      =1  sfr P2    = 0xA0;
 193      =1  sfr P3    = 0xB0;
 194      =1  sfr PSW   = 0xD0;
 195      =1  sfr ACC   = 0xE0;
 196      =1  sfr B     = 0xF0;
 197      =1  sfr SP    = 0x81;
 198      =1  sfr DPL   = 0x82;
 199      =1  sfr DPH   = 0x83;
 200      =1  sfr PCON  = 0x87;
 201      =1  sfr TCON  = 0x88;
 202      =1  sfr TMOD  = 0x89;
 203      =1  sfr TL0   = 0x8A;
 204      =1  sfr TL1   = 0x8B;
 205      =1  sfr TH0   = 0x8C;
 206      =1  sfr TH1   = 0x8D;
 207      =1  sfr CKCON = 0x8E;   //clock control register, default =0x01
 208      =1  sfr IE    = 0xA8;
 209      =1  sfr IP    = 0xB8;
 210      =1  sfr SCON  = 0x98;
 211      =1  sfr SBUF  = 0x99;
 212      =1  sfr P4 = 0xE8; //Megawin Ryan@970716
 213      =1  //sfr P4    = 0xa5;      //SST MCU
 214      =1  //sfr P4    = 0xd8;   //winbond<960820>
 215      =1  
 216      =1  
 217      =1  /*  8052 Extensions  */
 218      =1  sfr ADCTL = 0xC5;   //william-20111017
 219      =1  sfr ADCV = 0xC6;    //william-20111017
 220      =1  sfr ADCVL = 0xE8;   //william-20111017
 221      =1  sfr T2CON = 0xC8;
 222      =1  sfr RCAP2L = 0xCA;
 223      =1  sfr RCAP2H = 0xCB;
 224      =1  sfr TL2   = 0xCC;
 225      =1  sfr TH2   = 0xCD;
 226      =1  
 227      =1  // for UART2
 228      =1  sfr S2CON  = 0xAA;
 229      =1  sfr S2BRT  = 0xBA;
 230      =1  sfr S2BUF  = 0x9A;
 231      =1  sfr AUXR2  = 0xA6;
 232      =1  sfr AUXIE  = 0xAD;
 233      =1  
 234      =1  
 235      =1  sfr P1M0  = 0x91;
 236      =1  sfr P1M1  = 0x92;
 237      =1  sfr P0M0  = 0x93;
 238      =1  sfr P0M1  = 0x94;
 239      =1  sfr P2M0  = 0x95;
 240      =1  sfr P2M1  = 0x96;
 241      =1  sfr P3M0  = 0xB1;
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 12  

 242      =1  sfr P3M1  = 0xB2;
 243      =1  
 244      =1  
 245      =1  // for PCA
 246      =1  sfr CCON   = 0xD8;
 247      =1  sfr CMOD   = 0xD9;
 248      =1  sfr CCAPM0 = 0xDA;
 249      =1  sfr CCAPM1 = 0xDB;
 250      =1  sfr CCAPM2 = 0xDC;
 251      =1  sfr CCAPM3 = 0xDD;
 252      =1  sfr CCAPM4 = 0xDE;
 253      =1  sfr CCAPM5 = 0xDF;
 254      =1  sfr CL     = 0xE9;
 255      =1  sfr CH     = 0xF9;
 256      =1  sfr CCAP0L = 0xEA;
 257      =1  sfr CCAP0H = 0xFA;
 258      =1  sfr CCAP1L = 0xEB;
 259      =1  sfr CCAP1H = 0xFB;
 260      =1  sfr CCAP2L = 0xEC;
 261      =1  sfr CCAP2H = 0xFC;
 262      =1  sfr CCAP3L = 0xED;
 263      =1  sfr CCAP3H = 0xFD;
 264      =1  sfr CCAP4L = 0xEE;
 265      =1  sfr CCAP4H = 0xFE;
 266      =1  sfr CCAP5L = 0xEF;
 267      =1  sfr CCAP5H = 0xFF;
 268      =1  sfr PCAPWM0= 0xF2;
 269      =1  sfr PCAPWM1= 0xF3;
 270      =1  sfr PCAPWM2= 0xF4;
 271      =1  sfr PCAPWM3= 0xF5;
 272      =1  sfr PCAPWM4= 0xF6;
 273      =1  sfr PCAPWM5= 0xF7;
 274      =1  
 275      =1  /*  BIT Registers  */
 276      =1  /*  PSW  */
 277      =1  sbit CY    = 0xD7;
 278      =1  sbit AC    = 0xD6;
 279      =1  sbit F0    = 0xD5;
 280      =1  sbit RS1   = 0xD4;
 281      =1  sbit RS0   = 0xD3;
 282      =1  sbit OV    = 0xD2;
 283      =1  sbit P     = 0xD0;
 284      =1  
 285      =1  /*  TCON  */
 286      =1  sbit TF1   = 0x8F;
 287      =1  sbit TR1   = 0x8E;
 288      =1  sbit TF0   = 0x8D;
 289      =1  sbit TR0   = 0x8C;
 290      =1  sbit IE1   = 0x8B;
 291      =1  sbit IT1   = 0x8A;
 292      =1  sbit IE0   = 0x89;
 293      =1  sbit IT0   = 0x88;
 294      =1  
 295      =1  /*  IE  */
 296      =1  sbit EA    = 0xAF;
 297      =1  sbit ES    = 0xAC;
 298      =1  sbit ET1   = 0xAB;
 299      =1  sbit EX1   = 0xAA;
 300      =1  sbit ET0   = 0xA9;
 301      =1  sbit EX0   = 0xA8;
 302      =1  
 303      =1  /*  IP  */
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 13  

 304      =1  sbit PS    = 0xBC;
 305      =1  sbit PT1   = 0xBB;
 306      =1  sbit PX1   = 0xBA;
 307      =1  sbit PT0   = 0xB9;
 308      =1  sbit PX0   = 0xB8;
 309      =1  
 310      =1  /*  P3  */
 311      =1  sbit RD    = 0xB7;
 312      =1  sbit WR    = 0xB6;
 313      =1  sbit T1    = 0xB5;
 314      =1  sbit T0    = 0xB4;
 315      =1  sbit INT1  = 0xB3;
 316      =1  sbit INT0  = 0xB2;
 317      =1  sbit TXD   = 0xB1;
 318      =1  sbit RXD   = 0xB0;
 319      =1  
 320      =1  /*  SCON  */
 321      =1  sbit SM0   = 0x9F;
 322      =1  sbit SM1   = 0x9E;
 323      =1  sbit SM2   = 0x9D;
 324      =1  sbit REN   = 0x9C;
 325      =1  sbit TB8   = 0x9B;
 326      =1  sbit RB8   = 0x9A;
 327      =1  sbit TI    = 0x99;
 328      =1  sbit RI    = 0x98;
 329      =1  
 330      =1  /*  8052 Extensions  */
 331      =1  /*  IE  */
 332      =1  sbit ET2   = 0xAD;
 333      =1  
 334      =1  /*  IP  */
 335      =1  sbit PT2   = 0xBD;
 336      =1  
 337      =1  /*  P1  */
 338      =1  sbit T2EX  = 0x91;
 339      =1  sbit T2    = 0x90;
 340      =1               
 341      =1  /*  T2CON  */
 342      =1  sbit TF2   = 0xCF;
 343      =1  sbit EXF2  = 0xCE;
 344      =1  sbit RCLK  = 0xCD;
 345      =1  sbit TCLK  = 0xCC;
 346      =1  sbit EXEN2 = 0xCB;
 347      =1  sbit TR2   = 0xCA;
 348      =1  sbit C_T2  = 0xC9;
 349      =1  sbit CP_RL2= 0xC8;
 350      =1  
 351      =1  sfr CHPENR = 0xF6;
 352      =1  sfr CHPCON = 0xBF;
 353      =1  sfr SFRAL  = 0xC4;
 354      =1  sfr SFRAH  = 0xC5;
 355      =1  sfr SFRFD  = 0xC6;
 356      =1  sfr SFRCN  = 0xC7;
 357      =1  
 358      =1  sbit P0_0  = 0x80;
 359      =1  sbit P0_1  = 0x81;
 360      =1  sbit P0_2  = 0x82;
 361      =1  sbit P0_3  = 0x83;
 362      =1  sbit P0_4  = 0x84;
 363      =1  sbit P0_5  = 0x85;
 364      =1  sbit P0_6  = 0x86;
 365      =1  sbit P0_7  = 0x87;
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 14  

 366      =1  
 367      =1  sbit P1_0  = 0x90;
 368      =1  sbit P1_1  = 0x91;
 369      =1  sbit P1_2  = 0x92;
 370      =1  sbit P1_3  = 0x93;
 371      =1  sbit P1_4  = 0x94;
 372      =1  sbit P1_5  = 0x95;
 373      =1  sbit P1_6  = 0x96;
 374      =1  sbit P1_7  = 0x97;
 375      =1  
 376      =1  sbit P2_0  = 0xa0;
 377      =1  sbit P2_1  = 0xa1;
 378      =1  sbit P2_2  = 0xa2;
 379      =1  sbit P2_3  = 0xa3;
 380      =1  sbit P2_4  = 0xa4;
 381      =1  sbit P2_5  = 0xa5;
 382      =1  sbit P2_6  = 0xa6;
 383      =1  sbit P2_7  = 0xa7;
 384      =1  
 385      =1  sbit P3_0  = 0xb0;
 386      =1  sbit P3_1  = 0xb1;
 387      =1  sbit P3_2  = 0xb2;
 388      =1  sbit P3_3  = 0xb3;
 389      =1  sbit P3_4  = 0xb4;
 390      =1  sbit P3_5  = 0xb5;
 391      =1  sbit P3_6  = 0xb6;
 392      =1  sbit P3_7  = 0xb7;
 393      =1  
 394      =1  sbit P4_0  = P4^0;
 395      =1  sbit P4_1  = P4^1;
 396      =1  sbit P4_2  = P4^2;
 397      =1  sbit P4_3  = P4^3;
 398      =1  #endif  // INTERNAL_MCU
 399      =1  
 400      =1  #endif  //__REGISTERS__
  13          #include "typedefs.h"
   1      =1  #ifndef __TYPEDEFS__
   2      =1  #define __TYPEDEFS__
   3      =1  
   4      =1  
   5      =1  #define DATA    data
   6      =1  #define PDATA   pdata
   7      =1  #define IDATA   data
   8      =1  #define CODE    code
   9      =1  #define CODE_P
  10      =1  #define PDATA_P
  11      =1  #define IDATA_P
  12      =1  #define DATA_P
  13      =1  
  14      =1  #define INTERRUPT( num, name ) name() interrupt num
  15      =1  
  16      =1  #define _between(x, a, b) (a<=x && x<=b)
  17      =1  #define _swap(a, b)     { a^=b; b^=a; a^=b; }
  18      =1  
  19      =1  #define SEC(x)                                  (1000 * (x))
  20      =1  
  21      =1  typedef unsigned char Register;
  22      =1  typedef unsigned char BYTE;
  23      =1  typedef unsigned short  WORD;
  24      =1  typedef unsigned long DWORD;
  25      =1  
  26      =1  #define TRUE  1
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 15  

  27      =1  #define FALSE 0
  28      =1  #define _TRUE 1
  29      =1  #define _FALSE  0
  30      =1  
  31      =1  //VInputStdDetectMode
  32      =1  #define AUTO  0
  33      =1  
  34      =1  //VInputStd
  35      =1  #define NTSC  1     
  36      =1  #define PAL   2
  37      =1  #define SECAM 3
  38      =1  #define NTSC4 4
  39      =1  #define PALM  5
  40      =1  #define PALN  6
  41      =1  #define PAL60 7
  42      =1  
  43      =1  #define MAXINPUTSTD PAL60+1 // 
  44      =1  
  45      =1  #define UNKNOWN 0xfe
  46      =1  #define NOINPUT 0 //0xff
  47      =1  
  48      =1  
  49      =1  
  50      =1  
  51      =1  #define NIL     0xff
  52      =1  //****************************************************************************
  53      =1  // DEFINITIONS / MACROS
  54      =1  //****************************************************************************
  55      =1  
  56      =1  #define GET_MODE_STATE()                            (g_stModeInfo.b5ModeState)
  57      =1  #define SET_MODE_STATE(x)                         (g_stModeInfo.b5ModeState = x)
  58      =1  #define GET_MODE_STATE_CHANGE()                 (bit)(g_stModeInfo.b1ModeStateChanged)
  59      =1  #define SET_MODE_STATE_CHANGE()                 (g_stModeInfo.b1ModeStateChanged = _TRUE)
  60      =1  #define CLR_MODE_STATE_CHANGE()                 (g_stModeInfo.b1ModeStateChanged = _FALSE)
  61      =1  #define GET_MODE_RESET_TARGET()                   (g_stModeInfo.b4ModeResetFlag)
  62      =1  #define SET_MODE_RESET_TARGET(x)                (g_stModeInfo.b4ModeResetFlag = x)
  63      =1  #define GET_TARGET_POWER_STATUS()           (g_stPowerInfo.b4PowerAction)
  64      =1  #define SET_TARGET_POWER_STATUS(x)          (g_stPowerInfo.b4PowerAction = x)
  65      =1  
  66      =1  #define GET_BATTERY_STATE()       (g_stBatteryInfo.b5BatteryStatus)
  67      =1  #define SET_BATTERY_STATE(x)        (g_stBatteryInfo.b5BatteryStatus = x)
  68      =1  #define GET_NO_BATTERY()        (bit)(g_stBatteryInfo.b1NoBattery)
  69      =1  #define SET_NO_BATTERY()        (g_stBatteryInfo.b1NoBattery =_TRUE)
  70      =1  #define CLR_NO_BATTERY()        (g_stBatteryInfo.b1NoBattery = _FALSE)
  71      =1  
  72      =1  #define GET_AC_PLUG()       (bit)(g_stBatteryInfo.b1AC_PLUG)
  73      =1  #define SET_AC_PLUG()       (g_stBatteryInfo.b1AC_PLUG =_TRUE)
  74      =1  #define CLR_AC_PLUG()       (g_stBatteryInfo.b1AC_PLUG = _FALSE)
  75      =1        
  76      =1  
  77      =1  #define GET_BTH_STATE()         (g_stBatteryInfo.b3BTHStatus)
  78      =1  #define SET_BTH_STATE(x)          (g_stBatteryInfo.b3BTHStatus = x)
  79      =1  
  80      =1  #define GET_BATTERY_CAPACITY()        (g_stBatteryInfo.BatteryCapacity)
  81      =1  #define SET_BATTERY_CAPACITY(x)     (g_stBatteryInfo.BatteryCapacity = x)
  82      =1  #define GET_BATTERY_CAPACITY_FLAG()       (bit)(g_stBatteryInfo.b1BatteryCapacityLow)
  83      =1  #define SET_BATTERY_CAPACITY_FLAG()       (g_stBatteryInfo.b1BatteryCapacityLow =_TRUE)
  84      =1  #define CLR_BATTERY_CAPACITY_FLAG()     (g_stBatteryInfo.b1BatteryCapacityLow =_FALSE)
  85      =1  
  86      =1  #define GET_BATTERY_ABNORMAL()        (bit)(g_stBatteryInfo.b1BatteryAbnormal)
  87      =1  #define SET_BATTERY_ABNORMAL()        (g_stBatteryInfo.b1BatteryAbnormal=_TRUE)
  88      =1  #define CLR_BATTERY_ABNORMAL()        (g_stBatteryInfo.b1BatteryAbnormal=_FALSE)
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 16  

  89      =1  
  90      =1  #define GET_BATTERY_CHARGE_STATE()        (g_stBatteryInfo.b2BatteryChargeStatus)
  91      =1  #define SET_BATTERY_CHARGE_STATE(x)     (g_stBatteryInfo.b2BatteryChargeStatus = x)
  92      =1  
  93      =1  //--------------------------------------------------
  94      =1  // Power status
  95      =1  //--------------------------------------------------
  96      =1  #define GET_POWER_STATUS()                 (g_stPowerInfo.b4PowerStatus)
  97      =1  #define SET_POWER_STATUS(x)                (g_stPowerInfo.b4PowerStatus = x)
  98      =1  
  99      =1  //--------------------------------------------------
 100      =1  // Enumerations of Timer Events
 101      =1  //--------------------------------------------------
 102      =1  
 103      =1  typedef struct
 104      =1  {
 105      =1      BYTE b1EventValid : 1;
 106      =1      BYTE b7EventID : 7;
 107      =1      WORD usTime;
 108      =1  } StructTimerEventTableType;
 109      =1  
 110      =1  typedef enum
 111      =1  {
 112      =1      _USER_TIMER_EVENT_START,
 113      =1      _USER_TIMER_EVENT_KEY_REPEAT_ENABLE = _USER_TIMER_EVENT_START,   
 114      =1      _USER_TIMER_EVENT_KEY_SCAN_READY,
 115      =1      _USER_TIMER_EVENT_OSD_CAMERA_VOLTAGE_INC,
 116      =1      _USER_TIMER_EVENT_OSD_CAMERA_VOLTAGE_DEC,
 117      =1      _USER_TIMER_EVENT_OSD_GET_MCU_VERSION,
 118      =1      _USER_TIMER_EVENT_OSD_MCU_ENTRY_SLEEP_MODE,
 119      =1      _USER_TIMER_EVENT_OSD_DISTANCE_RESET,
 120      =1      _USER_TIMER_EVENT_OSD_DVR_REBOOT,
 121      =1      _USER_TIMER_EVENT_OSD_DVR_SHUTDOWN,
 122      =1      _USER_TIMER_EVENT_OSD_ENCODER_DEVIATION_SETTING,
 123      =1      //
 124      =1       _USER_TIMER_EVENT_OSD_SHOW_NO_CABLE,
 125      =1      _USER_TIMER_EVENT_OSD_SHOW_NO_SIGNAL,
 126      =1      _USER_TIMER_EVENT_OSD_SHOW_POWER_SAVING,
 127      =1      _USER_TIMER_EVENT_GO_TO_POWER_SAVING,
 128      =1      _USER_TIMER_EVENT_OSD_DISABLE,
 129      =1      _USER_TIMER_EVENT_PANEL_BACKLIGHT_ON,
 130      =1      _USER_TIMER_EVENT_PANEL_POWER_OFF,
 131      =1      _USER_TIMER_EVENT_DO_AUTO_COLOR,
 132      =1      _USER_TIMER_EVENT_PANEL_USED_TIMER,
 133      =1      _USER_TIMER_EVENT_HLWIN_TYPE5_MOVE,    
 134      =1    _USER_TIMER_EVENT_LED_POWER_SAVING,
 135      =1    _USER_TIMER_EVENT_LIGHT_SENSER_ON,
 136      =1    _USER_TIMER_EVENT_SHOW_BURN_IN,//ryan@20151230
 137      =1    _USER_TIMER_EVENT_BURN_IN_ON,//ryan@20151230
 138      =1    _USER_TIMER_EVENT_CHECK,//ryan@20151231
 139      =1    _USER_TIMER_EVENT_DISPLAY_INFO,//ryan@20151231
 140      =1    _USER_TIMER_EVENT_STANDBY_MODE,
 141      =1    _USER_TIMER_EVENT_FACTORY_MODE,//ryan@20160113
 142      =1      _USER_TIMER_EVENT_END,
 143      =1      _USER_TIMER_EVENT_COUNT = _USER_TIMER_EVENT_END,
 144      =1  } EnumUserTimerEventID;
 145      =1  
 146      =1  typedef enum
 147      =1  {
 148      =1      _SYSTEM_TIMER_EVENT_START = _USER_TIMER_EVENT_COUNT,
 149      =1      _SYSTEM_TIMER_EVENT_SOURCE_CLEAR_DETECTING = _SYSTEM_TIMER_EVENT_START,
 150      =1      _SYSTEM_TIMER_EVENT_JUDGE_BATT_STATE,
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 17  

 151      =1      _SYSTEM_TIMER_EVENT_JUDGE_POWER_STATE,
 152      =1      _SYSTEM_TIMER_EVENT_JUDGE_BTH_STATE,
 153      =1      _SYSTEM_TIMER_EVENT_JUDGE_PSW_STATE,    
 154      =1      _SYSTEM_TIMER_EVENT_JUDGE_AC_MODE,
 155      =1      _SYSTEM_TIMER_EVENT_JUDGE_DVR_COMM,
 156      =1      _SYSTEM_TIMER_EVENT_JUDGE_TW8836_COMM,
 157      =1      _SYSTEM_TIMER_EVENT_JUDGE_WDT_ECHO,
 158      =1       _SYSTEM_TIMER_EVENT_GRN_ON,    
 159      =1      _SYSTEM_TIMER_EVENT_GRN_OFF,    
 160      =1      _SYSTEM_TIMER_EVENT_RED_ON,      
 161      =1      _SYSTEM_TIMER_EVENT_RED_OFF,   
 162      =1      _SYSTEM_TIMER_EVENT_GRN_BLINK,    
 163      =1      _SYSTEM_TIMER_EVENT_RED_BLINK,   
 164      =1      _SYSTEM_TIMER_EVENT_GRN_RED_BLINK,    
 165      =1      _SYSTEM_TIMER_EVENT_GRN_RED_ON,    
 166      =1      _SYSTEM_TIMER_EVENT_GRN_ON_RED_BLINK,    
 167      =1      _SYSTEM_TIMER_EVENT_END,
 168      =1      _SYSTEM_TIMER_EVENT_COUNT,
 169      =1  } EnumSystemTimerEventID;
 170      =1  
 171      =1  
 172      =1  typedef enum
 173      =1  {
 174      =1      _SCALER_TIMER_EVENT_START = _SYSTEM_TIMER_EVENT_COUNT,
 175      =1      _SCALER_TIMER_EVENT_TMDS_HDMI_PACKET_DETECT = _SCALER_TIMER_EVENT_START, 
 176      =1      _SCALER_TIMER_EVENT_TMDS_VIDEO_DETECT,  
 177      =1      _SCALER_TIMER_EVENT_AUDIO_LOAD_STABLE_I_CODE,
 178      =1      _SCALER_TIMER_EVENT_DP_HOTPLUG_ASSERTED,
 179      =1      _SCALER_TIMER_EVENT_DP_HDCP_LONG_HOTPLUG_EVENT,
 180      =1      _SCALER_TIMER_EVENT_DP_LINK_STATUS_IRQ,    
 181      =1      _SCALER_TIMER_EVENT_D0_PORT_DIGITAL_SWITCH,
 182      =1      _SCALER_TIMER_EVENT_D1_PORT_DIGITAL_SWITCH,  
 183      =1      _SCALER_TIMER_EVENT_NR_DETECTION_FINISHED,  
 184      =1      _SCALER_TIMER_EVENT_PHASE_CALIBRATION,    
 185      =1      _SCALER_TIMER_EVENT_PHASE_CNT_CHECK,
 186      =1      _SCALER_TIMER_EVENT_MHL_D0_READY_TO_TRANSMIT,
 187      =1      _SCALER_TIMER_EVENT_MHL_D0_READY_TO_RESEND,
 188      =1      _SCALER_TIMER_EVENT_MHL_D0_RECONNECT_1K,
 189      =1      _SCALER_TIMER_EVENT_MHL_D0_ACTIVE_VBUS,
 190      =1      _SCALER_TIMER_EVENT_MHL_D1_READY_TO_TRANSMIT,
 191      =1      _SCALER_TIMER_EVENT_MHL_D1_READY_TO_RESEND,
 192      =1      _SCALER_TIMER_EVENT_MHL_D1_RECONNECT_1K,
 193      =1      _SCALER_TIMER_EVENT_MHL_D1_ACTIVE_VBUS,
 194      =1      _SCALER_TIMER_EVENT_DCC_HISTOGRAM_THD_CHANGE,
 195      =1      _SCALER_TIMER_EVENT_END,
 196      =1      _SCALER_TIMER_EVENT_COUNT = _SCALER_TIMER_EVENT_END,
 197      =1  } EnumMCUTimerEventID;
 198      =1  
 199      =1  #define _SIMULTANEOUS_SCALER_EVENT_COUNT       0//     (5 + (_D0_INPUT_PORT_TYPE == _D0_MHL_PORT) + (_D1_I
             -NPUT_PORT_TYPE == _D1_MHL_PORT))
 200      =1  #define _SIMULTANEOUS_USER_EVENT_COUNT             5
 201      =1  #define _SIMULTANEOUS_SYSTEM_EVENT_COUNT            3
 202      =1  
 203      =1  
 204      =1  #define _TIMER_EVENT_COUNT    (_SIMULTANEOUS_USER_EVENT_COUNT + _SIMULTANEOUS_SYSTEM_EVENT_COUNT + _SIMULT
             -ANEOUS_SCALER_EVENT_COUNT)
 205      =1  
 206      =1  
 207      =1  //--------------------------------------------------
 208      =1  // Power action
 209      =1  //--------------------------------------------------
 210      =1  
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 18  

 211      =1  typedef enum
 212      =1  {
 213      =1      _POWER_ACTION_OFF_TO_NORMAL = 0x00,          
 214      =1      _POWER_ACTION_AC_ON_TO_NORMAL,         
 215      =1      _POWER_ACTION_AC_ON_TO_OFF,  ////2          
 216      =1      _POWER_ACTION_PS_TO_NORMAL,           
 217      =1      _POWER_ACTION_PS_TO_OFF,              
 218      =1      _POWER_ACTION_NORMAL_TO_PS,   //5        
 219      =1      _POWER_ACTION_NORMAL_TO_OFF,          
 220      =1      _POWER_ACTION_NORMAL_TO_NOSUPPORT_PS, 
 221      =1      _POWER_ACTION_NOSUPPORT_PS_TO_PS,
 222      =1      _POWER_ACTION_NOSUPPORT_PS_TO_OFF, 
 223      =1      _POWER_ACTION_NONE = 0xFF,
 224      =1  } EnumPowerAction;
 225      =1  
 226      =1  typedef enum
 227      =1  {
 228      =1      _MODE_ACTION_NO_RESET_MODE = 0x00,                
 229      =1      _MODE_ACTION_RESET_TO_SEARCH,
 230      =1      _MODE_ACTION_RESET_TO_DISPLAY_SETTING, 
 231      =1      _MODE_ACTION_RESET_TO_DISPLAY_SETTING_WITHOUT_FORCETOBG,
 232      =1      _MODE_ACTION_RESET_TO_NOSUPPORT,    
 233      =1      _MODE_ACTION_RESET_TO_NOSIGNAL,
 234      =1      _MODE_ACTION_RESET_TO_POWER_SAVING,    
 235      =1      _MODE_ACTION_RESET_TO_POWER_OFF,           
 236      =1      _MODE_ACTION_RESET_TO_FACTORY_MODE,   
 237      =1      _MODE_ACTION_NONE = 0xFF,
 238      =1  } EnumModeAction;
 239      =1  
 240      =1  
 241      =1  //--------------------------------------------------
 242      =1  // Power status
 243      =1  //--------------------------------------------------
 244      =1  
 245      =1  typedef enum
 246      =1  {
 247      =1      _MODE_STATUS_INITIAL = 0x00,            
 248      =1      _MODE_STATUS_SEARCH,             
 249      =1      _MODE_STATUS_DISPLAY_SETTING,    
 250      =1      _MODE_STATUS_ACTIVE,             
 251      =1      _MODE_STATUS_NOSUPPORT,          
 252      =1      _MODE_STATUS_NOSIGNAL,           
 253      =1      _MODE_STATUS_POWER_SAVING,       
 254      =1      _MODE_STATUS_POWER_OFF,          
 255      =1      _MODE_STATUS_FACTORY,     
 256      =1      _MODE_STATUS_NONE = 0xFF,
 257      =1  } EnumModeStatus;
 258      =1  
 259      =1  typedef enum
 260      =1  {
 261      =1      _POWER_STATUS_AC_ON = 0x00,
 262      =1      _POWER_STATUS_OFF,
 263      =1      _POWER_STATUS_NORMAL,
 264      =1      _POWER_STATUS_NORMAL_BATTERY_MODE,   
 265      =1      _POWER_STATUS_NORMAL_NO_MATTERY_MODE,
 266      =1      _POWER_STATUS_SAVING,
 267      =1      _POWER_STATUS_SAVING_BATTERY_MODE,   
 268      =1      _POWER_STATUS_NOSUPPORT_SAVING,
 269      =1      _POWER_STATUS_NONE = 0xFF,
 270      =1  } EnumPowerStatus;
 271      =1  
 272      =1  
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 19  

 273      =1  //--------------------------------------------------
 274      =1  // Battery status
 275      =1  //--------------------------------------------------
 276      =1  
 277      =1  typedef enum
 278      =1  {
 279      =1    _BATT_STATUS_CAPACITY_LEVEL4=0x00,
 280      =1    _BATT_STATUS_CAPACITY_LEVEL3,
 281      =1    _BATT_STATUS_CAPACITY_LEVEL2,
 282      =1    _BATT_STATUS_CAPACITY_LEVEL1,
 283      =1    _BATT_STATUS_AC_MODE,
 284      =1    _BATT_STATUS_TEMP_HIGH, 
 285      =1    _BATT_STATUS_TEMP_NORMAL,
 286      =1    _BATT_STATUS_TEMP_LOW, 
 287      =1    _BATT_STATUS_NO_BATT,
 288      =1    _BATT_STATUS_CAPACITY_LOW,
 289      =1    _BATT_STATUS_CAPACITY_HIGH,
 290      =1    _BATT_STATUS_ABNORMAL_MODE,
 291      =1    _BATT_STATUS_FAST_CHARGE,
 292      =1    _BATT_STATUS_LOW_CHARGE,
 293      =1    _BATT_STATUS_STOP_CHARGE,
 294      =1    _BATT_STATUS_START_CHARGE,
 295      =1        _BATT_STATUS_NONE = 0xFF,
 296      =1  } EnumBatteryStatus;
 297      =1  
 298      =1  //--------------------------------------------------
 299      =1  // Battery action
 300      =1  //--------------------------------------------------
 301      =1  /*
 302      =1  typedef enum
 303      =1  {
 304      =1      _POWER_ACTION_OFF_TO_NORMAL = 0x00,          
 305      =1      _POWER_ACTION_AC_ON_TO_NORMAL,         
 306      =1      _POWER_ACTION_AC_ON_TO_OFF,  ////2          
 307      =1      _POWER_ACTION_PS_TO_NORMAL,           
 308      =1      _POWER_ACTION_PS_TO_OFF,              
 309      =1      _POWER_ACTION_NORMAL_TO_PS,   //5        
 310      =1      _POWER_ACTION_NORMAL_TO_OFF,          
 311      =1      _POWER_ACTION_NORMAL_TO_NOSUPPORT_PS, 
 312      =1      _POWER_ACTION_NOSUPPORT_PS_TO_PS,
 313      =1      _POWER_ACTION_NOSUPPORT_PS_TO_OFF, 
 314      =1      _POWER_ACTION_NONE = 0xFF,
 315      =1  } EnumPowerAction;
 316      =1  */
 317      =1  /*
 318      =1  typedef enum
 319      =1  {
 320      =1      _MODE_ACTION_NO_RESET_MODE = 0x00,                
 321      =1      _MODE_ACTION_RESET_TO_SEARCH,
 322      =1      _MODE_ACTION_RESET_TO_DISPLAY_SETTING, 
 323      =1      _MODE_ACTION_RESET_TO_DISPLAY_SETTING_WITHOUT_FORCETOBG,
 324      =1      _MODE_ACTION_RESET_TO_NOSUPPORT,    
 325      =1      _MODE_ACTION_RESET_TO_NOSIGNAL,
 326      =1      _MODE_ACTION_RESET_TO_POWER_SAVING,    
 327      =1      _MODE_ACTION_RESET_TO_POWER_OFF,           
 328      =1      _MODE_ACTION_RESET_TO_FACTORY_MODE,   
 329      =1      _MODE_ACTION_NONE = 0xFF,
 330      =1  } EnumModeAction;
 331      =1  */
 332      =1  
 333      =1  typedef struct
 334      =1  {
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 20  

 335      =1      BYTE b5BatteryStatus:5;
 336      =1      BYTE b1NoBattery:1;
 337      =1      BYTE b1AC_PLUG:1;
 338      =1      BYTE b3BTHStatus:3;
 339      =1      BYTE b1BatteryCapacityLow:1;
 340      =1      BYTE b1BatteryAbnormal:1;
 341      =1      BYTE b2BatteryChargeStatus:2;
 342      =1      WORD BatteryCapacity;
 343      =1  } StructBatteryInfoType;
 344      =1  
 345      =1  
 346      =1  typedef struct
 347      =1  {
 348      =1      BYTE b4PowerAction : 4;
 349      =1      BYTE b4PowerStatus : 4;
 350      =1      BYTE b1GDIIsolationFlag : 1;
 351      =1      BYTE b1TopIsolationFlag : 1;
 352      =1      BYTE b1AnalogIsolationFlag : 1;
 353      =1  } StructPowerInfoType;
 354      =1  
 355      =1  
 356      =1  typedef struct
 357      =1  {
 358      =1      BYTE b5ModeState : 5;
 359      =1      BYTE b1DisplaySettingReady : 1;
 360      =1      BYTE b1TimingConfirm : 1;
 361      =1      BYTE b1ModeStateChanged : 1;
 362      =1      BYTE b4ModeResetFlag : 4;    
 363      =1      BYTE b1NoWaitForActive : 1;
 364      =1      BYTE b1ActiveReady : 1;
 365      =1  } StructModeInfoType;
 366      =1  
 367      =1  
 368      =1  
 369      =1  /*
 370      =1  
 371      =1  enum SourceModeTypeEnum
 372      =1  { 
 373      =1    AVMode,      // 0   0X00
 374      =1    //VGAMode,       // 1
 375      =1  #ifdef USE_CAMD 
 376      =1    CAM_D,         // 2
 377      =1  #endif
 378      =1    CAM_A,         // 3     0x01
 379      =1    CAM_B,         // 4     0x02
 380      =1    CAM_C,         // 5     0x03
 381      =1    CAM_R,         // 6     0x04
 382      =1    CAM_AB,        // 7     0x05
 383      =1    CAM_CR,        // 8     0x06
 384      =1    CAM_AR,        // 9     0x07
 385      =1    CAM_RB,        // 10    0x08
 386      =1    CAM_AC,        // 11    0x09
 387      =1    CAM_CB,        // 12    0x0a
 388      =1    CAM_RAB_T,     // 13    0x0b
 389      =1    CAM_RAB_H,     // 14    0x0c
 390      =1  
 391      =1    CAM_QUAD,      // 15    0x0d
 392      =1    CAM_ABR_T3,    // 16    0x0e
 393      =1    CAM_ABR_T4,    // 17    0x0f
 394      =1    CAM_RAC_T,      //0x10  
 395      =1    CAM_RBC_T,      //0x11
 396      =1    CAM_RAC_T2,     //0x12  
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 21  

 397      =1    CAM_RBC_T2,     //0x13  
 398      =1    CAM_BA,       //0x14
 399      =1    CAM_BC,
 400      =1    CAM_BR,
 401      =1    CAM_CA,
 402      =1    CAM_ABC,
 403      =1    CAM_ABR,
 404      =1    CAM_ACR,
 405      =1    CAM_BAC,
 406      =1    CAM_BAR,
 407      =1    CAM_BCR,
 408      =1    CAM_CAB,
 409      =1    CAM_CAR,
 410      =1    CAM_CBR,  
 411      =1    SEQ,           // 18      0x10
 412      =1    CAM_NUM
 413      =1  };
 414      =1  */
 415      =1  //#define _TIMER_EVENT_COUNT      _SYSTEM_TIMER_EVENT_END////                    (_SIMULTANEOUS_USER_EVENT
             -_COUNT + _SIMULTANEOUS_SYSTEM_EVENT_COUNT + _SIMULTANEOUS_SCALER_EVENT_COUNT)
 416      =1  
 417      =1  //typedef unsigned char SourceModeType;
 418      =1  
 419      =1  #endif  /* __TYPEDEFS__ */
  14          #include "main.h"
   1      =1  #ifndef __MAIN__
   2      =1  #define __MAIN__
   3      =1  
   4      =1  #define ON          1
   5      =1  #define OFF         0
   6      =1  #define Hs_debug
   7      =1  //#define DVR
   8      =1  #define Format_SDCard
   9      =1  #define BJTSwitch
  10      =1  
  11      =1  
  12      =1  
  13      =1  #define Panel_Enable()          P4=P4|0x08 //andy 980908
  14      =1  #define Panel_Disable()     P4=P4&0xf7
  15      =1  
  16      =1  #if 0
           =1 #define SetBacklight()      P4=P4|0x04
           =1 #define clrBacklight()      P4=P4&0xfb
           =1 #else
  20      =1  #define SetBacklight()      P4=P4&0xfb
  21      =1  #define clrBacklight()       P4=P4|0x04
  22      =1  #endif
  23      =1  /*
  24      =1  #define COLUMN1_PIN   P2_3
  25      =1  #define COLUMN2_PIN   P2_4
  26      =1  #define COLUMN3_PIN   P2_5
  27      =1  */
  28      =1  
  29      =1  //InputSelection
  30      =1  /*
  31      =1  struct struct_IdName {
  32      =1    BYTE  Id;
  33      =1    BYTE  Name[16];
  34      =1  };
  35      =1  /*
  36      =1  
  37      =1  #define CH_TW2835              1
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 22  

  38      =1  #define CH_CAMD                2
  39      =1  #define CH_AV                  3
  40      =1  #define PC             7
  41      =1  #define ChineseDefaultMenu   8
  42      =1  
  43      =1  #define SVIDEO        2
  44      =1  #define COMPONENT     3
  45      =1  //#define ANALOGDTV     4
  46      =1  #define DTV         4
  47      =1  #define TV          5
  48      =1  #define SCART       6
  49      =1  
  50      =1  #define DIGITALVGA      8
  51      =1  
  52      =1  #define AIRTV       0 //9
  53      =1  #define CABLETV       1 //0xa
  54      =1  
  55      =1  
  56      =1  #define TVTUNER       0xd   //10
  57      =1  #define MUTE        1 
  58      =1  #define MENU        2 
  59      =1  #define TVVOL       4 
  60      =1  #define CC          8 
  61      =1  #define INPUTINFO     0x10
  62      =1  #define PCINFO        0x20
  63      =1  #define GAUGEINFO           0x40
  64      =1  //#define RATINGINFO      0x40
  65      =1  #define TVCHN       0x80
  66      =1  //#define MUTE        0x40
  67      =1  
  68      =1  #define YPBPR_480i      0
  69      =1  #define YPBPR_576i      1
  70      =1  #define YPBPR_480p      2
  71      =1  #define YPBPR_576p      3
  72      =1  #define YPBPR_1080i     4
  73      =1  #define YPBPR_720p      5
  74      =1  #define YPBPR_720p50    6
  75      =1  */
  76      =1  
  77      =1  #define _STOP_PWM     0x00
  78      =1  #define _RUN_PWM    0xFF
  79      =1  #define _BL_PWM     0x14
  80      =1  #define _CHG_CURR   0x15
  81      =1  
  82      =1  //ADC
  83      =1  #define P16_BTH   6  //P1.6
  84      =1  #define P17_BAT   7  //P1.7
  85      =1  
  86      =1  
  87      =1  
  88      =1  //--------------------------- P0 Define -----------------------------
  89      =1  //#define SEL_MIX     P0_6  // 
  90      =1  //--------------------------- P1 Define -----------------------------
  91      =1  //#define SEL_DVI     P3_5  //LJY062001   
  92      =1  
  93      =1  #define TW88HWReset     P3_4  //LJY001010 //LJY000721
  94      =1  #define PowerUp             P3_7
  95      =1  #define LBEN P1_6
  96      =1  //======================= CDS Control ================================= 
  97      =1  //#define CDS_CTRL           P1_5
  98      =1  /*
  99      =1  extern BYTE SelectModeType;
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 23  

 100      =1  extern BYTE InputSelection;
 101      =1  extern BYTE SEQTime;
 102      =1  extern BYTE Priority;
 103      =1  extern BYTE PowerFlag;
 104      =1  //extern bit AutoDayNight;
 105      =1  extern bit SDCardCoverDetect;
 106      =1  */
 107      =1  BYTE keyIn(void);
 108      =1  void TimerForRemocon(void);
 109      =1  void TimerForTick(void);
 110      =1  void DisableRemoconInt(void);
 111      =1  BYTE SetSupport_remocon(BYTE newd);
 112      =1  
 113      =1  void delay(BYTE cnt);
 114      =1  
 115      =1  BYTE RS_ready(void);
 116      =1  #ifdef Hs_debug
 117      =1  BYTE RS_rx(void);
 118      =1  #endif
 119      =1  void RS_tx(BYTE tx_buf);
 120      =1  
 121      =1  BYTE RS2_rx(void);
 122      =1  void RS2_tx(BYTE tx_buf);
 123      =1  
 124      =1  //void NewLine(void);
 125      =1  //void PutsP(PDATA_P BYTE *ptr);
 126      =1  #ifdef Hs_debug
 127      =1  //void MonWriteI2C(BYTE addr, BYTE index, BYTE val);
 128      =1  //BYTE MonReadI2C(BYTE addr, BYTE index);
 129      =1  #endif
 130      =1  BYTE Asc1Bin(BYTE asc);
 131      =1  BYTE Asc2Bin(PDATA_P BYTE *s);
 132      =1  
 133      =1  //void I2CDeviceInitialize( CODE_P BYTE *RegSet);
 134      =1  
 135      =1  //void RestartSystemClock(WORD clock_hm);
 136      =1  //WORD GetTime_ms(void);
 137      =1  #if 0
           =1 BYTE GetTime_H(void);
           =1 BYTE GetTime_M(void);
           =1 #endif
 141      =1  //void ChangeTime_H( char add );
 142      =1  //void ChangeTime_M( char add );
 143      =1  //WORD GetWakeupTime(void);
 144      =1  //void SetWakeupTime(WORD wtime);
 145      =1  
 146      =1  
 147      =1  //WORD GetOffTime(void);
 148      =1  //void SetOffTime(WORD wtime);
 149      =1  //BYTE GetSleepTimer(void);
 150      =1  //void SetSleepTimer(BYTE stime);
 151      =1  /*
 152      =1  WORD DiffTime_ms( WORD stime, WORD etime );
 153      =1  //void SetLastBlockedTime(void);
 154      =1  void SetLastCCTime(void);       //ljy010904...CC_FIX_CLEAR_ON_TIME
 155      =1  
 156      =1  void SetOSDLastKeyInTime(void);
 157      =1  WORD GetOSDLastKeyInTime(void);
 158      =1  WORD GetIVF(void);
 159      =1  DWORD GetIHF(void);
 160      =1  BYTE ReadVInputSTD(void);
 161      =1  void SetVInputStd(BYTE newd);
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 24  

 162      =1  BYTE GetVInputStd(void);
 163      =1  BYTE GetInputSelection(void);
 164      =1  #ifdef ADD_ANALOGPANEL
 165      =1  BYTE IsAnalogOn(void);
 166      =1  #endif
 167      =1  void InitVideoData(BYTE src);
 168      =1  void ChangeVInputStdDetectMode(BYTE val);
 169      =1  BYTE GetVInputStdInx(void);
 170      =1  
 171      =1  void MonWriteI2Cn_(BYTE addr, BYTE *val, BYTE cnt) ;
 172      =1  */
 173      =1  ///void Usage(void);
 174      =1  #ifdef Hs_debug
 175      =1    void Prompt(void);
 176      =1  #endif
 177      =1  /*
 178      =1  void DebugKeyIn(BYTE ikey);
 179      =1  void DVIPowerDown(bit flag);
 180      =1  void PowerDown_XTAL(bit flag);
 181      =1  */
 182      =1  //void ChangeInput(BYTE newsel);
 183      =1  
 184      =1  
 185      =1  void WaitPowerOn(void);
 186      =1  //void PowerOff(void);
 187      =1  //BYTE GetNextInputSelection(void);
 188      =1  
 189      =1  //BYTE WantToStopTVScan(void);
 190      =1  
 191      =1  //BYTE IsTW8801(void);
 192      =1  //BYTE IsTW8803(void);
 193      =1  //BYTE ConvertVideoVSAT(BYTE reg);
 194      =1  
 195      =1  //BYTE IsNoInput(void);
 196      =1  void LoadEEPROM (void);
 197      =1  void Hs_InitVars(void);
 198      =1  /*
 199      =1  void AdjustAutoDayNight(BYTE val);
 200      =1  void ACCPowerControl(void);
 201      =1  void AdjustBacklight(BYTE val);//val=0~110
 202      =1  */
 203      =1  BYTE mcuLib_ProtocolAppend(BYTE *pucBuf, BYTE* piLen, BYTE ucByte);
 204      =1  BYTE mcuLib_ProtocolSendCmdWithParamNum(BYTE ucType, BYTE* pucParam, BYTE ucSize);
 205      =1  void MCU_SendCmdToDVR(BYTE ucType);
 206      =1  void SetAD5110Step(BYTE newv) ;
 207      =1  
 208      =1  
 209      =1  
 210      =1  extern BYTE ScanPowerkey(void);
 211      =1  extern void MCUTimerInitialTimerEvent(void);
 212      =1  extern void MCUTimerActiveTimerEvent(WORD usTime, BYTE ucEventID);
 213      =1  extern void SysTimerHandler(void);
 214      =1  extern void SysJudgeHandler(void);
 215      =1  extern void SysModeHandler(void);
 216      =1  extern void SysPowerHandler(void);
 217      =1  
 218      =1  extern void MCUTimerDelayXms(WORD usNum);
 219      =1  
 220      =1  
 221      =1  struct RegisterInfo
 222      =1  {
 223      =1     int  Min;
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 25  

 224      =1     int  Max;
 225      =1     int  Default;
 226      =1  };
 227      =1  struct LongRegisterInfo
 228      =1  {
 229      =1     WORD Min;
 230      =1     WORD Max;
 231      =1     WORD Default;
 232      =1  };
 233      =1  
 234      =1  
 235      =1  
 236      =1  
 237      =1  #endif  // __MAIN__
  15          #include "i2c.h"
   1      =1  #ifndef __I2C_H__
   2      =1  #define __I2C_H__
   3      =1  //AD5110 table
   4      =1  /*   
   5      =1  "RA=100K+5.1K, RB=10K+10K  "        //  
   6      =1    D7D6D5D4D3D2D1D0  Vout        //
   7      =1  0 0 4.90                            //
   8      =1  1 1 4.92      
   9      =1  2 10  4.93      
  10      =1  3 11  4.95      
  11      =1  4 100 4.97      
  12      =1  5 101 4.99      
  13      =1  6 110 5.00      
  14      =1  7 111 5.02      
  15      =1  8 1000  5.03      
  16      =1  9 1001  5.05      
  17      =1  10  1010  5.07      
  18      =1  11  1011  5.09      
  19      =1  12  1100  5.11      
  20      =1  13  1101  5.12      
  21      =1  14  1110  5.14      
  22      =1  15  1111  5.16      
  23      =1  16  10000 5.18      
  24      =1  17  10001 5.20      
  25      =1  18  10010 5.21      
  26      =1  19  10011 5.23      
  27      =1  20  10100 5.25      
  28      =1  21  10101 5.27      
  29      =1  22  10110 5.29      
  30      =1  23  10111 5.31      
  31      =1  24  11000 5.33      
  32      =1  25  11001 5.35      
  33      =1  26  11010 5.37      
  34      =1  27  11011 5.39      
  35      =1  28  11100 5.41      
  36      =1  29  11101 5.43      
  37      =1  30  11110 5.45      
  38      =1  31  11111 5.47      
  39      =1  32  100000  5.48      
  40      =1  33  100001  5.51      
  41      =1  34  100010  5.54      
  42      =1  35  100011  5.56      
  43      =1  36  100100  5.58      
  44      =1  37  100101  5.60      
  45      =1  38  100110  5.63      
  46      =1  39  100111  5.65      
  47      =1  40  101000  5.67      
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 26  

  48      =1  41  101001  5.69      
  49      =1  42  101010  5.72      
  50      =1  43  101011  5.74      
  51      =1  44  101100  5.76      
  52      =1  45  101101  5.78      
  53      =1  46  101110  5.81      
  54      =1  47  101111  5.84      
  55      =1  48  110000  5.86      
  56      =1  49  110001  5.88      
  57      =1  50  110010  5.91      
  58      =1  51  110011  5.93      
  59      =1  52  110100  5.96      
  60      =1  53  110101  5.98      
  61      =1  54  110110  6.01      
  62      =1  55  110111  6.04      
  63      =1  56  111000  6.06      
  64      =1  57  111001  6.09      
  65      =1  58  111010  6.11      
  66      =1  59  111011  6.15      
  67      =1  60  111100  6.17      
  68      =1  61  111101  6.20      
  69      =1  62  111110  6.23      
  70      =1  63  111111  6.26      
  71      =1  64  1000000 6.28      
  72      =1  65  1000001 6.32      
  73      =1  66  1000010 6.35      
  74      =1  67  1000011 6.37      
  75      =1  68  1000100 6.40      
  76      =1  69  1000101 6.44      
  77      =1  70  1000110 6.47      
  78      =1  71  1000111 6.50      
  79      =1  72  1001000 6.53      
  80      =1  73  1001001 6.56      
  81      =1  74  1001010 6.59      
  82      =1  75  1001011 6.62      
  83      =1  76  1001100 6.66      
  84      =1  77  1001101 6.69      
  85      =1  78  1001110 6.72      
  86      =1  79  1001111 6.76      
  87      =1  80  1010000 6.79      
  88      =1  81  1010001 6.83      
  89      =1  82  1010010 6.86      
  90      =1  83  1010011 6.90      
  91      =1  84  1010100 6.93      
  92      =1  85  1010101 6.97      
  93      =1  86  1010110 7.01      
  94      =1  87  1010111 7.04      
  95      =1  88  1011000 7.08      
  96      =1  89  1011001 7.12      
  97      =1  90  1011010 7.16      
  98      =1  91  1011011 7.20      
  99      =1  92  1011100 7.24      
 100      =1  93  1011101 7.28      
 101      =1  94  1011110 7.32      
 102      =1  95  1011111 7.36      
 103      =1  96  1100000 7.40      
 104      =1  97  1100001 7.44      
 105      =1  98  1100010 7.48      
 106      =1  99  1100011 7.53      
 107      =1  100 1100100 7.57      
 108      =1  101 1100101 7.61      
 109      =1  102 1100110 7.66      
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 27  

 110      =1  103 1100111 7.71      
 111      =1  104 1101000 7.75      
 112      =1  105 1101001 7.80      
 113      =1  106 1101010 7.84      
 114      =1  107 1101011 7.89      
 115      =1  108 1101100 7.94      
 116      =1  109 1101101 7.99      
 117      =1  110 1101110 8.04      
 118      =1  111 1101111 8.09      
 119      =1  112 1110000 8.14      
 120      =1  113 1110001 8.19      
 121      =1  114 1110010 8.25      
 122      =1  115 1110011 8.30      
 123      =1  116 1110100 8.35      
 124      =1  117 1110101 8.41      
 125      =1  118 1110110 8.47      
 126      =1  119 1110111 8.52      
 127      =1  120 1111000 8.58      
 128      =1  121 1111001 8.64      
 129      =1  122 1111010 8.70      
 130      =1  123 1111011 8.76      
 131      =1  124 1111100 8.82      
 132      =1  125 1111101 8.88      
 133      =1  126 1111110 8.95      
 134      =1  127 1111111 9.01      
 135      =1  */
 136      =1  void I2CReadByte3(BYTE *);
 137      =1  void I2CRead8Byte(BYTE *);
 138      =1  #if 0
           =1 void I2CReadByteMSP(BYTE addr, BYTE index, BYTE *pd, BYTE cnt);
           =1 #endif
 141      =1  BYTE I2CWriteByte2(BYTE);
 142      =1  BYTE I2CWriteByte3(BYTE*);
 143      =1  BYTE I2CWrite8Byte(BYTE *);
 144      =1  
 145      =1  void I2CStart(void);
 146      =1  void I2CWriteData(BYTE value);
 147      =1  BYTE I2CReadData(void);
 148      =1  #if 0
           =1 BYTE I2CReadDataWithACK(void);
           =1 #endif
 151      =1  void I2CStop(void);
 152      =1  void I2Cdelay(void);
 153      =1  
 154      =1  
 155      =1  
 156      =1  #define WriteTW88(a,b)    WriteI2C(TW88I2CAddress, a, b)
 157      =1  #define ReadTW88(a)     ReadI2C(TW88I2CAddress, a)
 158      =1  /*
 159      =1  
 160      =1  
 161      =1  BYTE WriteTW88_Wait (BYTE, BYTE);
 162      =1  void WriteADC   (BYTE, BYTE);
 163      =1  BYTE ReadADC    (BYTE);
 164      =1  //BYTE ReadADC_TW88(BYTE index);
 165      =1  void WriteADC_TW88(BYTE index, BYTE dat);
 166      =1  */
 167      =1  void WriteEEP   (WORD, BYTE);
 168      =1  BYTE ReadEEP    (WORD);
 169      =1  //WORD ReadALC106(WORD index);
 170      =1  //void WriteALC106(WORD index, WORD  dat);
 171      =1  
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 28  

 172      =1  WORD ReadI2CWORD(BYTE addr, BYTE index);
 173      =1  BYTE ReadI2C    (BYTE addr, BYTE index);
 174      =1  void WriteI2C   (BYTE addr, BYTE index, BYTE val);
 175      =1  
 176      =1  void WriteI2Cn_(BYTE addr, BYTE *val, BYTE cnt);
 177      =1  void WriteI2Cn (BYTE addr, BYTE index, BYTE *val, BYTE cnt);
 178      =1  void WriteI2CnD(BYTE addr, BYTE index, BYTE val, BYTE cnt);
 179      =1  
 180      =1  void ReadI2Cmn(BYTE addr, BYTE wcnt, BYTE rcnt, BYTE *rwdata);
 181      =1  void WriteAD5110(WORD index, WORD  dat);
 182      =1  WORD ReadAD5110(WORD index);
 183      =1  
 184      =1  
 185      =1  #define   WriteADC(a,b) WriteADC_TW88(a,b)
 186      =1  #define   ReadADC(a)    ReadADC_TW88(a)
 187      =1  
 188      =1  #endif  /* __I2C_H__ */
  16          #include "adc.h"
   1      =1  #ifndef __ADC__
   2      =1  #define __ADC__
   3      =1  
   4      =1  //=============================================================================
   5      =1  //                             ADC Functions
   6      =1  //=============================================================================
   7      =1  
   8      =1  void ADCPowerDown(bit flag);
   9      =1  void SelectADCmux(BYTE sel);
  10      =1  void SetADCMode(BYTE mode);
  11      =1  
  12      =1  void EnableADC(void);
  13      =1  void DisableADC(void);
  14      =1  
  15      =1  WORD GetCoarse(void);
  16      =1  void SetCoarse(WORD i);
  17      =1  void SetPhase(BYTE j);
  18      =1  BYTE GetPhaseCurrent(void);
  19      =1  BYTE SetVCORange(DWORD _IPF);
  20      =1  
  21      =1  //void SetADCGainOffset(BYTE gain, BYTE offset);
  22      =1  void AutoColorAdjust(void);
  23      =1  
  24      =1  
  25      =1  
  26      =1  void AutoColorAdjustForDTV(BYTE flag);
  27      =1  
  28      =1  #endif  // __ADC__
  29      =1  
  30      =1  
  31      =1  
  32      =1  
  33      =1  
  34      =1  
  35      =1  
  36      =1  
  37      =1  
  38      =1  
  39      =1  
  40      =1  
  41      =1  
  42      =1  
  43      =1  
  44      =1  
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 29  

  45      =1  
  46      =1  
  47      =1  
  48      =1  
  49      =1  
  50      =1  
  51      =1  
  52      =1  
  53      =1  
  54      =1  
  17          #include "etc_eep.h"
   1      =1  #ifndef __ETC_EEP__
   2      =1  #define __ETC_EEP__
   3      =1  
   4      =1  
   5      =1  ////eeprom.h
   6      =1  
   7      =1  
   8      =1  #define  EEP_Powerflag            0x10   
   9      =1  #define  EEP_CameraVolt           0x11   
  10      =1  
  11      =1  
  12      =1  //=========================================================================
  13      =1  //  EEPROM structure
  14      =1  //  0x00  BYTE  4 'TW88'
  15      =1  #define EEP_FWREV_MAJOR     0x04  //BYTE  1 F/W Rev.-major(Hex) 
  16      =1  #define EEP_FWREV_MINOR     0x05  //BYTE  1 F/W Rev.-minor(Hex)
  17      =1  #define EEP_DEBUGLEVEL      0x06  //BYTE  1 DebugLevel
  18      =1  /*//
  19      =1  #define EEP_AUTODETECT      0x07  //BYTE  1 Flag for Input Auto Detect  -0:Auto, 1:NTSC,....
  20      =1  #define EEP_AUTODETECTTYTE    0x08  //BYTE  1 Type of Auto-detect(will be value of register 0x1d)
  21      =1  //      ---------------------------------------------------------------
  22      =1  #define EEP_WIDEMODE      0x09  //BYTE  1   Wide Mode
  23      =1  
  24      =1  #define EEP_AUTORECOGNITION   0x0a  //BYTE  1 Auto Recognition
  25      =1  #define EEP_VIDEOMODE     0x0b  //BYTE  1   Video Mode
  26      =1  
  27      =1  #define EEP_OSDLANG       0x0c  //BYTE  1   OSDLang           // 0
  28      =1  
  29      =1  #define EEP_OSDPOSITIONMODE   0x0d  //BYTE  1 OSD Position Mode
  30      =1  #define EEP_CCD         0x0e  //BYTE  1 Closed Caption- 0: off, 1:on
  31      =1  
  32      =1  #define EEP_INPUTSELECTION    0x0f  //BYTE  1 InputSelection
  33      =1  
  34      =1  //
  35      =1  #define EEP_PC_CONTRAST     0x10
  36      =1  #define EEP_PC_BRIGHT     0x11
  37      =1  
  38      =1  #define EEP_CONTRAST      0x12  //BYTE  1 Contrast 
  39      =1  #define EEP_BRIGHTNESS      0x13  //BYTE  1 Brightness
  40      =1  #define EEP_SATURATION_U    0x14  //BYTE  1 Saturation :U
  41      =1  #define EEP_SATURATION_V    0x15  //BYTE  1 Saturation :V
  42      =1  #define EEP_SHARPNESS     0x16  //BYTE  1 Sharpness 
  43      =1  #define EEP_HUE         0x17  //BYTE  1 Hue                    
  44      =1  
  45      =1  //====================================HS AWT 981001
  46      =1  #define  EEP_AutoMode           0xa0
  47      =1  #define  EEP_IMAGEMode          0xa1
  48      =1  #define  EEP_RearMode           0xa2
  49      =1  #define  EEP_COSDMode           0xa3
  50      =1  #define  EEP_GAUGEMode          0xa4
  51      =1  #define  EEP_CAMAMode           0xa5 
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 30  

  52      =1  #define  EEP_CAMBMode           0xa6
  53      =1  #define  EEP_CAMCMode           0xa7
  54      =1  #define  EEP_CAMRMode           0xa8
  55      =1  #define  EEP_CAMOutMode         0xa9  
  56      =1  #define  EEP_TimeStep           0xaa
  57      =1  
  58      =1  
  59      =1  
  60      =1  #define  EEP_ONOFFChoice        0xac 
  61      =1  
  62      =1  #define  EEP_PRIORITY           0xad
  63      =1  #define  EEP_JUMPMode           0xae
  64      =1  #define  EEP_NowModeState       0xaf
  65      =1  #define  EEP_SelectMode         0xb0
  66      =1  #define  EEP_PriorityOffSelectMode  0xb1
  67      =1  #define  EEP_AudioRecord    0xb2
  68      =1  
  69      =1  #define  EEP_FirstNumber    0xb3
  70      =1  #define  EEP_SecondNumber   0xb4
  71      =1  #define  EEP_ThridNumber    0xb5
  72      =1  #define  EEP_FourthNumber   0xb6
  73      =1  
  74      =1  #define  EEP_CAMNUMBER     0xb7
  75      =1  #define  EEP_PELCO       0xb8
  76      =1  #define  EEP_Baud_rate     0xb9
  77      =1  #define  EEP_TriggerVGA    0xba
  78      =1  #define  EEP_DVRDisplay    0xbb
  79      =1  #define  EEP_IMAGE_A_Mode    0xbc//andy A1.4 20100113
  80      =1  #define  EEP_IMAGE_B_Mode    0xbd//andy A1.4 20100113
  81      =1  #define  EEP_IMAGE_C_Mode    0xbe//andy A1.4 20100113
  82      =1  
  83      =1  #define  EEP_SDCardDetect    0xbf//andy A1.4 20100113
  84      =1  
  85      =1  
  86      =1  #define  EEP_DELAYCAMA           0xC0 
  87      =1  #define  EEP_DELAYCAMB           0xC1
  88      =1  #define  EEP_DELAYCAMC           0xC2
  89      =1  #define  EEP_DELAYCAMR           0xC3
  90      =1  #ifdef USE_CAMD
  91      =1  #define  EEP_DELAYCAMD           0xC4
  92      =1  #endif
  93      =1  //#define  EEP_SelectModeBuf         0xb2
  94      =1  #define  EEP_ReverseMode    0xc5
  95      =1  #define  EEP_JUMPAV_TIMESET 0xc6
  96      =1  
  97      =1  #define EEP_OSD_TYPE    0xc7
  98      =1  #define EEP_OSD_LANGUAGE  0xc8
  99      =1  #define EEP_OSD_BRIGHTNESS  0xc9
 100      =1  #define EEP_OSD_PWR_LINK  0xca
 101      =1  
 102      =1  #if 0
 103      =1  #define  EEP_Resolution     0xc0
 104      =1  #define  EEP_FPS        0xc1
 105      =1  #define  EEP_Quality      0xc2
 106      =1  #define  EEP_RecordMode     0xc3
 107      =1  #define  EEP_RecordLength   0xc4
 108      =1  #define  EEP_PreAlarmLength   0xc5
 109      =1  #define  EEP_PostAlarmLength  0xc6
 110      =1  #endif
 111      =1  //====================================HS AWT 981001
 112      =1  
 113      =1  //
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 31  

 114      =1  //        ---------------------------------------------------------------
 115      =1  #define EEP_PCAUDIOPVOL   0x37  //BYTE  1   AudioVol
 116      =1  #define EEP_AUDIOPVOL     0x38  //BYTE  1   AudioVol
 117      =1  #define EEP_AUDIOBALANCE    0x39  //BYTE  1   AudioBalance
 118      =1  //
 119      =1  //        ---------------------------------------------------------------
 120      =1  
 121      =1  #define EEP_BLOCKMOVIE      0x40  //BYTE  1 BlockedMovie:Blocked rating for Movie 
 122      =1  #define EEP_BLOCKTV       0x41  //BYTE  1 BlockedTV:Blocked rating for TV     
 123      =1  #define EEP_FVSLD       0x42  //BYTE  6
 124      =1  //                            7    6       4    3    2    1    0
 125      =1  //  FVSLD Level                        ALL   FV(V)   S    L    D    
 126      =1  //  0x43    BYTE    1   TV-Y            X  
 127      =1  //  0x44  BYTE    1   TV-Y7           X    X 
 128      =1  //  0x45  BYTE    1   TV-G            X 
 129      =1  //  0x46  BYTE    1   TV-PG           X       X    X    X    X
 130      =1  //  0x47  BYTE    1   TV-14           X       X    X    X    X 
 131      =1  //  0x48  BYTE    1   TV-MA           X       X    X    X
 132      =1  //
 133      =1  #define EEP_VCHIPPASSWORD   0x49  //BYTE  4   OSDPassword         //Defualt:3366
 134      =1  */
 135      =1  //      ---------------------------------------------------------------
 136      =1  //
 137      =1  //
 138      =1  //  0x61  WORD  2   PanelXRes
 139      =1  //  0x63  WORD  2 PanelYRes
 140      =1  //  0x65  BYTE  1 PanelHsyncMinPulseWidth
 141      =1  //  0x66  BYTE  1 PanelVsyncMinPulseWidth
 142      =1  //  0x67  WORD  2 PanelHminBackPorch
 143      =1  //  0x69  BYTE  1 PanelHsyncPolarity
 144      =1  //  0x6a  BYTE  1 PanelVsyncPolarity
 145      =1  //  0x6b  WORD  2 PanelDotClock
 146      =1  //  0x6d  BYTE  1 PanelPixsPerClock
 147      =1  //  0x6e  BYTE  1 PanelDEonly
 148      =1  //      ---------------------------------------------------------------
 149      =1  //
 150      =1  //  0x80  PC Data
 151      =1  //
 152      =1  //      ---------------------------------------------------------------
 153      =1  //
 154      =1  //  0x300 TV Data
 155      =1  //
 156      =1  //  --- NTSC_TV -------------------------------------------------------------
 157      =1  //  CNT_SAVEDAIR      BYTE  1   Total count of saved Air TV Channel.
 158      =1  //  IDX_CURAIR        BYTE  1   Index of Current Air TV Channel
 159      =1  //  CHN_CURAIR        BYTE    1   Current Air TV Channel.
 160      =1  //
 161      =1  //  FIRSTSAVED_AIRCHN   BYTE    1 First saved Air TV channel no (maximum 100)
 162      =1  //  ....
 163      =1  //
 164      =1  //  CNT_SAVEDCABLE      BYTE  1   Total count of saved Cable TV Channel.
 165      =1  //  IDX_CURCABLE      BYTE  1   Index of Current Cable TV Channel
 166      =1  //  CHN_CURCABLE      BYTE    1   Current Cable TV Channel.
 167      =1  //
 168      =1  //  FIRSTSAVED_CABLECHN   BYTE  1 First saved Cable TV channel no (maximum 100)
 169      =1  //
 170      =1  //  --- PAL_TV --------------------------------------------------------------
 171      =1  //  PR_CUR          BYTE  1   Current PR no.
 172      =1  //  FIRST_SAVEDPR     DWORD 4   Freq of PR0.  (TOTAL_PR)
 173      =1  //  FIRST_SAVEDPR+4     DWORD   4   Freq of PR1.
 174      =1  //  .....
 175      =1  //
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 32  

 176      =1  
 177      =1  
 178      =1  
 179      =1  //
 180      =1  // Offset of EEPROM
 181      =1  //
 182      =1  /*
 183      =1  #define VIDEOCONTRAST   0x18    // for NTSC.(PAL:0x20,SECAM:0x28)
 184      =1  #define VIDEOBRIGHTNESS   0x19
 185      =1  #define VIDEOSATURATION_U 0x1a
 186      =1  #define VIDEOSATURATION_V 0x1b
 187      =1  #define VIDEOHUE      0x1c    // only for NTSC
 188      =1  #define VIDEOSHARPNESS    0x1d
 189      =1  */
 190      =1  /*
 191      =1  #define CCCOLOR   0x52
 192      =1  #define VOLZOOM   0x53
 193      =1  
 194      =1  #define PANELINFO 0x61
 195      =1  
 196      =1  // PAL_TV
 197      =1  #define  PR_CUR         0x301 
 198      =1  #define  FIRST_SAVEDPR      0x308 
 199      =1   #define TVFREQ_HIGH 0 
 200      =1   #define TVFREQ_LOW  1
 201      =1  #ifdef PAL_TV
 202      =1   #define TVFINETUNE  2
 203      =1      // NOT Finetune: 0 , Range: -32 ~ +32
 204      =1   #define TVPRSYSTEM  3  
 205      =1      // bit 7: Add:1 Ereased :0
 206      =1      // 
 207      =1   #define TVCHNAME    4
 208      =1  
 209      =1   #define BYTEPERCHANNEL 9 
 210      =1  #endif
 211      =1  // NTSC_TV
 212      =1  #define  EEP_TVInputSel     0x302
 213      =1  #define  CHN_CURAIR       0x303 
 214      =1  #define  FIRSTSAVED_AIRCHN    0x308 
 215      =1  #define  CHN_CURCABLE     0x403 
 216      =1  #define  FIRSTSAVED_CABLECHN  0x408 
 217      =1  #ifdef NTSC_TV
 218      =1   #define TVFINETUNE  0
 219      =1      // NOT Finetune: 0 , Range: -32 ~ +32
 220      =1   #define TVPRSYSTEM  1  
 221      =1      // bit 7: Add:1 Ereased :0
 222      =1      // 
 223      =1   #define BYTEPERCHANNEL 2
 224      =1  #endif
 225      =1  
 226      =1  */
 227      =1  
 228      =1  
 229      =1  WORD GetFWRevEE(void);
 230      =1  void SaveFWRevEE(WORD);
 231      =1  
 232      =1  BYTE GetDebugLevelEE(void);
 233      =1  void SaveDebugLevelEE(BYTE);
 234      =1  
 235      =1  #if 0//def WIDE_SCREEN
           =1 BYTE GetWideModeEE(void);
           =1 void SaveWideModeEE(BYTE dl);
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 33  

           =1 #endif
 239      =1  
 240      =1  /*
 241      =1  //BYTE GetRange4CoarseEE(void);
 242      =1  //void SaveRange4CoarseEE(BYTE);
 243      =1  
 244      =1  BYTE GetPossibleAutoDetectStdEE(void);
 245      =1  void SetPossibleAutoDetectStdEE(void);
 246      =1  
 247      =1  //BYTE GetOSDXPositionEE(void);
 248      =1  //BYTE GetOSDYPositionEE(void);
 249      =1  BYTE GetClosedCaptionFlagEE(void);
 250      =1  
 251      =1  BYTE GetVideoDatafromEE(BYTE);
 252      =1  void SaveVideoDatatoEE(BYTE offset, BYTE ndata);
 253      =1  
 254      =1  //BYTE GetVideoBrightnessEE(void);
 255      =1  //BYTE GetVideoSaturationEE(BYTE);
 256      =1  //BYTE GetVideoHueEE(void);
 257      =1  //BYTE GetVideoSharpnessEE(void);
 258      =1  
 259      =1  //void SaveVideoContrastEE(BYTE ndata);
 260      =1  //void SaveVideoBrightnessEE(BYTE ndata);
 261      =1  //void SaveVideoSaturationEE(BYTE, BYTE ndata);
 262      =1  //void SaveVideoHueEE(BYTE ndata);
 263      =1  //void SaveVideoSharpnessEE(BYTE ndata);
 264      =1  
 265      =1  BYTE GetOSDPositionModeEE(void);
 266      =1  void SaveOSDPositionModeEE(BYTE ndata);
 267      =1  //void SaveOSDXPositionEE(BYTE);
 268      =1  //void SaveOSDYPositionEE(BYTE);
 269      =1  
 270      =1  void SaveClosedCaptionFlagEE(BYTE);
 271      =1  
 272      =1  BYTE GetBlockedTVEE(void);      
 273      =1  void SaveBlockedTVEE(BYTE vi);    
 274      =1  BYTE GetBlockedTV_FLDSLEE( BYTE level ) ;
 275      =1  void SaveBlockedTV_FLDSLEE(BYTE level, BYTE vi) ;
 276      =1  
 277      =1  BYTE GetBlockedMovieEE(void);   
 278      =1  void SaveBlockedMovieEE(BYTE vi); 
 279      =1  #if 0
 280      =1  BYTE GetInputSelectionEE(void);
 281      =1  #endif
 282      =1  void SaveInputSelectionEE(BYTE val);
 283      =1  
 284      =1  //BYTE GetOSDDurationEE(void);
 285      =1  //void SaveOSDDurationEE(BYTE val);
 286      =1  
 287      =1  BYTE GetOSDLangEE(void);
 288      =1  void SaveOSDLangEE(BYTE val);
 289      =1  
 290      =1  //ljy100303...BYTE GetOSDZoomEE(void);
 291      =1  //ljy100303...void SaveOSDZoomEE(BYTE val);
 292      =1  
 293      =1  BYTE GetAudioVolEE(void);
 294      =1  void SetAudioVolEE( BYTE vol );
 295      =1  BYTE GetPCAudioVolEE(void);
 296      =1  void SetPCAudioVolEE( BYTE vol );
 297      =1  */
 298      =1  #if 0
           =1 BYTE GetAudioBalanceEE(void);
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 34  

           =1 void SetAudioBalanceEE( BYTE vol );
           =1 BYTE GetAudioBassEE(void);
           =1 void SetAudioBassEE( BYTE vol );
           =1 BYTE GetAudioTrebleEE(void);
           =1 void SetAudioTrebleEE( BYTE vol );
           =1 #endif
 306      =1  //BYTE GetAudioEffectEE(void);
 307      =1  //void SetAudioEffectEE( BYTE vol );
 308      =1  
 309      =1  void ClearBasicEE(void);
 310      =1  /*
 311      =1  BYTE ValidPassword(DATA_P BYTE *numstr, BYTE index);
 312      =1  BYTE SetNewPassword(DATA_P BYTE *numstr, BYTE index);
 313      =1  */
 314      =1  //WORD GetPanelXRes(void);
 315      =1  //WORD GetPanelYRes(void);
 316      =1  /*
 317      =1  BYTE GetPanelHsyncMinPulseWidth(void);
 318      =1  BYTE GetPanelVsyncMinPulseWidth(void);
 319      =1  WORD GetPanelHMinBackPorch(void);
 320      =1  BYTE GetPanelHsyncPolarity(void);
 321      =1  BYTE GetPanelVsyncPolarity(void);
 322      =1  WORD GetPanelDotClock(void);
 323      =1  WORD GetPanelMaxClock(void);
 324      =1  BYTE GetPanelPixsPerClock(void);
 325      =1  // Not used yet *************************  BYTE GetPanelDEonly(void);
 326      =1  
 327      =1  void AddTVChannelEE( BYTE tvtype, BYTE chn);
 328      =1  BYTE GetTVChannelEE( BYTE tvtype, BYTE inx);
 329      =1  void ResetTVChannelEE( BYTE tvtype );
 330      =1  BYTE GetTVChannelCntEE(BYTE tvtype);
 331      =1  BYTE GetTVChnIdxEE(BYTE tvtype);
 332      =1  BYTE GetCurTVChannelEE(BYTE tvtype);
 333      =1  void SetTVChnIdxEE(BYTE tvtype, BYTE newd);
 334      =1  void SetCurTVChannelEE(BYTE tvtype, BYTE newd);
 335      =1  BYTE InsertTVChannelEE(BYTE tvtype, BYTE newd);
 336      =1  BYTE RemoveTVChannelEE(BYTE tvtype, BYTE newd);
 337      =1  
 338      =1  void SetTVPrEE(void);
 339      =1  BYTE GetTVPrEE(void);
 340      =1  void SetTVFreqEE(BYTE, WORD);
 341      =1  WORD GetTVFreqEE(BYTE);
 342      =1  void SetFineTuneEE(BYTE, BYTE);
 343      =1  BYTE GetFineTuneEE(BYTE);
 344      =1  BYTE GetTVPrSystem(BYTE);
 345      =1  void SetTVPrSystem(BYTE, BYTE);
 346      =1  BYTE GetTVInputSelEE(void);
 347      =1  void SetTVInputSelEE(BYTE);
 348      =1  */
 349      =1  /*
 350      =1  #define GetVInputStdDetectModeEE()        ReadEEP(EEP_AUTODETECTTYTE)
 351      =1  #define SaveVInputStdDetectModeEE(A)      WriteEEP(EEP_AUTODETECTTYTE, A)
 352      =1  
 353      =1  #define GetAutoRecogntionEE()         ReadEEP(EEP_AUTORECOGNITION)
 354      =1  #define SaveAutoRecogntionEE(A)         WriteEEP(EEP_AUTORECOGNITION, A)
 355      =1  
 356      =1  #define SetVideoModeEE( ctid )          WriteEEP( EEP_VIDEOMODE, ctid )
 357      =1  #define GetVideoModeEE()            ReadEEP( EEP_VIDEOMODE )
 358      =1  
 359      =1  #define GetPanelContrastEE()          ReadEEP(0x10)
 360      =1  
 361      =1  #if defined( SUPPORT_PC ) || defined( SUPPORT_DTV )
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 35  

 362      =1  //#define GetPanelHueEE()             ReadEEP(0x28)
 363      =1  //#define GetPanelSharpnessEE()         ReadEEP(0x29)
 364      =1  #define GetPanelBrightnessEE()          ReadEEP(0x11)
 365      =1  //#define GetPanelSaturationEE()          ReadEEP(0x2a)
 366      =1  
 367      =1  //#define SavePanelHueEE(A)           WriteEEP(0x28, A)
 368      =1  //#define SavePanelSharpnessEE(A)         WriteEEP(0x29, A)
 369      =1  #define SavePanelContrastEE(A)          WriteEEP(0x10, A)
 370      =1  #define SavePanelBrightnessEE(A)        WriteEEP(0x11, A)
 371      =1  //#define SavePanelSaturationEE(A)        WriteEEP(0x2a, A)
 372      =1  #endif
 373      =1  */
 374      =1  /*
 375      =1  #define GetDigitalVideoContrastEE()       ReadEEP(0x2b)
 376      =1  #define GetDigitalVideoBrightnessEE()     ReadEEP(0x2c)
 377      =1  #define GetDigitalVideoHueEE()          ReadEEP(0x2d)
 378      =1  #define GetDigitalVideoSaturationEE(off)    ReadEEP(0x2e+off)
 379      =1  
 380      =1  #define SaveDigitalVideoContrastEE(A)     WriteEEP(0x2b, A)
 381      =1  #define SaveDigitalVideoBrightnessEE(A)     WriteEEP(0x2c, A)
 382      =1  #define SaveDigitalVideoHueEE(A)        WriteEEP(0x2d, A)
 383      =1  #define SaveDigitalVideoSaturationEE(off,A)   WriteEEP(0x2e+off, A)
 384      =1  */
 385      =1  
 386      =1  #endif  // __ETC_EEP__
  18          #include "Printf.h"
   1      =1  #ifndef __PRINTF__
   2      =1  #define __PRINTF__
   3      =1  
   4      =1  #define _outchar(c) while(1) { if( !RS_Xbusy ) { SBUF = c; RS_Xbusy=1; break; } }
   5      =1  #define Putch(c) _outchar(c)
   6      =1  
   7      =1  #ifdef SERIAL
   8      =1  
   9      =1   void Printf ( const char CODE_P *fmt, ... );
  10      =1   void Puts ( CODE_P char *ptr );
  11      =1  
  12      =1  #define TW2835Cmd(a)   Puts ( a )
  13      =1  
  14      =1  #else
           =1 
           =1  #undef  DEBUG
           =1  #define Printf(a,b)  //
           =1  #define Puts(a)      //
           =1 
           =1 #endif
  21      =1  
  22      =1  
  23      =1  #ifndef DEBUG
  24      =1  
  25      =1   #define dPuts(a)   //
  26      =1   #define wPuts(a)   //
  27      =1   #define ePuts(a)   //
  28      =1  
  29      =1  #else
           =1 
           =1  void dPrintf( const char CODE_P *fmt, ... );
           =1  void wPrintf( const char CODE_P *fmt, ... );
           =1  void ePrintf( const char CODE_P *fmt, ... );
           =1 
           =1  void dPuts( CODE_P char *ptr );
           =1  void wPuts( CODE_P char *ptr );
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 36  

           =1  void ePuts( CODE_P char *ptr );
           =1 
           =1 #endif  // DEBUG
  40      =1  
  41      =1  BYTE Getch(void);
  42      =1  BYTE Getche(void);
  43      =1  
  44      =1  
  45      =1  #endif  //__PRINTF__
  19          #include "KeyRemo.h"
   1      =1  #ifndef __KEYREMO_H__
   2      =1  #define __KEYREMO_H__
   3      =1  
   4      =1  //
   5      =1  // KeyRemo.h
   6      =1  // Default function for Key Input and Remocon Input
   7      =1  //
   8      =1  //=============================================================================
   9      =1  //                        Operation Key Mapping
  10      =1  //=============================================================================
  11      =1  
  12      =1  
  13      =1  
  14      =1  /*
  15      =1  
  16      =1  #define ResetKey()    { P2 = 0xff;}
  17      =1  //#define ReadKey()   (~P1 & 0xfc);
  18      =1  
  19      =1  
  20      =1  #define DVR_POWER 0x01
  21      =1  #define DVR_MENU  0x03
  22      =1  #define DVR_RECORD  0x05
  23      =1  #define DVR_PLAY  0x07
  24      =1  #define DVR_STOP  0x09
  25      =1  #define DVR_RIGHT 0x0b
  26      =1  #define DVR_LEFT  0x0d
  27      =1  #define DVR_UP    0x10
  28      =1  #define DVR_DOWN  0x12
  29      =1  #define DVR_RESET 0x13
  30      =1  #define DVR_FAC     0x99
  31      =1  #define DVR_RESET_OSD   0x98
  32      =1  */
  33      =1  
  34      =1  #if 0//def QUAD
           =1 #define EVENTKEY    0x02
           =1 #endif
  37      =1  /*
  38      =1  #define POWERKEY    0x04 //andy AWT 980907
  39      =1  #define MENUKEY     0x08
  40      =1  #define INPUTSOURCEKEY  0x10
  41      =1  #define UPKEY       0x20
  42      =1  #define DOWNKEY       0x40
  43      =1  #define SELECTKEY     0x80
  44      =1  #define VersionKEY      0x90
  45      =1  #define PLAYKEY         0x01
  46      =1  
  47      =1  #define REMO_CUSTOM   0
  48      =1  
  49      =1  #define REMO_NUM0   0
  50      =1  #define REMO_NUM1   1
  51      =1  #define REMO_NUM2   2
  52      =1  #define REMO_NUM3   3
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 37  

  53      =1  #define REMO_NUM4   4
  54      =1  #define REMO_NUM5   5
  55      =1  #define REMO_NUM6   6
  56      =1  #define REMO_NUM7   7
  57      =1  #define REMO_NUM8   8
  58      =1  #define REMO_NUM9   9
  59      =1  
  60      =1  #define REMO_STANDBY  12
  61      =1  #define REMO_CHNUP    32
  62      =1  #define REMO_CHNDN    33
  63      =1  #define REMO_VOLUP    16
  64      =1  #define REMO_VOLDN    17
  65      =1  #define REMO_SELECT   21
  66      =1  #define REMO_MENU   63
  67      =1  #define REMO_MUTE   13
  68      =1  #define REMO_INPUT    56
  69      =1  
  70      =1  #define REMO_AUTO   10
  71      =1  #define REMO_INFO   58
  72      =1  #define REMO_AUDIO    38
  73      =1  #define REMO_ASPECT   62
  74      =1  #define REMO_CC     15
  75      =1  #define REMO_EXIT   0x16
  76      =1  
  77      =1  #define REMO_TTXRED     0x37
  78      =1  #define REMO_TTXGREEN   0x36
  79      =1  #define REMO_TTXYELLOW    0x32
  80      =1  #define REMO_TTXCYAN    0x34
  81      =1  
  82      =1  */
  83      =1  
  84      =1  //=============================================================================
  85      =1  //                                 RC5 type
  86      =1  //=============================================================================
  87      =1  #if 0//def REMO_RC5
           =1 
           =1 #ifdef TECHWELL_REMOCON
           =1 #define REMO_CUSTOM   0
           =1 
           =1 #define REMO_NUM0   0
           =1 #define REMO_NUM1   1
           =1 #define REMO_NUM2   2
           =1 #define REMO_NUM3   3
           =1 #define REMO_NUM4   4
           =1 #define REMO_NUM5   5
           =1 #define REMO_NUM6   6
           =1 #define REMO_NUM7   7
           =1 #define REMO_NUM8   8
           =1 #define REMO_NUM9   9
           =1 
           =1 #define REMO_STANDBY  12
           =1 #define REMO_CHNUP    32
           =1 #define REMO_CHNDN    33
           =1 #define REMO_VOLUP    16
           =1 #define REMO_VOLDN    17
           =1 #define REMO_SELECT   21
           =1 #define REMO_MENU   63
           =1 //#define REMO_TV     63
           =1 //#define REMO_VCR    60
           =1 //#define REMO_SVIDEO   56
           =1 #define REMO_MUTE   13
           =1 #define REMO_INPUT    56
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 38  

           =1 
           =1 #define REMO_AUTO   10
           =1 #define REMO_INFO   58
           =1 #define REMO_AUDIO    38
           =1 #define REMO_ASPECT   62
           =1 #define REMO_CC     15
           =1 #define REMO_EXIT   0x16
           =1 
           =1 #define REMO_TTXRED     0x37
           =1 #define REMO_TTXGREEN   0x36
           =1 #define REMO_TTXYELLOW    0x32
           =1 #define REMO_TTXCYAN    0x34
           =1 
           =1 #ifdef SUPPORT_DEBUG
           =1 #define REMO_DEBUG    0x2b
           =1 #define REMO_READ   0x29
           =1 #define REMO_WRITE    0x2a
           =1 #define REMO_RESERVED 0x30
           =1 #endif
           =1 
           =1 #else 
           =1 #define REMO_CUSTOM   0
           =1 
           =1 #define REMO_NUM0   0
           =1 #define REMO_NUM1   1
           =1 #define REMO_NUM2   2
           =1 #define REMO_NUM3   3
           =1 #define REMO_NUM4   4
           =1 #define REMO_NUM5   5
           =1 #define REMO_NUM6   6
           =1 #define REMO_NUM7   7
           =1 #define REMO_NUM8   8
           =1 #define REMO_NUM9   9
           =1 
           =1 #define REMO_STANDBY  12
           =1 #define REMO_CHNUP    32
           =1 #define REMO_CHNDN    33
           =1 #define REMO_VOLUP    16
           =1 #define REMO_VOLDN    17
           =1 #define REMO_SELECT   18
           =1 #define REMO_MENU   48
           =1 #define REMO_TV     63
           =1 #define REMO_VCR    60
           =1 #define REMO_SVIDEO   56
           =1 #define REMO_MUTE   13
           =1 #define REMO_INPUT    0xff
           =1 
           =1 #define REMO_INFO   0x0a //??
           =1 #endif
           =1 
           =1 //=============================================================================
           =1 //                                 NEC type
           =1 //=============================================================================
           =1 #elif defined REMO_NEC
           =1 /*
           =1 // Techwell Origin
           =1 #define REMO_CUSTOM1  0x20
           =1 #define REMO_CUSTOM2  0xdf
           =1 
           =1 
           =1 #define REMO_NUM0   0x08
           =1 #define REMO_NUM1   0x88
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 39  

           =1 #define REMO_NUM2   0x48
           =1 #define REMO_NUM3   0xc8
           =1 #define REMO_NUM4   0x28
           =1 #define REMO_NUM5   0xa8
           =1 #define REMO_NUM6   0x68
           =1 #define REMO_NUM7   0xe8
           =1 #define REMO_NUM8   0x18
           =1 #define REMO_NUM9   0x98
           =1 
           =1 #define REMO_STANDBY  0x10
           =1 #define REMO_CHNUP    0x00
           =1 #define REMO_CHNDN    0x80
           =1 #define REMO_VOLUP    0x40
           =1 #define REMO_VOLDN    0xc0
           =1 #define REMO_SELECT   0x70
           =1 #define REMO_MENU   0x9c
           =1 #define REMO_MUTE   0x90
           =1 #define REMO_INPUT    0xd0
           =1 */
           =1 
           =1 // Techwell New Remocon after 4/7/2005
           =1 #if 0//def PHILIPS_REMOCON
           =1 #define REMO_CUSTOM1  0x02
           =1 #define REMO_CUSTOM2  0xfd
           =1 
           =1 #define REMO_NUM0   0x00
           =1 #define REMO_NUM1   0x80
           =1 #define REMO_NUM2   0x40
           =1 #define REMO_NUM3   0xc0
           =1 #define REMO_NUM4   0x20
           =1 #define REMO_NUM5   0xa0
           =1 #define REMO_NUM6   0x60
           =1 #define REMO_NUM7   0xe0
           =1 #define REMO_NUM8   0x10
           =1 #define REMO_NUM9   0x90
           =1 
           =1 #define REMO_STANDBY  0x48
           =1 #define REMO_CHNUP    0xd8
           =1 #define REMO_CHNDN    0xf8
           =1 #define REMO_VOLUP    0x58
           =1 #define REMO_VOLDN    0x78
           =1 #define REMO_SELECT   0xe8
           =1 #define REMO_MENU   0x01
           =1 #define REMO_MUTE   0x08
           =1 #define REMO_INPUT    0xf0
           =1 
           =1 #define REMO_INFO   0x38
           =1 
           =1 
           =1 
           =1 #define REMO_TTXRED     0x4E
           =1 #define REMO_TTXGREEN   0x8E
           =1 #define REMO_TTXYELLOW    0xC6
           =1 #define REMO_TTXCYAN    0x86
           =1 
           =1 /#else
           =1 // RYU For Test
           =1 #define REMO_CUSTOM1    0x04
           =1 #define REMO_CUSTOM2    0xfb
           =1 
           =1 #define REMO_NUM0   0xf8
           =1 #define REMO_NUM1   0x48
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 40  

           =1 #define REMO_NUM2   0xc8
           =1 #define REMO_NUM3   0x28
           =1 #define REMO_NUM4   0xa8
           =1 #define REMO_NUM5   0x18
           =1 #define REMO_NUM6   0x98
           =1 #define REMO_NUM7   0x58
           =1 #define REMO_NUM8   0xd8
           =1 #define REMO_NUM9   0x78
           =1 
           =1 #define REMO_STANDBY  0x00
           =1 #define REMO_CHNUP    0x40  //
           =1 #define REMO_CHNDN    0x70  //
           =1 #define REMO_VOLUP    0x90  //
           =1 #define REMO_VOLDN    0xe0  //
           =1 #define REMO_SELECT   0x11//??
           =1 #define REMO_MENU   0x10
           =1 
           =1 #define REMO_MUTE   0x60
           =1 #define REMO_INPUT    0xc0
           =1 #define REMO_AUTO   0x30
           =1 #define REMO_AUTOSCAN 0x80
           =1 #define REMO_TV     0x20
           =1 #define REMO_EXIT   0xa0
           =1 #define REMO_INFO   0x08
           =1 #define REMO_ASPECT   0x62
           =1 
           =1 #define REMO_TTXRED   0xb8
           =1 #define REMO_TTXGREEN 0x02
           =1 #define REMO_TTXYELLOW  0x82
           =1 #define REMO_TTXCYAN  0x42
           =1 
           =1 #ifdef SUPPORT_DEBUG
           =1 #define REMO_DEBUG    0xb8
           =1 #define REMO_READ   0x02
           =1 #define REMO_WRITE    0x82
           =1 #endif
           =1 
           =1 #endif //PHILIPS_REMOCON
           =1 
           =1 #endif // REMO_NEC
 279      =1  
 280      =1  BYTE GetKey(BYTE repeat);
 281      =1  void Scankey(void);
 282      =1  
 283      =1  /*
 284      =1  BYTE ActionRemo(BYTE, BYTE);
 285      =1  BYTE CheckKeyIn(void);
 286      =1  
 287      =1  BYTE IsRemoDataReady(BYTE *, BYTE *);
 288      =1  
 289      =1  void protocol_send_cmd_with_param_num(unsigned char type, unsigned char* param, unsigned char len) ;
 290      =1  BYTE ScanPowerkey(void);
 291      =1  */
 292      =1  
 293      =1  #endif
  20          #include "Monitor.h"
   1      =1  #ifndef __MONITOR__H_
   2      =1  #define __MONITOR__H_
   3      =1  
   4      =1  
   5      =1  /* monitor.h */
   6      =1  
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 41  

   7      =1  
   8      =1  void Mon_tx(BYTE ch);
   9      =1  
  10      =1  void MonHelp(void);
  11      =1  BYTE MonGetCommand(void);
  12      =1  void Monitor(void);
  13      =1  void Prompt(void);
  14      =1  
  15      =1  BYTE GetMonAddress(void);
  16      =1  void SetMonAddress(BYTE addr);
  17      =1  void MonReadI2C(void);
  18      =1  void MonWriteI2C(void);
  19      =1  extern void SET_PWM(BYTE index, BYTE val);
  20      =1  
  21      =1  #endif
  21          #include "CPU.h"
   1      =1  #ifndef __CPU__
   2      =1  #define __CPU__
   3      =1  
   4      =1  /*
   5      =1  #ifdef INTERNAL_MCU
   6      =1  #define I2C_SCL   P2_0
   7      =1  #else
   8      =1  #define I2C_SCL   P1_0
   9      =1  #endif
  10      =1  #define I2C_SDA   P1_1
  11      =1  */
  12      =1  #define I2C_SCL   P1_0
  13      =1  #define I2C_SDA   P1_1
  14      =1  #define BUF_MAX   8
  15      =1  #define DVR_BUF_MAX   30
  16      =1  
  17      =1  //--------------------------------------------------
  18      =1  // Panel  Related MACRO
  19      =1  //--------------------------------------------------
  20      =1  #define GET_P_IO1()   (P3_4)  
  21      =1  #define SET_P_IO1()   (P3_4 = 1)    
  22      =1  #define CLR_P_IO1()   (P3_4 = 0)  
  23      =1  
  24      =1  #define GET_P_IO2()   (P3_5)  
  25      =1  #define SET_P_IO2()   (P3_5 = 1)    
  26      =1  #define CLR_P_IO2()   (P3_5 = 0)  
  27      =1  
  28      =1  #define GET_BL_PWM()    (P1_4)  
  29      =1  #define SET_BL_PWM()    (P1_4 = 1)    //ON
  30      =1  #define CLR_BL_PWM()    (P1_4 = 0)  //OFF
  31      =1  
  32      =1  #define GET_PCON3V3_P()  (P0_3) 
  33      =1  #define SET_PCON3V3_P()  (P0_3 = 0)    //ON
  34      =1  #define CLR_PCON3V3_P()  (P0_3 = 1) //OFF
  35      =1  
  36      =1  #define GET_PCON5V_P()   (P0_4) 
  37      =1  #define SET_PCON5V_P()   (P0_4 = 0)    //ON
  38      =1  #define CLR_PCON5V_P()   (P0_4 = 1) //OFF
  39      =1  
  40      =1  #define GET_Panel_EN()   (P2_1) 
  41      =1  #define SET_Panel_EN()   (P2_1 = 1)    //ON
  42      =1  #define CLR_Panel_EN()   (P2_1 = 0) //OFF
  43      =1  
  44      =1  #define GET_CTP_INT()   (P2_4)  
  45      =1  #define SET_CTP_INT()   (P2_4 = 1)     //ON
  46      =1  #define CLR_CTP_INT()   (P2_4 = 0)  //OFF
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 42  

  47      =1  
  48      =1  #define GET_CTP_RST()   (P2_5)  
  49      =1  #define SET_CTP_RST()   (P2_5 = 1)     //ON
  50      =1  #define CLR_CTP_RST()   (P2_5 = 0)  //OFF
  51      =1  
  52      =1  #define GET_PWCTRL()    (P3_7)  
  53      =1  #define SET_PWCTRL()    (P3_7 = 1)     //ON
  54      =1  #define CLR_PWCTRL()    (P3_7 = 0)  //OFF
  55      =1  
  56      =1  //--------------------------------------------------
  57      =1  // Battery  Related MACRO
  58      =1  //--------------------------------------------------
  59      =1  
  60      =1  #define GET_PWR_GOOD()  (P1_5)    
  61      =1  
  62      =1  #define GET_STAT1()   (P0_0)    
  63      =1  #define GET_STAT2()   (P0_1)    
  64      =1  
  65      =1  #define GET_CHG_CURR()    (P0_6)  
  66      =1  #define SET_CHG_CURR()    (P0_6 = 1)     //ON
  67      =1  #define CLR_CHG_CURR()    (P0_6 = 0)  //OFF
  68      =1  
  69      =1  #define GET_AC_MODE()   (P4_2)  
  70      =1  #define SET_AC_MODE()   (P4_2 = 1)     //ON
  71      =1  #define CLR_AC_MODE()   (P4_2 = 0)  //OFF
  72      =1  
  73      =1  //--------------------------------------------------
  74      =1  // DVR Power  Related MACRO
  75      =1  //--------------------------------------------------
  76      =1  
  77      =1  #define GET_BAT_SYS()   (P2_6)  
  78      =1  #define SET_BAT_SYS()   (P2_6 = 1)     //ON
  79      =1  #define CLR_BAT_SYS()   (P2_6 = 0)  //OFF
  80      =1  
  81      =1  //--------------------------------------------------
  82      =1  // CAM Power  Related MACRO
  83      =1  //--------------------------------------------------
  84      =1  
  85      =1  #define GET_PCON_CAM()    (P2_2)  
  86      =1  #define SET_PCON_CAM()    (P2_2 = 1)     //ON
  87      =1  #define CLR_PCON_CAM()    (P2_2 = 0)  //OFF
  88      =1  
  89      =1  //--------------------------------------------------
  90      =1  // TW8836 Power  Related MACRO
  91      =1  //--------------------------------------------------
  92      =1  
  93      =1  #define GET_PCON3V3_TW()    (P3_6)  
  94      =1  #define SET_PCON3V3_TW()    (P3_6 = 0)     //ON
  95      =1  #define CLR_PCON3V3_TW()    (P3_6 = 1)  //OFF
  96      =1  
  97      =1  #define GET_TW8836_RST()      (P2_0)  
  98      =1  #define SET_TW8836_RST()      (P2_0 = 0)     //ON
  99      =1  #define CLR_TW8836_RST()      (P2_0 = 1)  //OFF
 100      =1  
 101      =1  
 102      =1  //--------------------------------------------------
 103      =1  // I/O board  Related MACRO
 104      =1  //--------------------------------------------------
 105      =1  
 106      =1  #define GET_GREEN()       (P4_0)  
 107      =1  #define SET_GREEN()       (P4_0 = 0)     
 108      =1  #define CLR_GREEN()       (P4_0 = 1)  
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 43  

 109      =1  
 110      =1  #define GET_RED()         (P4_1)  
 111      =1  #define SET_RED()         (P4_1 = 0)     
 112      =1  #define CLR_RED()         (P4_1 = 1)  
 113      =1  
 114      =1  #define GET_PSW()       (P4_3)  
 115      =1  #define SET_PSW()       (P4_3 = 1)     
 116      =1  #define CLR_PSW()       (P4_3 = 0)  
 117      =1  
 118      =1  #define GET_ADAP_12()     (P0_5)  
 119      =1  #define SET_ADAP_12()     (P0_5 = 1)     
 120      =1  #define CLR_ADAP_12()     (P0_5 = 0)  
 121      =1  
 122      =1  
 123      =1  #ifdef REMO_RC5
           =1 #define EnableRemoconInt()  { RemoDataReady = 0;  EX0 = 1;}
           =1 #endif
 126      =1  void  InitCPU(void);
 127      =1  void  InitVars(void);
 128      =1  void  InitTechwell(void);
 129      =1  void  main_init (void);
 130      =1  void  PowerDown( void );
 131      =1  #if 0
           =1 BYTE  OKSleepTime(void);
           =1 #endif
 134      =1  #ifdef REMO_RC5
           =1 void  InitForRemo(void);
           =1 #endif
 137      =1  void  PowerLED(BYTE flag);
 138      =1  void    Wait_ms(WORD Tms);
 139      =1  BYTE    TW2835Command(char,char,char,char,char);
 140      =1  void SET_PWM(BYTE index, BYTE val);
 141      =1  
 142      =1  #endif
  22          #include "HS_DVRProtocol.h"
   1      =1  
   2      =1  #ifndef _HS_DVRProtocol_
   3      =1  #define _HS_DVRProtocol_
   4      =1  
   5      =1  //==================================================
   6      =1  //
   7      =1  //
   8      =1  //
   9      =1  //==================================================
  10      =1  /*
  11      =1  #define bSetDVRParam  0x0001
  12      =1  #define bSetDVRDefault  0x0002
  13      =1  #define bSetDATETIME  0x0004
  14      =1  #define bGetDVRParam  0x0008
  15      =1  #define bGetDVRStatus 0x0010
  16      =1  #define bGetDATETIME  0x0020
  17      =1  #define bBOOKMARK   0x0040
  18      =1  #define bSetSystem    0x0080
  19      =1  #define bHalt_Start     0x0100
  20      =1  #define bSetFormatSD    0x0200  
  21      =1  #define bGetDVRVersion  0x0400  
  22      =1  #define bFW_Update_Start 0x0800
  23      =1  #define bUpdate_CONFIG  0x1000
  24      =1  #define bDoorClose    0x2000
  25      =1  #define bDoorOpen     0x4000
  26      =1  */
  27      =1  //DVR to MCU command 
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 44  

  28      =1  
  29      =1  #define MCU_PROTOCOL_CMD_SYS_READY_NOTICE   0x01///DVR system ready notice
  30      =1  #define MCU_PROTOCOL_CMD_WATCH_DOG_KICK     0x02///DVR WDT kick
  31      =1  #define MCU_PROTOCOL_CMD_ENTRY_SLEEP        0x03///DVR sleep mode
  32      =1  #define MCU_PROTOCOL_CMD_DISTANCE_RESET     0x04///DVR distance reset  0M
  33      =1  #define MCU_PROTOCOL_CMD_ENCODER_SET        0x05///Encoder deviation setting
  34      =1  #define MCU_PROTOCOL_CMD_CAMERA_VOLTAGE     0x06///Camera voltage adjust
  35      =1  #define MCU_PROTOCOL_CMD_STOP_REBOOT                        0x07///stop retoot 
  36      =1  #define MCU_PROTOCOL_CMD_GET_MCU_FW     0x10///MCU FW version
  37      =1  #define MCU_PROTOCOL_CMD_DVR_REBOOT     0x11///DVR Reboot
  38      =1  #define MCU_PROTOCOL_CMD_DVR_SHUTDOWN   0x12///DVR shutdown
  39      =1  
  40      =1  //MCU to DVR command 
  41      =1  #define MCU_PROTOCOL_CMD_REPLY_MCU_FW     0x80  //Reply MCU firmware version
  42      =1  #define MCU_PROTOCOL_CMD_REGULAR_DATA       0x81      //Regular data
  43      =1  #define MCU_PROTOCOL_CMD_SYSTEM_SHUTDOWN    0x82      //system shutdown
  44      =1  #define MCU_PROTOCOL_CMD_ENTRY_FACTORY      0x83      //Entry factory mode
  45      =1  
  46      =1  // 3521 Command
  47      =1  #define CMD_TEMP      0x0A
  48      =1  #define CMD_BATERY      0x0B
  49      =1  #define CMD_ROLLENC     0x0C
  50      =1  #define CMD_MCU_ROLLENC     0x80
  51      =1  #define CMD_MCU_TEMP      0x8A
  52      =1  #define CMD_MCU_BATERY    0x8B
  53      =1  #define CMD_DVR_PING        0x00
  54      =1  
  55      =1  #define CMD_OSDTYPE      0x11
  56      =1  #define CMD_KEY        0x12
  57      =1  #define CMD_BRIGHTNESS     0x13
  58      =1  #define CMD_GET_VERSION    0x18
  59      =1  #define CMD_RESPONSE_VERSION 0x09
  60      =1  #define CMD_REC_LED          0x0D
  61      =1  #define CMD_Protect_POWER  0x39
  62      =1  #define CMD_POWER_ON         0x38
  63      =1  #define CMD_BATT_Lo     0x40
  64      =1  
  65      =1  #define CMD_POWER_SEL        0x0E
  66      =1  #define CMD_POWER_LINK     0x0F
  67      =1  
  68      =1  
  69      =1  
  70      =1  
  71      =1  #define PROTOCOL_DEFINE
  72      =1  
  73      =1  #define PROTOCOL_DATA_LENGTH                256
  74      =1  
  75      =1  #define PROTOCOL_STATE_NONE               0
  76      =1  #define PROTOCOL_STATE_TYPE               1
  77      =1  #define PROTOCOL_STATE_LENGTH             2
  78      =1  #define PROTOCOL_STATE_DATA               3
  79      =1  #define PROTOCOL_STATE_CHECKSUM             4
  80      =1  
  81      =1  #define PROTOCOL_MCU_VERSION                          0x22
  82      =1  #define PROTOCOL_CMD_GET_VERSION                      0x08
  83      =1  #define PROTOCOL_RESPONSE_VERSION           0x09
  84      =1  
  85      =1  #define PROTOCOL_CMD_ENTER_ISP              0x30
  86      =1  #define PROTOCOL_CMD_ISP_PING             0x31
  87      =1  #define PROTOCOL_CMD_ISP_ERASE              0x32
  88      =1  #define PROTOCOL_CMD_ISP_WRITE              0x33
  89      =1  #define PROTOCOL_CMD_ISP_READ             0x34
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 45  

  90      =1  #define PROTOCOL_CMD_ISP_SEND_DATA            0x35
  91      =1  #define PROTOCOL_CMD_ISP_ACK              0x36
  92      =1  #define PROTOCOL_CMD_ISP_NAK              0x37
  93      =1  #define PROTOCOL_CMD_ISP_REBOOT             0x38
  94      =1  
  95      =1  enum BATERY_State
  96      =1  {
  97      =1   BATERY_100,
  98      =1   BATERY_75,
  99      =1   BATERY_50,
 100      =1   BATERY_25,
 101      =1   BATERY_10,
 102      =1   BATERY_AC
 103      =1  };
 104      =1  
 105      =1  enum BRIGHTNESS_STATE
 106      =1  {
 107      =1    BRIGHTNESS_MIN,
 108      =1    BRIGHTNESS_NORMAL,
 109      =1    BRIGHTNESS_MAX
 110      =1  };
 111      =1  
 112      =1  enum POWER_STATE
 113      =1  {
 114      =1    POWER_SEL_ON,
 115      =1    POWER_SEL_OFF,
 116      =1    POWER_SEL_SAVING
 117      =1  };
 118      =1  
 119      =1  enum TEMP_State
 120      =1  {
 121      =1   TEMP_OK,
 122      =1   TEMP_Alarm1,
 123      =1   TEMP_Alarm2
 124      =1  };
 125      =1  /*
 126      =1  enum HS_DvrCommand
 127      =1  {
 128      =1    CMD_NULL,
 129      =1    SetDVRParam,  // 1
 130      =1    SetDVRDefault,
 131      =1    SetDATETIME,
 132      =1    GetDVRParam,
 133      =1    GetDVRStatus,
 134      =1    GetDATETIME, 
 135      =1    SetFormatSD, 
 136      =1    SendAlarm, 
 137      =1    GetDVRVersion=0x09, 
 138      =1    SendDVRStatus=0x14,
 139      =1    GetLCDMode=0x15,
 140      =1    SendDVRParam=0x16,
 141      =1    SendDVRParamDT=0x17,
 142      =1    SetFormatSDDone=0x18,
 143      =1    GetInformation=0x19,
 144      =1    SetSystem=0x1a,
 145      =1    GPSReset=0x1b,
 146      =1    Halt_Start=0xc8,
 147      =1    Halt_OK=0xc9,
 148      =1    FW_Update_Start=0xca,
 149      =1    FW_Update_OK=0xcb,
 150      =1    MANUALRECSTART=0xdc,
 151      =1    MANUALRECSTOP=0xdd,
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 46  

 152      =1    SNAPSHOT=0xde,
 153      =1    BOOKMARK=0xdf,
 154      =1    Update_CONFIG=0xe0,
 155      =1    Update_CONFIG_OK=0xe1,
 156      =1    DoorOpen=0xe2,
 157      =1    DoorClose=0xe3,
 158      =1    CMD_UNKNOWN=0xff,
 159      =1    CMD_NUM
 160      =1  };
 161      =1  */
 162      =1  
 163      =1  //RS485 TX or RX define
 164      =1  /*
 165      =1  enum
 166      =1  {
 167      =1    RS485_TX,   //RS485 Transmit  
 168      =1    RS485_RX    //Rs485 Receive
 169      =1  };
 170      =1  
 171      =1  enum
 172      =1  {
 173      =1    Baud_rate2400,    
 174      =1    Baud_rate4800,  
 175      =1    Baud_rate9600
 176      =1  };
 177      =1  
 178      =1  
 179      =1  
 180      =1  //Camera Command ID define
 181      =1  enum
 182      =1  {
 183      =1  //  CAM_CLEAR,        //Clear 
 184      =1    CAM_ZOOM_OUT_START,     //Zoom Out  Start
 185      =1  //  CAM_ZOOM_OUT_END,     //Zoom Out  End
 186      =1    CAM_ZOOM_IN_START,      //Zoom In Start
 187      =1  //  CAM_ZOOM_IN_END,      //Zoom In End
 188      =1  //  CAM_IRIS_CLOSE_START,   //IRIS Close Start
 189      =1  //  CAM_IRIS_CLOSE_END,   //IRIS Close End
 190      =1  //  CAM_IRIS_OPEN_START,      //IRIS Open Start
 191      =1  //  CAM_IRIS_OPEN_END,      //IRIS Open End
 192      =1  //  CAM_FOCUS_FAR_START,    //Focus Far Start
 193      =1  //  CAM_FOCUS_FAR_END,    //Focus Far End
 194      =1  //  CAM_FOCUS_NEAR_START,   //Focus Near Start
 195      =1  //  CAM_FOCUS_NEAR_END,   //Focus Near End
 196      =1    CAM_SET,        //Set 
 197      =1    CAM_CALL,       //Call 
 198      =1  //  CAM_FOCUS_SPEED,    //Focus Speed
 199      =1  //  CAM_ZOOM_SPEED,   //Zoom Speed
 200      =1    CAM_PTZ_RIGHT,      //PTZ Right 
 201      =1    CAM_PTZ_LEFT,     //PTZ Left
 202      =1    CAM_PTZ_UP,     //PTZ Up
 203      =1    CAM_PTZ_DOWN,     //PTZ Down
 204      =1    CAM_MENU_ENTER,     //PTZ Down
 205      =1    CAM_Iris_Open,
 206      =1  
 207      =1  //  CAM_PTZ_RIGHT_UP,   //PTZ Right with Up
 208      =1  //  CAM_PTZ_RIGHT_DOWN, //PTZ Right with Down
 209      =1  //  CAM_PTZ_LEFT_UP,    //PTZ Left with Up
 210      =1  //  CAM_PTZ_LEFT_DOWN,  //PTZ Left with Down
 211      =1    CAM_PTZ_STOP      //PTZ Control Stop
 212      =1  };
 213      =1  */
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 47  

 214      =1  
 215      =1  void Hs_DvrTxCmdPaser(BYTE Cmd_Id );
 216      =1  void Hs_Protocol_Init(void);
 217      =1  void DvrReceivePaser(void);
 218      =1  void DVRCommandReSend(void);
 219      =1  extern void MCUTimerDelayXms(WORD usNum);
 220      =1  
 221      =1  
 222      =1  #if 0
           =1 BYTE TW2835ReceivePaser(void);
           =1 #endif
 225      =1  extern bit   DVR_Ready;
 226      =1  void CAM_TxCommand_toRS485(BYTE Com_ID);
 227      =1  void Send_PelcoP_Command(void);
 228      =1  void Send_PelcoD_Command(void);
 229      =1  void Send_GE_Command(void);
 230      =1  
 231      =1  
 232      =1  
 233      =1  
 234      =1  #endif
 235      =1  
  23          
  24          
  25          StructBatteryInfoType g_stBatteryInfo = {0};
  26          
  27          
  28          extern DATA  DWORD tic_Init_time;
  29          
  30          
  31          
  32          BYTE  PowerFlag;
  33          BYTE  CameraVolt;
  34          /*
  35          
  36          BYTE DVR_AudioRecord;
  37          bit VGAflag=0;
  38          bit   PowerDownStart=0;
  39          bit AccPowerDown=0;
  40          bit DVRReSendDisable;
  41          BYTE  Commanderror;
  42          BYTE AutoDayNightDelay=0;
  43          DATA BYTE PWMLevel=0;
  44          BYTE displayhold_flag;
  45          BYTE  ReverseModeFlag;
  46          BYTE  BATERY_STAT=0x04,BATERY_STAT_TEMP=0xFE;
  47          
  48          BYTE  ACmode=0;
  49          BYTE  ACmodeStatus;
  50          
  51          BYTE  BAT_param[2];
  52          BYTE  TEMP_param[2];
  53          BYTE  PROTECT[1];
  54          extern bit Power_On_Display_Msg_Flag;
  55          volatile BYTE  OSD_TEMP_STAT=0x00,TEMP_STAT_TEMP=0x01;
  56          
  57          BYTE OSD_TYPE_FLAG=0;
  58          BYTE OSD_LANGUAGE=1;
  59          BYTE OSD_BRIGHTNESS_FLAG=0;
  60          BYTE Ready_Flag=0;
  61          */
  62          //#ifdef AWT_ML072S //william @20130902 v1.0.1.2
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 48  

  63          //bit   JUMPAVFlag;
  64          //#endif
  65          
  66          float EncorderLen;
  67          WORD EncorderLen_Offset=0;
  68          BYTE EncorderLenint,EncorderCountPN,EncorderCountPN_offset;
  69          WORD EncorderLenfloaat;
  70          //BYTE Encorder1=0.85,Encorder2=0.8,Encorder3=0.75,Encorder4=0.75;
  71          float Encorder1=100,Encorder2=100,Encorder3=100,Encorder4=100;
  72          /*
  73          float TempAlarm1=0x36,TempAlarm2=0x26;
  74          float BattDetect1=0xF8,BattDetect2=0xED,BattDetect3=0xE3,BattDetect4=0xCD;
  75          BYTE BattDetect1_COUNT=0, BattDetect2_COUNT=0, BattDetect3_COUNT=0, BattDetect4_COUNT=0;
  76          BYTE BattDetect5_COUNT=0,BattDetect6_COUNT=0;
  77          BYTE TEMP1_COUNT=0, TEMP2_COUNT=0, TEMP3_COUNT=0;
  78          extern bit POWER_LINK_FLAG;
  79          extern BYTE Power_Active;
  80          extern DATA DWORD tic_PWR_SAVING;
  81          extern  volatile bit PWR_SAVING_ACT_FLAG;
  82          extern bit PWR_OFF_KEY_LOCK;
  83          
  84          BYTE FWUPDATE_FLAG =0;
  85          */
  86          
  87          //BYTE Protect_Power_Flag=1;
  88          extern BYTE FLASH_FLAG;
  89          extern WORD LED_FLASH_COUNT;
  90          extern bit ChangeKey;
  91          extern short EncorderCount;
  92          
  93          extern  DATA  WORD  tic_pc;
  94          extern DATA BYTE  RS_in;
  95          extern DATA BYTE  RS2_in;
  96          extern DATA BYTE    RS_buf2[BUF_MAX];
  97          /*
  98          extern bit DVR_Ready;
  99          extern bit  GetDVRStatusflag;
 100          extern bit DoorState;
 101          extern bit CAM_PTZ_RUN_flag;
 102          extern bit Init_DisplayInput;
 103          extern BYTE SelectBoxMode;
 104          extern BYTE LockKeyState;
 105          extern BYTE second;
 106          extern BYTE PowerDownWait;
 107          extern BYTE SelectBoxADC;
 108          extern BYTE Information[1];
 109          extern BYTE DVR_System;
 110          extern BYTE DayNightLevel;
 111          */
 112          //#ifdef Format_SDCard
 113          /*
 114          extern BYTE FormatSDCard;
 115          //#endif
 116          extern BYTE DVR_SDCardAvailable;
 117          extern WORD CommandBuffer;
 118          
 119          extern BYTE Power_Saving_Flag;
 120          extern bit Display_Msg_Flag,Power_On_Display_Msg_Flag;
 121          */
 122          struct RegisterInfo UserRange={0,100,50};
 123          struct RegisterInfo AD5110Range={0,127,86};
 124          
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 49  

 125          BYTE  DebugLevel;
 126          
 127          //extern void CheckPanelImage(void);
 128          //extern CODE BYTE Init_Osd_DisplayDVRstatus[];
 129          
 130          /*
 131              BYTE  InputSelection;
 132          //    IDATA BYTE  InputSelectionInx = 0;
 133          ///     bit   PcDetectFlag = 1;
 134          //    bit   PowerMode = ON;
 135              IDATA WORD  IVF;
 136              IDATA DWORD IHF;
 137              BYTE  VInputStd;
 138          
 139              bit   Range4Coarse=0;
 140              //bit   AutoDetect=0;
 141              BYTE  VInputStdDetectMode;
 142              //BYTE  CheckBuf;
 143              BYTE  SEQTime;
 144              //bit  AutoDayNight=1;
 145              bit SDCardCoverDetect;
 146          */
 147          /*
 148          CODE struct struct_IdName struct_InputSelection[]={
 149            { UNKNOWN     , "" },       //don't remove or change this.
 150            { CH_TW2835,  "CVBS" },     //don't remove or change this.
 151            { CH_CAMD  ,   "CAM D"},
 152            { CH_AV    ,    "AV  "},
 153          
 154          
 155                                  // you can change the order of the followings
 156            #ifdef SUPPORT_SVIDEO
 157            { SVIDEO      , "S-Video" },
 158            #endif
 159          
 160            #ifdef SUPPORT_COMPONENT
 161            { COMPONENT ,     "Component" },
 162            #endif
 163          
 164            #ifdef SUPPORT_DTV
 165            { DTV ,       "DTV-SOG" },
 166            #endif
 167          
 168            #ifdef SUPPORT_PC
 169            { PC        , "VGA"},
 170            #endif
 171          
 172            #ifdef SUPPORT_DVI
 173            { DIGITALVGA    , "DVI" },
 174            #endif
 175          
 176            {0          , ""},        //don't remove or change this.
 177          };
 178          */
 179          /*
 180          #ifndef QUAD
 181          CODE struct struct_IdName struct_InputSelection_S[]={
 182            { UNKNOWN     , "" },       //don't remove or change this.
 183            { SOURCE_A, "CAM A" },      //don't remove or change this.
 184            { SOURCE_B  ,   "CAM B"},
 185            { SOURCE_R    ,    "CAM R  "},  
 186            { SOURCE_AV,    "AV  "},  
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 50  

 187          };
 188          #endif
 189          */
 190          /*
 191          CODE struct struct_IdName struct_VInputStd[]={
 192            { UNKNOWN     , "" },       //don't remove or change this.
 193            { NTSC,         "NTSC"},      //don't remove or change this.
 194          
 195            #ifdef SUPPORT_PAL
 196            { PAL,          "PAL"},
 197            #endif
 198          
 199            #ifdef SUPPORT_SECAM
 200            { SECAM,        "SECAM"},
 201            #endif
 202          
 203            #ifdef SUPPORT_PALM
 204            { PALM,         "PALM"},
 205            #endif
 206          
 207            #ifdef SUPPORT_PALN
 208            { PALN,         "PALN"},
 209            #endif
 210          
 211            #ifdef SUPPORT_PAL60
 212            { PAL60,        "PAL60"},
 213            #endif
 214          
 215            #ifdef SUPPORT_NTSC4
 216            { NTSC4,        "NTSC4.43"},
 217            #endif
 218          
 219            {0          , ""},        //don't remove or change this.
 220          };
 221          
 222          */
 223          /*
 224          //===================== OSD ===================================================
 225                WORD  OSDLastKeyInTime;   // in ms
 226          //===================== Button Key ============================================
 227          
 228          //================= Etc. ======================================================
 229          #ifdef WIDE_SCREEN
 230              BYTE  WideScreenMode;
 231          #endif
 232              BYTE  DebugLevel;
 233          
 234              bit   Flag4AutoPanelRegs = 0;
 235              bit   I2CAutoIncFlagOn = 0;
 236          #ifdef SUPPORT_COMPONENT
 237                BYTE  ComponentMode;
 238              WORD  OLD_hpn;
 239          #endif
 240          //extern  bit       OnChangingValue;
 241          //extern  BYTE  TVInputSel;
 242          #ifdef SUPPORT_DEBUG
 243          extern  bit Debug_On;
 244          #endif
 245          
 246          #ifdef NO_INITIALIZE
 247              bit   NoInitAccess=0;
 248          #endif
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 51  

 249          */
 250                //bit   DisplayInputHold = 0;   //william-981029
 251          
 252          #if 0 //william-981105
              //////////////////////////////////////////////////////////////////////////////
              
              //=============================================================================
              //    Prompt                                                       
              //=============================================================================
              
              void CheckDipSwitch(void)
              {
                static bit BW_STATUS=0, EDGE_STATUS=0;
                    //----- Check DIP Switch ---------------
              
                    if( EDGE_STATUS != DIP_EDGE_ENHANCE ) {
                      if( DIP_EDGE_ENHANCE==0 ) {
                        EDGE_STATUS = 0;
                        WriteTW88(0xdd, ReadTW88(0xdd) | 0x80);
                        //Printf("\r\nEnable Color Enhancement");
                      }
                      else {
                        EDGE_STATUS = 1;
                        WriteTW88(0xdd, ReadTW88(0xdd) & 0x7f);
                        //Printf("\r\nDisable Color Enhancement");
                      }
                    }
                    
                    if( BW_STATUS != DIP_BW_STRETCH ) {
                      if( DIP_BW_STRETCH==0 ) {
                        BW_STATUS = 0;
                        #ifdef WQVGA
                        WriteTW88(0x86, 0x0c);
                        WriteTW88(0x87, 0xff);
                        #else
                        WriteTW88(0x86, 0x20);
                        WriteTW88(0x87, 0xe0);
                        #endif
                        //Printf("\r\nEnable Black/White Stretch");
                      }
                      else {
                        BW_STATUS = 1;
                        WriteTW88(0x86, 0x00);
                        WriteTW88(0x87, 0xff);
                        //Printf("\r\nDisable Black/White Stretch");
                      }
                    }
                    if( AutoDetect != DIP_AUTO_DETECT ) {
                      AutoDetect = DIP_AUTO_DETECT;
                      //if ( AutoDetect )
                        //Puts("\r\nAutoDetect Mode Enabled" );
                      //else
                        //Puts("\r\nAutoDetect Mode Disabled" );
                    }
              }
              #endif
 305          #if 0///def 0///SUPPORT_GAMMA
              
              #include "Gamma.c"
              
              void DownLoadGamma(void)
              {
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 52  

                  // Red
                  WriteI2C(TW88I2CAddress, 0xf0, 0xe8|1 ); 
                  WriteI2C(TW88I2CAddress, 0xf1, 0x00); //  Start Address
                  WriteI2C(TW88I2CAddress, 0xf2, GammaRed[0]); //  
                  WriteI2Cn(TW88I2CAddress, 0xf2, &GammaRed[1], 255);
                  // Blue
                  WriteI2C(TW88I2CAddress, 0xf0, 0xe8|2 ); 
                  WriteI2C(TW88I2CAddress, 0xf1, 0x00); //  Start Address
                  WriteI2C(TW88I2CAddress, 0xf2, GammaGreen[0]); //  
                  WriteI2Cn(TW88I2CAddress, 0xf2, &GammaGreen[1], 255);
                  // Red
                  WriteI2C(TW88I2CAddress, 0xf0, 0xe8|3 ); 
                  WriteI2C(TW88I2CAddress, 0xf1, 0x00); //  Start Address
                  WriteI2C(TW88I2CAddress, 0xf2, GammaBlue[0]); //  
                  WriteI2Cn(TW88I2CAddress, 0xf2, &GammaBlue[1], 255);
              
              }
              #endif
 329          #if 0
              void I2CDeviceInitialize( CODE_P BYTE *RegSet)
              {
                int cnt=0;
                BYTE addr, index, val;
              
                addr = *RegSet;
                #ifdef DEBUG_TW88
                dPrintf("\r\nI2C address : %02x", (WORD)addr);
                #endif
                cnt = *(RegSet+1);
                RegSet+=2;
              
                while (( RegSet[0] != 0xFF ) || ( RegSet[1]!= 0xFF )) {     // 0xff, 0xff is end of data
                  index = *RegSet;
                  val = *(RegSet+1);
                  WriteI2C(addr, index, val);
              
                  #ifdef DEBUG_TW88
                  dPrintf("\r\n    addr=%02x  index=%02x   val=%02x", (WORD)addr, (WORD)index, (WORD)val );
                  #endif
              
                  RegSet+=2;
                }
                WriteTW88(0xff, 0x00);    // set page 0
              }
              
              extern CODE struct RegisterInfo UserRange;
              extern CODE struct RegisterInfo VideoContrastRange;
              extern CODE struct RegisterInfo VideoBrightnessRange;
              extern CODE struct RegisterInfo VideoSaturationRange;
              extern CODE struct RegisterInfo VideoHueRange;
              extern CODE struct RegisterInfo VideoSharpnessRange;
              extern CODE struct RegisterInfo DigitalVideoSaturationRange;
              #endif
 364          
 365          #if 0///def ADD_ANALOGPANEL
              BYTE IsAnalogOn(void)
              {
                if(DIP_PANEL_SWITCH==0) return 1;
                else return 0;
              }
              #endif
 372          #if 0
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 53  

              void InitVideoData(BYTE src)
              {
              
                #ifdef DEBUG_DECODER
                Printf("\r\n++(InitVideoData)src:%02x", (WORD)src);
                #endif
              
                #ifdef ADD_ANALOGPANEL
                if(IsAnalogOn())
                  I2CDeviceInitialize(NTSC_Regs_Analog);
                else
                #endif
                I2CDeviceInitialize(NTSC_Regs);
                WriteTW88(0xff, 0);
                        
                switch( src ) {
              
                #ifdef SUPPORT_PAL
                case PAL:     
                  #ifdef ADD_ANALOGPANEL
                    if(IsAnalogOn())
                      I2CDeviceInitialize(PAL_Regs_Analog);
                    else
                  #endif
                  I2CDeviceInitialize(PAL_Regs);  
                  break;
                #endif
                #ifdef SUPPORT_SECAM
                case SECAM:   
                  #ifdef ADD_ANALOGPANEL
                    if(IsAnalogOn())
                      I2CDeviceInitialize(PAL_Regs_Analog);
                    else
                  #endif
                  I2CDeviceInitialize(PAL_Regs);  
                  break;
                #endif
                #ifdef SUPPORT_PALN
                case PALN:    
                  #ifdef ADD_ANALOGPANEL
                    if(IsAnalogOn())
                      I2CDeviceInitialize(PAL_Regs_Analog);
                    else
                  #endif
                  I2CDeviceInitialize(PAL_Regs);  
                  break;
                #endif
              
                #ifdef SUPPORT_NTSC4
                case NTSC4:
                #endif
                #ifdef SUPPORT_PALM
                case PALM:
                #endif
                #ifdef SUPPORT_PAL60
                case PAL60:
                #endif
                case NTSC:
              
                case UNKNOWN:
                case NOINPUT: src = NTSC;           break;
                }
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 54  

              
                if( InputSelection == TV ) 
                {
                  if( VInputStdDetectMode==AUTO ) SetAutoDetectStd();
                  else              ClearAutoDetectStd(src-1);
                }
                else // Always Auto Detect.
                  SetAutoDetectStd();
                  
                //----- Set Panel Characteristics
              /// SetPanelSingleDouble(PIXEL_SINGLE);
              
              
                WriteDecoder(V_CONTROL2, 0x15);     // Set CC line number of Even Field
              //  WriteDecoder(CC_ODDLINE, 0x15);     // Set CC line number of Odd Field
                WriteTW88(0x5c, 0x06);      // change error tolerance and enable V/HSYNC change/loss detection
              
              //  DefaultPanelAttributeForVideo();
              
                SetVideoMode( GetVideoModeEE());    // 02212008 change for ??????? by ybae
                #ifdef DEBUG
                dPrintf("\r\n SetVideoMode: %d", (WORD)GetVideoModeEE() );
                #endif
              
                #ifdef WIDE_SCREEN
                Set4WideScreen(GetWideModeEE());
                #endif
                Init_DisplayInput=0;    //william 20120328
              }
              #endif
 465          #if 0///def ID_CHECK_BY_FW
              BYTE Is50Hz(void)
              {
                if( ReadDecoder(CSTATUS) & 0x01 ) return 1;
                return 0;
              }
              
              BYTE Slock(void)
              {
                if( ReadDecoder(CSTATUS) & 0x20 ) return 1;
                return 0;
              }
              #endif  // ID_CHECK_BY_FW
 478          
 479          #if 0///def SUPPORT_COMPONENT
              void CheckDecoderComponent(void)
              {
                CODE_P BYTE *reg=0;
                BYTE mode;
                WORD  width, height;
                DWORD scale;
              
                extern CODE BYTE COMPONENT_STR[][15] ;
              
                if( InputSelection != COMPONENT ) return;
              
                mode = ((ReadDecoder(CVFMT) & 0x70) >> 4);
                if( mode == ComponentMode ) return;
                Printf("\n\rCheckDecoderComponent==> Changed component Mode: %2x-> %2x (%s)", (WORD)ComponentMode, (WORD)
             -mode,COMPONENT_STR[mode]);
              
                ComponentMode = mode;
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 55  

                switch (mode)
                {
                case YPBPR_576i:  
                  #ifdef ADD_ANALOGPANEL
                    if(IsAnalogOn())
                    reg = COMP_YPbPr_576I_Reg;  
                    else
                  #endif
                    reg = COMP_YPbPr_576I_Reg;  
                    width = 700;
                    height = 280;
                  break;
                #if (defined WQVGA) || (defined QVGA)
              
                #else
                case YPBPR_480p:  reg = COMP_YPbPr_480P_Reg;    width = 630;  height = 480; break;
                case YPBPR_576p:  reg = COMP_YPbPr_576P_Reg;    width = 630;  height = 576; break;
                case YPBPR_720p:  reg = COMP_YPbPr_720P_Reg;    width = 413;  height = 720; break;
                case YPBPR_1080i: reg = COMP_YPbPr_1080I_Reg;   width = 624;  height = 540; break;
                #endif
                default:      reg = COMP_YPbPr_480I_Reg;    width = 700;  height = 235; break;
              
                }
              
                //InitVideoData(NTSC);
              
                I2CDeviceInitialize(reg);
              
                scale = width;
                scale *= 0x10000L;
                scale /= PWIDTH;
                XScale2(scale);
                #ifdef DEBUG_COMPONENT
                dPrintf("\r\nH scale: %xh - %xh", (WORD)(scale>>8), (WORD)(scale & 0xff));
                #endif
              
                scale = height;
                scale *= 0x10000L;
                scale /= PHEIGHT;
                YScale2(scale);
                #ifdef DEBUG_COMPONENT
                dPrintf("\r\nV scale: %xh - %xh", (WORD)(scale>>8), (WORD)(scale & 0xff));
                #endif
              
                delay(50);
                
                //william-981029>>>>>>>
                //if( IsNoInput() ) DisplayInputHold = 1;   // Hold  Input Information in no signal.
                //else 
                //DisplayInputHold = 0;
                //william-981029>>>>>
              
                //ClearOSDInfo();
              
                DisplayInput();
              }
              #endif
 553          #if 0
              void CheckDecoderInput(void)
              {
              
              #ifdef ID_CHECK_BY_FW
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 56  

              
                BYTE std, changed=0;
              
                static DATA BYTE no_cnt=0, secam_cnt=0, check_cnt=0;
              
                //if( InputSelection == TV ) return;
                if( InputSelection == COMPONENT ) return;
                if( ( InputSelection == TV ) && (VInputStdDetectMode != AUTO) ) return;
              
                if( IsNoInput() ) {
              //    if( VInputStd==NOINPUT ) return;
                  no_cnt++;
                  if( no_cnt>=10 ) {
                    no_cnt = 0;
                    
                    SetVInputStd( NOINPUT );
                    InitVideoData(NTSC);  
              
                    #ifdef DEBUG_DECODER
                    Printf("\r\nDecoder No Input");
                    #endif
              
                  }
                  return;
                }
                else {
                  no_cnt = 0;
                }
              
              
                switch( VInputStd ) {
              
                //--------------------------------------------------------------------------------------
                case NOINPUT:
              
                  WriteDecoder(SDT, 0x0f);    // 0x1c
                  //WriteTW88(0xb6, 0x87);
                  //delay(50);
              
                  switch( ReadDecoder(SDT) & 0x70 ) {
                  case 0x00:  std = NTSC; break;
                  case 0x10:  std = PAL;  break;
                  case 0x20:  std = SECAM;  break;
                  }
                  changed = 1;
                  check_cnt = 0;
                  secam_cnt = 0;
                  break;
                  
                //--------------------------------------------------------------------------------------
                case NTSC:
                  if( Is50Hz() ) {
                    if( !Slock() ) secam_cnt++;
                    if( ++check_cnt>=10 ) {
                      if( secam_cnt>=7 ) {
                        std = SECAM;
                        changed = 1;
                      }
                      else {
                        std = PAL;
                        changed = 1;
                      }
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 57  

                      check_cnt = 0;
                      secam_cnt = 0;
                    }
                  }
                  break;
              
                //--------------------------------------------------------------------------------------
                case PAL:
              
                  if( !Is50Hz() ) {
                    std = NTSC;
                    changed = 1;
                    check_cnt = 0;
                    secam_cnt = 0;
                  }
              
                  if( ReadTW88(0x30) & 0x10 ) secam_cnt++;
                  if( ++check_cnt>=10*10 ) {
                    if( secam_cnt>=7 ) {
                      std = SECAM;
                      changed = 1;
                    }
                    check_cnt = 0;
                    secam_cnt = 0;
                  }
                  break;
              
                //--------------------------------------------------------------------------------------
                case SECAM:
              
                  if( !Is50Hz() ) {
                    std = NTSC;
                    changed = 1;
                    check_cnt = 0;
                    secam_cnt = 0;
                  }
              
                  if( !(ReadTW88(0x30) & 0x80) ) secam_cnt++;
                  if( ++check_cnt>=10*10 ) {
              
                    #ifdef DEBUG_DECODER
                    Printf("%4d", secam_cnt);
                    #endif
              
                    if( secam_cnt<=7*10 ) {
                      std = PAL;
                      changed = 1;
                    }
                    check_cnt = 0;
                    secam_cnt = 0;
                  }
                  break;
                
              
                default:
                  break;
              
                }
              
                if( changed ) {
                  SetVInputStd( std );
                  InitVideoData(std);
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 58  

                  //DisplayInput();
              
                  switch( std ) {
                  case NTSC:  WriteDecoder(SDT, 0x08);  break;
                  case PAL: WriteDecoder(SDT, 0x09);  break;
                  case SECAM: WriteDecoder(SDT, 0x0a);  break;
                  }
                  
                  #ifdef DEBUG_DECODER
                  Printf("\r\n-------> Source changed %d", (WORD)VInputStd);
                  #endif
                  delay(99);
                }
                  
              #else // not ID_CHECK_BY_FW
              
                BYTE std1, std, cnt=0, trycnt=0, ChangedNoinput;
              
                  #ifdef DEBUG_DECODER
                  Printf("\r\n====>CheckDecoderInput<====");
                  #endif
                // LJY101002
                // Algorithm I 
                //if( InputSelection == TV ) return;
                //if( InputSelection == COMPONENT ) return;
                if( ( InputSelection == TV ) && (VInputStdDetectMode != AUTO) ) return;
              
                //if( VInputStdDetectMode==AUTO ) {
                  std1 = NOINPUT;
                  while(1) {            // keep checking until it's stable.(check cnt)
                    std = DetectDecoderInput();
                    
                    #ifdef DEBUG_DECODER
                    Printf("\r\nDetectDecoderInput: 0x%X, NOINPUT: 0x%x", (WORD)std, (WORD)std1);
                    #endif
                    trycnt++;
                    if( trycnt>= 10/*50*//*200*/ )      // so many try, but unstable
                      break;
              
                    if( std!=UNKNOWN && std!=VInputStd ) 
                      {
                      //changed!!
                      if( std == std1 )   // same as previous one.
                        cnt++;
                      else
                      {         // ooh.. different from previous one.
                        cnt = 0;
                        std1 = std;
                      }
              
                      if( cnt >= 2) { //100 ) {
                    #ifdef REFERENCE
                    #else
                        //ClearOSDInfo();
                    #endif 
                        //LCDPowerOFF();
                        if(  std == NOINPUT  )    //some input->NOINPUT
                          { 
                          
                          SetVInputStd( std );    //WILLIAM-20120502
                          ChangedNoinput = 1;   // Diaplay Input Information for no signal.
                          }
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 59  

                        else if( VInputStd==NOINPUT ) //NOINPUT->some input
                          {   
                          SetVInputStd( std );    //WILLIAM-20120502
                          InitVideoData(std);   //WILLIAM-20120502
                          ChangedNoinput = 0;   // Diaplay Input Information for no signal.
                          }
                        else 
                          {               //some input1->some input2
              //            LCDPowerOFF();
                          //PanelMute(1);
                        
                          SetVInputStd( std );
                          InitVideoData(std); 
                          delay(50);
              //            LCDPowerON(0);
                          ChangedNoinput = 0;   // Diaplay Input Information for no signal.
                          //ClearOSDInfo();
                          Printf("\r\n hello clear osd",0);
                //          if(SelectModeType==SOURCE_A) 
              //              ClearGAUGEINFO();
                          }
                        
                        //LCDPowerON(0);
                    #ifdef REFERENCE
                    #else
                        delay(0xff);
                    #endif 
                        //DisplayInput();   //william-981029
                        //DisplayInputHold = ChangedNoinput;    //william-981029
                        break;
                      }
                    }
                    #if 0   //william-981029
                    else
                    {
                      if(  std == NOINPUT  )      // NOINPUT->NOINPUT
                        DisplayInputHold = 1;   // Hold input information in no signal.
                      else
                        DisplayInputHold = 0;   // clear 
                      break;
              
                    }
                    #endif
                  }
                
                  //Printf("\r\nDisplayInputHold=%02x",(WORD)DisplayInputHold);
                //}
                
              #endif  // ID_CHECK_BY_FW
              
              }
              #endif
 796          #if 0
              BYTE ReadVInputSTD(void)
              {
                BYTE std;
                
                if( IsNoInput() ) return 1; // Noinput!!
                
                std = ReadDecoder(SDT) & 0xf0;
                if( std & 0x80 ) return 1; // Detection in progress..
                else 
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 60  

                  return ((( std & 0x70 ) >> 4 ) + 1 );
              }
              #endif
 809          /*********************************/
 810          #if 0
              BYTE IsNoInput(void)
              {
                if( ReadDecoder(CSTATUS) & 0x80 ) return 1;
                return 0;
              }
              #endif
 817          #if 0
              BYTE GetVInputStdInx(void)
              {
                BYTE i, std;
              
                std = ReadVInputSTD();
              
                switch( std ) {
              
                case NTSC4:
                case PALM:
                case PAL60:
                case NTSC:    IVF = 60;   IHF = 15723;  break;  // 15734
              
                case SECAM:
                case PALN:
                case PAL:   IVF = 50;   IHF = 15723;  break;  // 15625
                default:    IVF = 0;    IHF = 0;    break;
                }
              
                for(i=0; ; i++) {
                  if( struct_VInputStd[i].Id ==std )
                    return i;
                  if( struct_VInputStd[i].Id ==0 )
                    break;
                }
                return 0;
              }
              
              #endif
 847          
 848          #if 0///def WIDE_SCREEN
              BYTE GetVInputStd(void)
              {
                return VInputStd;
              }
              #endif
 854          #if 0
              void SetVInputStd(BYTE newd)
              {
                VInputStd = newd;
              
                //#ifdef DEBUG
                //Printf("\r\n(SetVInputStd) VInputStd:(%s)", struct_VInputStd[GetVInputStdInx()].Name);
                Printf("\r\n(SetVInputStd) VInputStd:%d(%s)", (WORD)newd, struct_VInputStd[GetVInputStdInx()].Name);
                //#endif
              
                #if 0
                if(DVR_System!=newd &&  GetInputSelection()==CH_TW2835)
                  {
                  DVR_System=newd;    //tw2835 system
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 61  

                  if(GetDVRStatusflag==1)
                    Hs_DvrTxCmdPaser(SetSystem);
                  }
                #endif
                switch( VInputStd ) {
              
                #ifdef SUPPORT_NTSC4
                case NTSC4:
                #endif
                #ifdef SUPPORT_PALM
                case PALM:
                #endif
                #ifdef SUPPORT_PAL60
                case PAL60:
                #endif
                case NTSC:    IVF = 60;   IHF = 15723;  break;  // 15734
              
                #ifdef SUPPORT_SECAM
                case SECAM:
                #endif
                #ifdef SUPPORT_PALN
                case PALN:
                #endif
                #ifdef SUPPORT_PAL
                case PAL:   IVF = 50;   IHF = 15723;  break;  // 15625
                #endif
              
                default:    IVF = 0;    IHF = 0;    break;
                }
              }
              #endif
 899          
 900          
 901          #if 0
              BYTE GetInputSelection(void)
              {
                return InputSelection;
              }
              #endif
 907          #if 0
              BYTE GetNextInputSelection(void)
              {
                BYTE i;
              
              #ifdef QUAD
                for (i=1; ;i++)
                  if( struct_InputSelection[i].Id==InputSelection )  break;
                i++;
                if( struct_InputSelection[i].Id == 0 ) i=1;
              
                return struct_InputSelection[i].Id;
              #else
                for (i=1; ;i++)
                  if( struct_InputSelection_S[i].Id==InputSelection )  break;
                i++;
                if( struct_InputSelection_S[i].Id == 0 ) i=1;
              
                return struct_InputSelection_S[i].Id;
              #endif
              }
              #endif
 929          
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 62  

 930          BYTE mcuLib_ProtocolAppend(BYTE *pucBuf, BYTE * piLen, BYTE ucByte) {
 931   1          if (ucByte == 0x7E || ucByte == 0x7D) {
 932   2              pucBuf[*piLen] = 0x7D;
 933   2              (*piLen)++;
 934   2              pucBuf[*piLen] = 0x50 | (ucByte & 0x0F);
 935   2              (*piLen)++;
 936   2          } else {
 937   2              pucBuf[*piLen] = ucByte;
 938   2              (*piLen)++;
 939   2          }
 940   1          return 0;
 941   1      }
 942          
 943          BYTE mcuLib_ProtocolSendCmdWithParamNum(BYTE ucType, BYTE* pucParam, BYTE ucSize) {
 944   1          BYTE ucChecksum = 0;
 945   1          BYTE pucBuf[16];
 946   1          BYTE iLen;
 947   1          BYTE i;
 948   1         
 949   1          pucBuf[0] = 0x7E;
 950   1          iLen = 1;
 951   1          ucChecksum ^= ucType;
 952   1          mcuLib_ProtocolAppend(pucBuf, &iLen, ucType);
 953   1          ucChecksum ^= ucSize;
 954   1          mcuLib_ProtocolAppend(pucBuf, &iLen, ucSize);
 955   1      
 956   1          for (i = 0; i < ucSize; i++) {
 957   2              ucChecksum ^= pucParam[i];
 958   2              mcuLib_ProtocolAppend(pucBuf, &iLen, pucParam[i]);
 959   2          }
 960   1      
 961   1          mcuLib_ProtocolAppend(pucBuf, &iLen, ucChecksum);
 962   1      
 963   1        ///send cmd to DVR
 964   1        for (i = 0; i < (iLen); i++) {
 965   2            RS_tx(pucBuf[i]);
 966   2          }
 967   1      
 968   1        
 969   1          return 0;
 970   1      }
 971          
 972          
 973          void MCU_SendCmdToDVR(BYTE ucType)
 974          {
 975   1        BYTE buf[3]={0,0,0};
 976   1      
 977   1      switch(ucType)
 978   1      {
 979   2        case MCU_PROTOCOL_CMD_REPLY_MCU_FW: //Reply MCU firmware version
 980   2          buf[0]=MCU_FW_Major;
 981   2          buf[1]=MCU_FW_Sub0;
 982   2          buf[2]=MCU_FW_Sub1;
 983   2          mcuLib_ProtocolSendCmdWithParamNum(MCU_PROTOCOL_CMD_REPLY_MCU_FW,buf,3);  
 984   2          break;
 985   2        case MCU_PROTOCOL_CMD_REGULAR_DATA:     //Regular data
 986   2          buf[0]=GET_BATTERY_STATE();         ///abttery info.
 987   2          buf[1]=EncorderLenint;   
 988   2          buf[2]=EncorderLenfloaat;
 989   2          mcuLib_ProtocolSendCmdWithParamNum(MCU_PROTOCOL_CMD_REGULAR_DATA,buf,3);                        
 990   2          break;
 991   2        case MCU_PROTOCOL_CMD_SYSTEM_SHUTDOWN:    //system shutdown
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 63  

 992   2          mcuLib_ProtocolSendCmdWithParamNum(MCU_PROTOCOL_CMD_SYSTEM_SHUTDOWN,buf,1);                     
 993   2          break;
 994   2        case MCU_PROTOCOL_CMD_ENTRY_FACTORY:  //Entry factory mode
 995   2          mcuLib_ProtocolSendCmdWithParamNum(MCU_PROTOCOL_CMD_ENTRY_FACTORY,buf,1); 
 996   2          break;
 997   2      
 998   2      default:
 999   2        break;
1000   2          
1001   2      }
1002   1        
1003   1      }
1004          /*
1005          void PowerDown_XTAL(bit flag)
1006          {
1007            if( flag ) P3_7 = 1;
1008            else      P3_7 = 0;
1009          }
1010          */
1011          #if 0
              void Audio_Select(BYTE flag)
              {
                switch(flag)
                {
                  case 0:
                    TW2835Cmd("\n\raudioselect 0\n\r"); 
                    break;
                  case 1:
                    TW2835Cmd("\n\raudioselect 1\n\r"); 
                    break;  
                  case 2:
                    TW2835Cmd("\n\raudioselect 2\n\r"); 
                    break;
                  case 3:
                    TW2835Cmd("\n\raudioselect 3\n\r"); 
                    break;
                }
              
              }
              #endif
1032          #if 0
              void ChangeInput(BYTE newsel)
              {
                
              
              //  extern  CODE struct _PCMDATA PCMDATA[];
                #ifdef DEBUG
                BYTE i;
                #endif
                #if (defined SUPPORT_PC) || (defined SUPPORT_DTV)
                BYTE ret;
                #endif
                
                //Printf("\r\n ENTER ChangeInput Function",0);
                
              #ifdef QUAD
                if( InputSelection==newsel ) return;
              #else
                if( InputSelection==newsel ) 
                  {
                  //DisplayInput();   //william-20100420
                  return;
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 64  

                  }  
              #endif
              
                //DisplayInputHold = 0; // Refresh Input info.  //william-981029
                //ClearOSDInfo();
              
                //LCDPowerOFF();
                clrBacklight();
                //LCDPowerON(0); 
              
                //PanelMute(1);
              
                InputSelection = newsel;
                
                
              
                  #ifdef DEBUG
                  for (i=1; ;i++)
                    if( struct_InputSelection[i].Id==InputSelection )  break;
                  Printf("\r\n ->->->->->->->->->->-> Changed Input: %s(%02x)", struct_InputSelection[i].Name, (WORD)Input
             -Selection);
                  #endif
              
                  InitVideoData(VInputStd);
              
                  switch(InputSelection) {
              
                    #ifdef SUPPORT_PC
                    case PC:    
              
                          AVGAInput();        // load data and input mux selection to PC              
                          AutoPHPCalDisable();
                          tic_pc = 0;
                          ret = DetectAndSetForVGAInput(1);
                          //Audio_Select(2);
                          VGAAudio=1;
                              ChangeVol(0);     //william-v1.1-991208
                          //Audio_Select1=1;                           
                                    //Audio_Select2=0;  
                          //ret = DetectAndSetForVGAInput(0);
              
                          break;
              
                    #endif
                 
                    case CH_TW2835:
                            COMPOSITE1Input();
                          //ExtAudio();
                            //Audio_Select(0);
                            VGAAudio=0;
                            ChangeVol(0);     //william-v1.1-991208
                            Audio_Select1=0;                           
                                Audio_Select2=0;  
                                 
                           //Printf("\r\n CH_TW2835(%02x)",(WORD)InputSelection);
                           
                          break;
                    case CH_CAMD:
                      #ifdef QUAD
                        COMPOSITE3Input();
                      #else
                              COMPOSITE2Input();
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 65  

                      #endif
                              
                          //Audio_Select(1);
                          VGAAudio=0;
                          ChangeVol(0);     //william-v1.1-991208
              
                      #ifdef AWT_ML072S   //william @20130902 v1.0.1.2
                          Audio_Select1=1;                           
                                    Audio_Select2=0; 
                      #else
                          Audio_Select1=0;                           
                                    Audio_Select2=1;  
                      #endif        
                        //Printf("\r\n CH_CAMD(%02x)",(WORD)InputSelection);      
                          break;
                    case CH_AV:
                      #ifdef QUAD
                         COMPOSITE2Input();   
                      #else
                              COMPOSITE3Input();
                      #endif
                             
                         //Audio_Select(2); 
                         VGAAudio=0;
                         ChangeVol(0);      //william-v1.1-991208
                      #ifdef AWT_ML072S   //william @20130902 v1.0.1.2
                          Audio_Select1=0;                           
                                Audio_Select2=1; 
                      #else
                          Audio_Select1=1;                           
                                Audio_Select2=0;  
                      #endif  
                      
                        Printf("\r\n CH_AV(%02x)", (WORD)InputSelection);           
                          break;
                    case DTV:
                        COMPOSITE4Input();
                             
                         //Audio_Select(2); 
                         VGAAudio=0;
                         ChangeVol(0);      //william-v1.1-991208
                          Audio_Select1=1;                           
                                              Audio_Select2=1;  
                        Printf("\r\n CH_AV(%02x)", (WORD)InputSelection);           
                          break;      
                          
                  
                  }
                CheckPanelImage();    //william-981111    changesource load panelimage
                SaveInputSelectionEE(InputSelection);   // HHY 1.31
              //#ifdef WIDE_SCREEN
              //  WideScreenMode = WIDESCREEN_WIDE;
              //#endif
                //InitOSDMenu();  // Standby OSD Menu
              
                #ifdef DEBUG_PAUSE
                Pause("Detect and Set {CR}");
                #endif
              
                #if (defined SUPPORT_PC) || (defined SUPPORT_DTV)
                if( InputSelection==PC || InputSelection==DTV ) {
                  if( ret==TRUE ) {
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 66  

                    ret = ReadDecoder(ACNTL);
                    ret |= 0x80;  // Software Reset
                    WriteDecoder(ACNTL, ret);
                    delay(30);
                    WriteTW88( 0xff, 1);
                    WriteTW88( 0xCD, 1 ); // init LLPLL
                    WriteTW88( 0xff, 0 );
                    //DisplayInput();
                  }
                  else {
                      //CheckDipSwitch();//andy AWT 981015    
                    LCDPowerON(0);
                    delay(100);
                    WriteTW88( 0xd0, 0xff); // clear status
                    WriteTW88( 0xd1, 0xff); // clear status
                    return;
                  }
                  
                }
                else 
                #endif
                {
                  //DisplayInput();
              
                  #ifdef SUPPORT_COMPONENT
                  if( InputSelection == COMPONENT ){
                    delay(30);
                    ComponentMode = 0xff;
                    CheckDecoderComponent();
                  }
                  else 
                  #endif
                  { 
                    delay(30);
                    CheckDecoderInput();
                  }
              //william-981110    
              //Printf("\r\nSetPanelBrightnessReg");
              //  SetPanelBrightnessReg(RED,  0x80);
              //  SetPanelBrightnessReg(GREEN,0x80);
              //  SetPanelBrightnessReg(BLUE, 0x80);
              //  SetPanelContrastReg(0,0x80);
              //  SetPanelContrastReg(1,0x80);
              //  SetPanelContrastReg(2,0x80);
              //william-981110  
                }
                //----- Check DIP Switch ---------------
                //CheckDipSwitch();                      //andy AWT 981015    
                //Pause("\r\nBeforn LCD ON");
                //delay(250);
              
              
              #ifndef QUAD
               // if(NowModeState==JumpMode)
                //  CheckMirror();
               // else  
              //  CheckMirror();
              #endif
              
                DisplayInput();
                //LCDPowerON(0);
                SetBacklight();
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 67  

                delay(100);
                WriteTW88( 0xd0, 0xff); // clear status
                WriteTW88( 0xd1, 0xff); // clear status
              }
              #endif
1244          #if 0
              void PowerOff(void)
              {
                //Printf("\r\n++(PowerOff)__");
              //  PowerMode = OFF;
              
                //AudioOff();
                AudioMute(0);
                //ClearOSDInfo();   //william v0.2 20120223
                //LCDPowerOFF();
                PowerLED(OFF);
              }
              #endif
1257          #if 0
              void SetOSDLastKeyInTime(void)
              {
                OSDLastKeyInTime = GetTime_ms();
              }
              #endif
1263          #if 0
              WORD GetOSDLastKeyInTime(void)
              {
                return OSDLastKeyInTime ;
              }
              #endif
1269          //=============================================================================
1270          //
1271          //=============================================================================
1272          /*
1273          #ifdef SUPPORT_PATTERN
1274          CODE BYTE PATTERN[7][] = {
1275            {TW88I2CAddress,7, 0x61,0x5f, 0x64,0xff, 0x65,0x00, 0x66,0x00, 0x67,0xff, 0x68,0x00, 0x69,0x00, 0xff,0xff
             -},  // Red
1276            {TW88I2CAddress,7, 0x61,0x5f, 0x64,0x00, 0x65,0xff, 0x66,0x00, 0x67,0x00, 0x68,0xff, 0x69,0x00, 0xff,0xff
             -},  // Green
1277            {TW88I2CAddress,7, 0x61,0x5f, 0x64,0x00, 0x65,0x00, 0x66,0xff, 0x67,0x00, 0x68,0x00, 0x69,0xff, 0xff,0xff
             -},  // Blue
1278            {TW88I2CAddress,7, 0x61,0x5f, 0x64,0xff, 0x65,0xff, 0x66,0xff, 0x67,0xff, 0x68,0xff, 0x69,0xff, 0xff,0xff
             -},  // White
1279            {TW88I2CAddress,7, 0x61,0x5f, 0x64,0x00, 0x65,0x00, 0x66,0x00, 0x67,0xff, 0x68,0xff, 0x69,0xff, 0xff,0xff
             -},  // Gray
1280            {TW88I2CAddress,7, 0x61,0x5f, 0x64,0x00, 0x65,0x00, 0x66,0x00, 0x67,0x00, 0x68,0x00, 0x69,0x00, 0xff,0xff
             -},  // Black
1281            {TW88I2CAddress,7, 0x61,0x00, 0x64,0xc0, 0x65,0xc0, 0x66,0xc0, 0x67,0x88, 0x68,0x88, 0x69,0x88, 0xff,0xff
             -}  // Gray scale
1282          };
1283          #endif // SUPPORT_PATTERN
1284          */
1285          #if 0
              void AdjustAutoDayNight(BYTE val)
              {
              
                BYTE page;
                BYTE PWMLevelTemp;
                val=0xff-val;
              
                if(val>=0&&val<100)
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 68  

                  PWMLevelTemp=0;
                else if(val>=100&&val<140)
                  PWMLevelTemp=30;//20;
                else if(val>=140&&val<180)
                  PWMLevelTemp=60;//50;
                else if(val>=180&&val<220)
                  PWMLevelTemp=80;//65;
                else if(val>=220&&val<=255)//andy 20110414
                  {
                  //#ifdef AWT
                  PWMLevelTemp=110;//80;
                  //#else
                  //PWMLevelTemp=115;
                  //#endif
                  }
                //else
                //  PWMLevelTemp=0;
              if(DayNightLevel==1)
              {
                //if(AutoDayNightDelay<5)
                //  AutoDayNightDelay++;
                //else
                  {
                  if(PWMLevel>PWMLevelTemp)
                    PWMLevel-=1;
                  else if(PWMLevel<PWMLevelTemp)
                    PWMLevel+=1;
              
                  AutoDayNightDelay=0;
                  }
              }
              else
              {
                PWMLevel=PWMLevelTemp;
                //PWMLevel=0x08;
              } 
              
                //Printf("\r\nLADC0=%02x",(WORD)val);
                page = ReadTW88( 0xff );
                WriteTW88( 0xff, 0x00 );    // set page 0
                WriteTW88( 0xbe, ((ReadTW88(0xbe) & 0xcf) | 0x10) );  // set active Low control, if want active high clear
             - 
                //WriteTW88( 0xc4, ((ReadTW88(0xc4) & 0x80)|(val>>2)) );  // set pwm number
                WriteTW88( 0xc4, ((ReadTW88(0xc4) & 0x80)|(PWMLevel)) );  // set pwm number
                WriteTW88( 0xff, page );
              
              }
              #endif
1341          
1342          void InitialTimerEvent(void)
1343          {
1344   1        MCUTimerInitialTimerEvent();  //clear all of timer event
1345   1        
1346   1          MCUTimerActiveTimerEvent(SEC(5), _SYSTEM_TIMER_EVENT_JUDGE_BATT_STATE);
1347   1          
1348   1        MCUTimerActiveTimerEvent(SEC(1), _SYSTEM_TIMER_EVENT_GRN_ON_RED_BLINK);
1349   1      //  MCUTimerActiveTimerEvent(SEC(5), _SYSTEM_TIMER_EVENT_JUDGE_BATT_STATE);
1350   1      //  MCUTimerActiveTimerEvent(SEC(10), _SYSTEM_TIMER_EVENT_JUDGE_BTH_STATE);
1351   1      
1352   1      }
1353          
1354          BYTE Mapping1( int fromValue, CODE_P struct RegisterInfo *fromRange,
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 69  

1355                                           int * toValue, CODE_P struct RegisterInfo *toRange ){
1356   1      
1357   1        // calculate intermediate values
1358   1        int a;
1359   1        int b;
1360   1      
1361   1        // perform mapping
1362   1        if ( fromValue <= fromRange->Default ) {
1363   2          a = toRange->Default - toRange->Min;
1364   2          b = fromRange->Default - fromRange->Min;
1365   2          // prevent divide by zero
1366   2          if( b==0 )    return (FALSE);
1367   2          *toValue = (int) ( (DWORD)fromValue- (DWORD)fromRange->Min ) * a / b 
1368   2                  +(DWORD)toRange->Min;
1369   2        }
1370   1        else {
1371   2          a = toRange->Max - toRange->Default;
1372   2          b = fromRange->Max - fromRange->Default;
1373   2          // prevent divide by zero
1374   2          if( b==0 )    return (FALSE);
1375   2              *toValue = (int) ( (DWORD)fromValue - (DWORD)fromRange->Default ) * a / b
1376   2                             + (DWORD)toRange->Default;
1377   2        }
1378   1      
1379   1      //  #ifdef DEBUG_OSD
1380   1      //  dPrintf("\r\n++(Mapping1)%d(%d-%d-%d)", (WORD)fromValue, (WORD)fromRange->Min, (WORD)fromRange->Default
             -, (WORD)fromRange->Max );
1381   1      //  dPrintf("->%d(%d-%d)", (WORD)*toValue, (WORD)toRange->Min, (WORD)toRange->Max);
1382   1      //  #endif
1383   1        
1384   1        return ( TRUE );
1385   1         
1386   1      }
1387          
1388          void SetAD5110Step(BYTE newv) 
1389          {
1390   1      
1391   1        int regv;
1392   1      
1393   1          Mapping1( newv, &UserRange , &regv, &AD5110Range);
1394   1      
1395   1            WriteAD5110(AD5110_CMD_Write_Data_To_RDAC ,regv);
1396   1          
1397   1      }
1398          /*
1399          void AdjustBacklight(BYTE val)//val=0~110
1400          {
1401          
1402            BYTE page,BE_VAL;
1403            #if 0
1404            BYTE PWMLevelTemp;
1405            val=0xff-val;
1406          
1407            if(val>=0&&val<100)
1408              PWMLevelTemp=0;
1409            else if(val>=100&&val<140)
1410              PWMLevelTemp=30;//20;
1411            else if(val>=140&&val<180)
1412              PWMLevelTemp=60;//50;
1413            else if(val>=180&&val<220)
1414              PWMLevelTemp=80;//65;
1415            else if(val>=220&&val<=255)//andy 20110414
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 70  

1416              {
1417              //#ifdef AWT
1418              PWMLevelTemp=110;//80;
1419              //#else
1420              //PWMLevelTemp=115;
1421              //#endif
1422              }
1423            //else
1424            //  PWMLevelTemp=0;
1425            if(DayNightLevel==1)
1426            {
1427            //if(AutoDayNightDelay<5)
1428            //  AutoDayNightDelay++;
1429            //else
1430              {
1431              if(PWMLevel>PWMLevelTemp)
1432                PWMLevel-=1;
1433              else if(PWMLevel<PWMLevelTemp)
1434                PWMLevel+=1;
1435          
1436              AutoDayNightDelay=0;
1437              }
1438            }
1439            else
1440            {
1441            PWMLevel=PWMLevelTemp;
1442            //PWMLevel=0x08;
1443            } 
1444            #endif
1445            
1446            page = ReadTW88( 0xff );
1447            WriteTW88( 0xff, 0x00 );    // set page 0
1448            BE_VAL=ReadTW88(0xbe); 
1449            Printf("\r\nReadTW88(0xbe)1 =%02x",(WORD)BE_VAL);
1450            //WriteTW88( 0xbe, ((ReadTW88(0xbe) & 0xcf) | 0x10) );  // set active Low control, if want active high cle
             -ar 
1451            BE_VAL = (BE_VAL & 0xcf) | 0x00;
1452            Printf("\r\nReadTW88(0xbe)2 =%02x",(WORD)BE_VAL);
1453            WriteTW88( 0xbe, BE_VAL );  // set active Low control, if want active high clear 
1454            //WriteTW88( 0xc4, ((ReadTW88(0xc4) & 0x80)|(val>>2)) );  // set pwm number
1455            WriteTW88( 0xc4, ((ReadTW88(0xc4) & 0x80)|(val)) ); // set pwm number
1456            WriteTW88( 0xff, page );
1457          
1458          }
1459          */
1460          /*
1461          void Hs_InitVars(void)
1462          {
1463            BYTE i;
1464            
1465            //ChangeKey=1;
1466            
1467            SEQFlag=0;
1468            SEQTime=0;
1469            TriggerMode=8;    //No_TRIG
1470            AccPowerDown=1;
1471            SelectBoxMode=0;
1472          //#ifdef Format_SDCard  
1473            FormatSDCard=1;
1474          //#endif
1475            DVR_SDCardAvailable=0xFF;
1476            for(i=0;i>14;i++)
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 71  

1477              Information[i]=0;
1478          
1479            DoorState=P1_7;
1480            OSD_TEMP_STAT=0;
1481            TEMP_STAT_TEMP=1;
1482          
1483          }
1484          */
1485          void LoadEEPROM (void)
1486          {
1487   1      //  BYTE val;
1488   1      
1489   1         PowerFlag = ReadEEP(EEP_Powerflag);
1490   1         //PowerFlag = 1;   //WILLIAM-V1.3.1.2  20120522
1491   1         CameraVolt= ReadEEP(EEP_CameraVolt);
1492   1      
1493   1      #if 0
                 
                 TimeStep = ReadEEP(EEP_TimeStep);
              #ifdef AWT_ML072Q   //william @20130905
                 Priority = ReadEEP(EEP_PRIORITY);
              #else
                Priority=0;
              #endif
              
                 OSD_TYPE_FLAG=ReadEEP(EEP_OSD_TYPE);
                 OSD_LANGUAGE=ReadEEP(EEP_OSD_LANGUAGE);
                 
                 Printf("\r\nOSD_LANGUAGE=0x%02x",(WORD)OSD_LANGUAGE);
                 OSD_BRIGHTNESS_FLAG=ReadEEP(EEP_OSD_BRIGHTNESS);
                 POWER_LINK_FLAG=ReadEEP(EEP_OSD_PWR_LINK);
                  
                 DayNightLevel= ReadEEP(EEP_AutoMode);
                   PelcoChoiceFLAG = ReadEEP(EEP_PELCO);
                 CAMNumber = ReadEEP(EEP_CAMNUMBER);  
                 Baud_rate = ReadEEP(EEP_Baud_rate);
                SDCardCoverDetect=ReadEEP(EEP_SDCardDetect);
                 ReverseModeFlag=ReadEEP(EEP_ReverseMode);//andy holtz 20091123
                 #ifdef AWT_ML072S //william @20130902 v1.0.1.2
                 JUMPAVFlag=ReadEEP(EEP_JUMPAV_TIMESET);  
                 NowModeState=SelectMode;
                 #else
                  NowModeState = ReadEEP(EEP_NowModeState);
                #endif
                
                WriteEEP(EEP_COSDMode, 0x01);
                 val = ReadEEP(EEP_COSDMode);   //OSD ON & OFF     //william-980428                       
                   if(val==0)           
                   {
                    Attr_A|=0x02;  //*** BIT1: Channel OSD  set 1
                    Attr_B|=0x02;
                    Attr_C|=0x02;
                    Attr_R|=0x02;
                    //displayhold_flag=0;
                   }
                   
                   else               
                   {
                    Attr_A&=0x0d;  //*** BIT1: Channel OSD  set 0
                    Attr_B&=0x0d;
                    Attr_C&=0x0d;
                    Attr_R&=0x0d;
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 72  

                   }                        
                
                   val = ReadEEP(EEP_CAMAMode);   //CAM Mirror}]w                                
                   if(val==0)           //ON        
                   Attr_A|=0x01;          //*** BIT0: Horizontal Mirror  set 1
                   else               //OFF        
                   Attr_A&=0x0E;          //*** BIT0: Horizontal Mirror  set 0
                
                   val = ReadEEP(EEP_CAMBMode);                      
                   if(val==0)          //ON        
                   Attr_B|=0x01;         
                   else              //OFF                
                   Attr_B&=0x0E;       
                
                   val = ReadEEP(EEP_CAMCMode);                               
                   if(val==0)          //ON              
                   Attr_C|=0x01;              
                   else              //OFF               
                   Attr_C&=0x0E;           
                
                   val = ReadEEP(EEP_CAMRMode);                               
                   if(val==0)          //ON              
                   Attr_R|=0x01;              
                   else              //OFF               
                   Attr_R&=0x0E; 
                  
                  
                  
              
                  
                  AudioVol = GetAudioVolEE();
                  PCAudioVol = GetPCAudioVolEE();
                  DVR_AudioRecord = ReadEEP(EEP_AudioRecord); 
              #endif    
1573   1      
1574   1          
1575   1        //if(PowerFlag)
1576   1          
1577   1      }
1578          #if 0
              void ACCPowerControl(void)
              {
              
              if(ACC_B==1 && AccPowerDown==1)
                { 
                Hs_DvrTxCmdPaser(Halt_Start);
                PowerDownStart=1;
                AccPowerDown=0;
              
                if(DVR_Ready==1)      
                  {
                  if(PowerDownWait>29)
                    {
                    if(ACC_B==1)  
                      {
                    #ifdef BJTSwitch  
                      PPWR=0;
                    #else
                      PPWR=1;
                    #endif
                      }
                    else
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 73  

                      {
                      PowerDownStart=0;
                      PowerDownWait=0;
                      AccPowerDown=1;
                      }   
                    }
                  }
                else
                  {
                  if(ACC_B==1)
                    {
                  #ifdef BJTSwitch  
                    PPWR=0;
                  #else
                    PPWR=1;
                  #endif
                    }
                  else
                    {
                    PowerDownStart=0;
                    PowerDownWait=0;
                    AccPowerDown=1;
                    }
                  }
                }
              
              
              
              if(((PowerDownWait%10)==0) && PowerDownWait!=0)
                AccPowerDown=1;
              
              }
              #endif
1634          
1635          #if 0////def SUPPORT_SDCARD
              void SDCardHandler(void)
              {
              
              BYTE val;
              
                if(RS2_in!=0 /*&& !(GetDisplayedOSD() & MENU)*/)    //william-v1410-20120524
                  {
                  val=DvrReceivePaser();  
                  //Printf("\r\nDvrReceivePaser=%02x",(WORD)val);
                  //RS2_in=0;
                  }
                
                if(GetDVRStatusflag==1)
                  {
                  //Hs_DvrTxCmdPaser(GetDVRStatus);
                  Hs_DvrTxCmdPaser(GetDVRParam);
                  Hs_DvrTxCmdPaser(GetDATETIME);
              
                  if(DoorState&&(SDCardCoverDetect==0))
                    Hs_DvrTxCmdPaser(DoorOpen);
                  else
                    Hs_DvrTxCmdPaser(DoorClose);
              
                  #if 0 
                  Hs_DvrTxCmdPaser(SetSystem);    
                  #endif
                  GetDVRStatusflag=0;
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 74  

                  DisplayDVRStatus();
                  }
                
                if(second==30 && DVRReSendDisable==0 && !(GetDisplayedOSD() & MENU))    //william-v1410-20120524
                  {
                  Hs_DvrTxCmdPaser(GetDATETIME);
                  DVRReSendDisable=1;           //william-v1410-20120524
                  }
              
                if(DoorState!=P1_7&&(SDCardCoverDetect==0))
                  {
                  if(P1_7)
                    Hs_DvrTxCmdPaser(DoorOpen);
                  else
                    Hs_DvrTxCmdPaser(DoorClose);  
                  }
              
                if(((GetDisplayedOSD()&(TVVOL|MENU))==0) && DVR_Ready==1)
                  DisplayDVRStatus();
              //#ifdef Format_SDCard
                if(FormatSDCard>=60)
                  {
                  DisplayInformation(InfoRECORDERROR);  
                  Printf("\r\n FormatSDCard%02x",(WORD)FormatSDCard);
                  }
              //#endif    
                if((second&0x01)==0 && DVRReSendDisable==0)
                  {
                  if(CommandBuffer!=0)
                    {
                    //DVRCommandReSend();
                    Commanderror++;
                    DVRReSendDisable=1;
                    }
                  else
                    Commanderror=0;
                  }
                
                if(Commanderror>=40)            //william-v1410-20120524
                  DisplayInformation(InfoPLZRESETSYSTEM); 
                
                if(second&0x01 && DVRReSendDisable==1)
                  DVRReSendDisable=0;
              
              
              
              
              }
              #endif
1712          
1713          WORD GetADCValue(BYTE sel)
1714          {
1715   1          
1716   1      ADCTL=0x80|0x08|sel;  //start adc sampling
1717   1      
1718   1      while(ADCTL&0x08);// printf("ADC is busying\r\n");  //wating for adc
1719   1      
1720   1      return (WORD)(((ADCVL&0x03) |(ADCV<<2))&0x03ff);
1721   1      
1722   1      }
1723          
1724          WORD GetBatteryBTH(void)
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 75  

1725          {
1726   1      WORD adc;
1727   1      adc=GetADCValue(P16_BTH);
1728   1      Printf("\r\nBatteryBTH=%d", (WORD)adc);
1729   1      return adc;
1730   1      }
1731          
1732          WORD GetBatteryVoltage(void)
1733          {
1734   1      WORD adc;
1735   1      adc=GetADCValue(P17_BAT);
1736   1      Printf("\r\nBatteryVoltage=%d", (WORD)adc);
1737   1      return adc;
1738   1      }
1739          
1740          
1741          void EncorderHandler(void)
1742          {
1743   1      WORD EncorderCountTemp,temp_val,temp_EncorderCountTemp;
1744   1      BYTE param[4];
1745   1      float EncorderParaTemp1,EncorderParaTemp2,EncorderParaTemp3,EncorderParaTemp4;
1746   1      float EncorderOffset1,EncorderOffset2,EncorderOffset3/*,EncorderOffset4*/;
1747   1        
1748   1        if(ChangeKey)
1749   1        {
1750   2          
1751   2          EncorderParaTemp1=Encorder1*0.01f;
1752   2          EncorderParaTemp2=Encorder2*0.01f;
1753   2          EncorderParaTemp3=Encorder3*0.01f;
1754   2          EncorderParaTemp4=Encorder4*0.01f;
1755   2          
1756   2          #if 0
                  Printf("\r\nEncorder1=%d ",(WORD)Encorder1);
                  Printf("\r\nEncorder2=%d ",(WORD)Encorder2);
                  Printf("\r\nEncorder3=%d ",(WORD)Encorder3);
                  Printf("\r\nEncorder4=%d ",(WORD)Encorder4);
                  
                  Printf("\r\nEncorderParaTemp1=%d ",(WORD)(EncorderParaTemp1*100));
                  Printf("\r\nEncorderParaTemp2=%d ",(WORD)(EncorderParaTemp2*100));
                  Printf("\r\nEncorderParaTemp3=%d ",(WORD)(EncorderParaTemp3*100));
                  Printf("\r\nEncorderParaTemp4=%d ",(WORD)(EncorderParaTemp4*100));
                  #endif
1767   2          #if 0
                  EncorderOffset1=(30.625*EncorderParaTemp1*(240-EncorderLen_Offset))/1000;
                  EncorderOffset2=EncorderOffset1+(32.091*EncorderParaTemp2*(450-240-EncorderLen_Offset))/1000;
                  EncorderOffset3=EncorderOffset2+(33.504*EncorderParaTemp3*(780-450-EncorderLen_Offset)/1000);
                  //EncorderOffset4=EncorderOffset3+(33.504*((EncorderParaTemp3+EncorderParaTemp4)/2)*(780-600)/1000);
                  #else
1773   2          
1774   2          EncorderOffset1=(30.625*EncorderParaTemp1*240)/1000;
1775   2          EncorderOffset2=EncorderOffset1+(32.091*EncorderParaTemp2*(450-240))/1000;
1776   2          EncorderOffset3=EncorderOffset2+(33.504*EncorderParaTemp3*(780-450)/1000);
1777   2          #endif
1778   2          #if 0
                  Printf("\r\nEncorderOffset1=%d ",(WORD)(EncorderOffset1*100));
                  Printf("\r\nEncorderOffset2=%d ",(WORD)(EncorderOffset2*100));
                  Printf("\r\nEncorderOffset3=%d ",(WORD)(EncorderOffset3*100));
                  #endif
1783   2          //Printf("\r\nEncorderOffset4=%d ",(WORD)(EncorderOffset4*100));
1784   2          
1785   2          if(EncorderCount>=0)
1786   2            {
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 76  

1787   3            EncorderCountPN=0;
1788   3            EncorderCountTemp=(EncorderCount/2);
1789   3            }
1790   2          else
1791   2            {
1792   3            EncorderCountPN=1;
1793   3            EncorderCountTemp=(0-EncorderCount)/2;
1794   3            }
1795   2          //EncorderCountTemp+=450;
1796   2          //EncorderCount
1797   2          #if 0
                  if(EncorderCount>=0)
                    EncorderCountPN=0;
                  else
                    EncorderCountPN=1;
                  #endif
1803   2          #if 0
                  if(EncorderCountTemp>EncorderLen_Offset)
                    {
                    EncorderCountPN=0;
                    temp_EncorderCountTemp=EncorderCountTemp-EncorderLen_Offset;
                    }
                  else
                    {
                    EncorderCountPN=1;
                    temp_EncorderCountTemp=EncorderLen_Offset-EncorderCountTemp;
                    }
                  #endif
1815   2          if(EncorderCountTemp<=240&&EncorderCountTemp>=0)
1816   2            {
1817   3          
1818   3            Printf("\r\nEncorderCountTemp=%d ",(WORD)EncorderCountTemp);
1819   3            Printf("\r\nEncorderLen_Offset=%d ",(WORD)EncorderLen_Offset);
1820   3            Printf("\r\nEncorderCountPN=%d ",(WORD)EncorderCountPN);
1821   3            //if(EncorderCountPN==1)
1822   3            #if 0
                      EncorderLen=(30.625*EncorderParaTemp1*(temp_EncorderCountTemp))/1000;
                    #else
1825   3            EncorderLen=(30.625*EncorderParaTemp1*EncorderCountTemp)/1000;
1826   3            #endif
1827   3              //EncorderLen=(30.625*EncorderParaTemp1*(EncorderCountTemp-EncorderLen_Offset))/1000;
1828   3              
1829   3            //EncorderLen=(30.625*1*EncorderCountTemp)/1000;
1830   3            temp_val=30.625*EncorderParaTemp1*EncorderCountTemp;
1831   3            EncorderLenint=EncorderLen+0.05f;
1832   3            //Printf("\r\nEncorderLenTemp=%d ",(WORD)EncorderLenTemp);
1833   3            //EncorderLenint=EncorderLen;
1834   3            EncorderLenfloaat=(EncorderLen+0.05)*10;
1835   3            EncorderLenfloaat%=10;
1836   3            #if 0
                    Printf("\r\nEncorderCountTemp=%d ",(WORD)EncorderCountTemp);
                    Printf("\r\nEncorderLen=%d ",(WORD)EncorderLen);
                    Printf("\r\nEncorderLenint=%d ",(WORD)EncorderLenint);      
                    Printf("\r\ntemp_val=%d ",(WORD)temp_val);
                    Printf("\r\nEncorderCount=%d ",(WORD)EncorderCount);
                    Printf("\r\nEncorderLenTemp=%d.%dm ",(WORD)EncorderLenint,(WORD)EncorderLenfloaat);
                    #endif
1844   3            }
1845   2          else if(EncorderCountTemp>240&&EncorderCountTemp<=450)
1846   2            {
1847   3        
1848   3            #if 0
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 77  

                    EncorderLen=EncorderOffset1+(32.091*EncorderParaTemp2*(temp_EncorderCountTemp-(240-EncorderLen_Offset))
             -/1000);
                    #else
1851   3            EncorderLen=EncorderOffset1+(32.091*EncorderParaTemp2*(EncorderCountTemp-240)/1000);
1852   3            #endif
1853   3            
1854   3            Printf("\r\ntemp_EncorderCountTemp=%d ",(WORD)(temp_EncorderCountTemp-(240-EncorderLen_Offset)));
1855   3            Printf("\r\nEncorderLen_Offset=%d ",(WORD)EncorderLen_Offset);
1856   3            Printf("\r\ntemp_EncorderCountTemp=%d ",(WORD)temp_EncorderCountTemp);
1857   3            Printf("\r\nEncorderLen=%d ",(WORD)EncorderLen);
1858   3            //EncorderLen=7.35+(32.091*1*(EncorderCountTemp-240)/1000);
1859   3            Printf("\r\nEncorderCount=%d ",(WORD)EncorderCount);
1860   3      
1861   3            EncorderLenint=EncorderLen+0.05f;
1862   3            Printf("\r\nEncorderLenint=%d ",(WORD)EncorderLenint);
1863   3            //EncorderLenint=EncorderLen;
1864   3            EncorderLenfloaat=(EncorderLen+0.05)*10;
1865   3            EncorderLenfloaat%=10;
1866   3            Printf("\r\nEncorderLenTemp=%d.%dm ",(WORD)EncorderLenint,(WORD)EncorderLenfloaat);
1867   3            }
1868   2          #if 1
1869   2          else if(EncorderCountTemp>450&&EncorderCountTemp<=780)
1870   2            {
1871   3            #if 0
                    EncorderLen=EncorderOffset2+(33.504*1*(temp_EncorderCountTemp-(450-EncorderLen_Offset))/1000);
                    #else     
1874   3            EncorderLen=EncorderOffset2+(33.504*EncorderParaTemp3*(EncorderCountTemp-450)/1000);
1875   3            #endif
1876   3            Printf("\r\nEncorderCount=%d ",(WORD)EncorderCount);
1877   3      
1878   3            EncorderLenint=EncorderLen+0.05f;
1879   3            //Printf("\r\nEncorderLenTemp=%d ",(WORD)EncorderLenTemp);
1880   3            //EncorderLenint=EncorderLen;
1881   3            EncorderLenfloaat=(EncorderLen+0.05)*10;
1882   3            EncorderLenfloaat%=10;
1883   3            Printf("\r\nEncorderLenTemp=%d.%dm ",(WORD)EncorderLenint,(WORD)EncorderLenfloaat);
1884   3            }
1885   2          #else
                  else if(EncorderCountTemp>450&&EncorderCountTemp<=600)
                    {
                    EncorderLen=14.089+(33.504*EncorderParaTemp3*(EncorderCountTemp-450)/1000);
                    //EncorderLen=14.089+(33.504*1*(EncorderCountTemp-450)/1000);
                    Printf("\r\nEncorderCount=%d ",(WORD)EncorderCount);
              
                    EncorderLenint=EncorderLen+0.05f;
                    //Printf("\r\nEncorderLenTemp=%d ",(WORD)EncorderLenTemp);
                    //EncorderLenint=EncorderLen;
                    EncorderLenfloaat=(EncorderLen+0.05)*10;
                    EncorderLenfloaat%=10;
                    Printf("\r\nEncorderLenTemp=%d.%dm ",(WORD)EncorderLenint,(WORD)EncorderLenfloaat);
                    }   
                  else if(EncorderCountTemp>600&&EncorderCountTemp<=780)
                    {
                    EncorderLen=19.089+(33.504*((EncorderParaTemp3+EncorderParaTemp4)/2)*(EncorderCountTemp-600)/1000);
                    //EncorderLen=14.089+(33.504*1*(EncorderCountTemp-450)/1000);
                    Printf("\r\nEncorderCount=%d ",(WORD)EncorderCount);
              
                    EncorderLenint=EncorderLen+0.05f;
                    //Printf("\r\nEncorderLenTemp=%d ",(WORD)EncorderLenTemp);
                    //EncorderLenint=EncorderLen;
                    EncorderLenfloaat=(EncorderLen+0.05)*10;
                    EncorderLenfloaat%=10;
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 78  

                    Printf("\r\nEncorderLenTemp=%d.%dm ",(WORD)EncorderLenint,(WORD)EncorderLenfloaat);
                    }
                  #endif
1913   2          else if(EncorderCountTemp>780)
1914   2            {
1915   3            #if 0
                    EncorderLen=EncorderOffset3+(34.896*1*(EncorderCountTemp-(780-EncorderLen_Offset))/1000);
                    #else
1918   3            EncorderLen=EncorderOffset3+(34.896*EncorderParaTemp4*(EncorderCountTemp-780)/1000);
1919   3            #endif
1920   3            Printf("\r\nEncorderCount=%d ",(WORD)EncorderCount);
1921   3      
1922   3            Printf("\r\nEncorderLen=%d ",(WORD)EncorderLen);
1923   3            EncorderLenint=EncorderLen+0.05f;
1924   3            Printf("\r\nEncorderLenint=%d ",(WORD)EncorderLenint);
1925   3            //EncorderLenint=EncorderLen;
1926   3            EncorderLenfloaat=(EncorderLen+0.05)*10;
1927   3            Printf("\r\nEncorderLenfloaat=%d ",(WORD)EncorderLenfloaat);
1928   3            EncorderLenfloaat%=10;
1929   3            Printf("\r\nEncorderLenTemp=%d.%dm ",(WORD)EncorderLenint,(WORD)EncorderLenfloaat);
1930   3            }
1931   2            
1932   2          ChangeKey=0;
1933   2          param[0]=EncorderLenint;
1934   2          param[1]=EncorderLenfloaat;
1935   2          param[2]=EncorderCountPN;
1936   2          //protocol_send_cmd_with_param_num(0x0a, (BYTE *)param, 3);
1937   2          //protocol_send_cmd_with_param_num(0x80, (BYTE *)param, 3);
1938   2      
1939   2          
1940   2        }
1941   1        //GetKey(0);
1942   1      }
1943          
1944            //bit CCFL_status;  
1945          void main_loop(void)
1946          {
1947   1      
1948   1        //BYTE val/*,i*/;
1949   1        //BYTE buf[3]={0x11,0x7E,0x7D};
1950   1        //DisplaySTARTINFOOSD();  
1951   1        Printf("\r\nStart Main Loop...");
1952   1        //mcuLib_ProtocolSendCmdWithParamNum(0x80,buf,3);
1953   1        //---------------------------------------------------------------
1954   1        //                   Main Loop
1955   1        //---------------------------------------------------------------
1956   1        while(1) {
1957   2          //Printf(">");
1958   2      
1959   2        
1960   2          //-------------- Check Serial Port -----------------
1961   2          //#ifdef Hs_debug
1962   2      #if 0//for test ryan@20200302   
                  while( RS_ready() ) 
                    Monitor();        // for new monitor functions
              #else     
1966   2            DvrReceivePaser();  
1967   2      #endif
1968   2          #if 0//def SERIAL
                  
                  #ifdef Hs_debug
                  //while( RS_ready() ) 
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 79  

                  //  Monitor();        // for new monitor functions
                  
                  #ifdef USE_HI3521_UART2
                  if(RS2_in!=0)   //william-v1410-20120524
                  #else
              //    if((RS_in!=0)   //william-v1410-20120524
                    if(RS_in>3)   //william-v1410-20120524
                  #endif  
                  {
                  val=DvrReceivePaser();
                  //Printf("\r\nDvrReceivePaser=%02x",(WORD)val);
                  }
                  #else
                  
                  #ifdef USE_HI3521_UART2
                  if(RS2_in!=0 /*&& !(GetDisplayedOSD() & MENU)*/)    //william-v1410-20120524
                  #else
                  if(RS_in!=0 /*&& !(GetDisplayedOSD() & MENU)*/)   //william-v1410-20120524
                  #endif  
                  {
                  val=DvrReceivePaser();  
                  //Printf("\r\nDvrReceivePaser=%02x",(WORD)val);
                  //RS_in=0;
                  }
                  #endif  
              
                  #endif // SERIAL
1999   2      
2000   2        //  DvrReceivePaser();  
2001   2      
2002   2          SysJudgeHandler();  
2003   2          SysTimerHandler();
2004   2          //SysModeHandler();
2005   2          SysPowerHandler();  
2006   2            #if 0
                    if(!OSD_Ready_Flag)
                    {
                      if(FLASH_FLAG==1)
                      {
                      if(TL057I_GREEN_LED==1)
                      TL057I_GREEN_LED=0;
                      else
                      TL057I_GREEN_LED=1;
                      FLASH_FLAG=0;
                      }
                    }
                    else
                    {
                      if(Ready_Flag)
                      {
                      if(PowerFlag)
                        TL057I_GREEN_LED=0;
                      else
                        TL057I_GREEN_LED=1;
                      
                      Ready_Flag=0;
                      }
                    }
                    #endif
2031   2      #if 0         
                    #if 1
                          if(ACPWRDt==1)
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 80  

              
                        {
                      if (ACmode == 0)
              
                            {
                      //#define GM8126_WD2    P3_5
              
                  ////    Printf("\r\nACPWRDt_STAT=%d",(WORD)ACPWRDt);
                  ////    Printf("\r\n               ACmode  Enable");
              
                      ACmode = 1;
                              ACmodeStatus = ACmode;
                              
                      BAT_param[0]=0x05;
                      protocol_send_cmd_with_param_num(0x8C, (BYTE *)BAT_param, 1);
                            }
              
                        }
                    else  // Not detect 
                      {
                      ACmode =0 ;
              
                    if(ACmodeStatus != ACmode)
              
                      {
                      
                              ACmodeStatus = ACmode;
                      
                      BAT_param[0]=0x00;
                      protocol_send_cmd_with_param_num(0x8C, (BYTE *)BAT_param, 1);
              
                      
                      }
              
                      }
              
              
              
              
              
                    
                    ADCTL=0xED;
                    while((ADCTL&0x10)==1);
                    Wait_ms(10);
                    val=ADCV;
                    BATERY_STAT_TEMP=BATERY_STAT;
                    #if 1
                    if((val>135)&&(val<=BattDetect4))//BattDetect4
                    {
                       //BATERY_STAT=BATERY_25;
                        BattDetect1_COUNT=0;
                        BattDetect2_COUNT=0;
                      BattDetect3_COUNT=0;
                      BattDetect4_COUNT=0;
                      BattDetect5_COUNT=0;
                      BattDetect6_COUNT++;
                    }
                    else if((val>BattDetect4)&&(val<=BattDetect3))//BattDetect4
                    {
                       //BATERY_STAT=BATERY_25;
                        BattDetect1_COUNT++;
                        BattDetect2_COUNT=0;
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 81  

                      BattDetect3_COUNT=0;
                      BattDetect4_COUNT=0;
                      BattDetect5_COUNT=0;
                      BattDetect6_COUNT=0;
                    }     
                    else if((val>BattDetect3)&&(val<=BattDetect2))//BattDetect3
                    {
                      // BATERY_STAT=BATERY_50;
                        BattDetect1_COUNT=0;
                        BattDetect2_COUNT++;
                      BattDetect3_COUNT=0;
                      BattDetect4_COUNT=0;
                      BattDetect5_COUNT=0;
                      BattDetect6_COUNT=0;
                    }
                    else if((val>BattDetect2)&&(val<=BattDetect1))//BattDetect2
                    {
                      //BATERY_STAT=BATERY_75;
                        BattDetect1_COUNT=0;
                        BattDetect2_COUNT=0;
                      BattDetect3_COUNT++;
                      BattDetect4_COUNT=0;
                      BattDetect5_COUNT=0;
                      BattDetect6_COUNT=0;
                    }
                    else if((val>BattDetect1)&&(val<=255))//BattDetect1
                    {
                        //BATERY_STAT=BATERY_100;
                        BattDetect1_COUNT=0;
                        BattDetect2_COUNT=0;
                      BattDetect3_COUNT=0;
                      BattDetect4_COUNT++;
                      BattDetect5_COUNT=0;
                      BattDetect6_COUNT=0;
                    }
                    else if(val<=100)//BattDetect1
                    {
                        //BATERY_STAT=BATERY_100;
                        BattDetect1_COUNT=0;
                        BattDetect2_COUNT=0;
                      BattDetect3_COUNT=0;
                      BattDetect4_COUNT=0;
                      BattDetect5_COUNT++;
                      BattDetect6_COUNT=0;
                    }
              
                    
                    if(BattDetect1_COUNT==20)
                    {
                      BATERY_STAT=BATERY_25;
                      BattDetect1_COUNT=0;
                    }
                    if(BattDetect2_COUNT==20)
                    {
                      BATERY_STAT=BATERY_50;
                      BattDetect2_COUNT=0;
                    }
                    if(BattDetect3_COUNT==20)
                    {
                      BATERY_STAT=BATERY_75;
                      BattDetect3_COUNT=0;
                    }
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 82  

                    if(BattDetect4_COUNT==20)
                    {
                      BATERY_STAT=BATERY_100;
                      BattDetect4_COUNT=0;
                    }
                    if(BattDetect5_COUNT==20)
                    {
                      BATERY_STAT=BATERY_AC;
                      BattDetect5_COUNT=0;
                    }
                    
                    if(BattDetect6_COUNT==20)
                    {
                      BATERY_STAT=BATERY_10;
                      BattDetect6_COUNT=0;
                    }
                    //Printf("\r\nBattDetect1_COUNT=%d",(WORD)BattDetect1_COUNT);
                    //Printf("\r\nBattDetect2_COUNT=%d",(WORD)BattDetect2_COUNT);
                    //Printf("\r\nBattDetect3_COUNT=%d",(WORD)BattDetect3_COUNT);
                    //Printf("\r\nBattDetect4_COUNT=%d",(WORD)BattDetect4_COUNT);
                    
                    #else
                    if((val>135)&&(val<=BattDetect3))//BattDetect4
                    {
                       BATERY_STAT=BATERY_25;
                    }
                    else if((val>BattDetect3)&&(val<=BattDetect2))//BattDetect3
                    {
                       BATERY_STAT=BATERY_50;
                    }
                    else if((val>BattDetect2)&&(val<=BattDetect1))//BattDetect2
                    {
                      BATERY_STAT=BATERY_75;
                    }
                    else if((val>BattDetect1)&&(val<=255))//BattDetect1
                    {
                        BATERY_STAT=BATERY_100;
                    } 
                    #endif
                
                    if(BATERY_STAT_TEMP!=BATERY_STAT)
                    {
                      Printf("\r\n Send_CMD",0);
                      if(BATERY_STAT!=0xFF)
                      {
                      BAT_param[0]=BATERY_STAT;
                
                      Printf("\r\n Send_BATERY_STAT",0);
                      protocol_send_cmd_with_param_num(0x8B, (BYTE *)BAT_param, 1);
                      Wait_ms(100);
                      //protocol_send_cmd_with_param_num(0x8B, (BYTE *)BAT_param, 1);
                      Printf("\r\nBATERY_STAT=%d",(WORD)BATERY_STAT);
                      }
                    }
              
              
                            
                    //Printf("\r\nADCV1=%d",(WORD)ADCV);
                    //Wait_ms(2000); 
                    ADCTL=0xEC;
                    while((ADCTL&0x10)==1);
                      Wait_ms(10);
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 83  

                    val=ADCV;
                    TEMP_STAT_TEMP=OSD_TEMP_STAT;
                    //if(val<255&&val>141)
                    //TEMP1_COUNT
                    if(val<=255&&val>=TempAlarm1)
                    {
                    //TEMP_STAT=TEMP_OK;
                    TEMP1_COUNT++;
                    TEMP2_COUNT=0;
                    TEMP3_COUNT=0;
                    }
                    else if(val<TempAlarm1&&val>=TempAlarm2)
                    {
                    //TEMP_STAT=TEMP_Alarm1;
                    TEMP1_COUNT=0;
                    TEMP2_COUNT++;
                    TEMP3_COUNT=0;
                
                    }
                    else if(val<=TempAlarm2)
                    {
                    TEMP1_COUNT=0;
                    TEMP2_COUNT=0;
                    TEMP3_COUNT++;
                    //TEMP_STAT=TEMP_Alarm2;
                    }
                    if(TEMP1_COUNT==20)
                    {
                      //Printf("\r\n Send Message ok",0);
                      OSD_TEMP_STAT=TEMP_OK;
                      TEMP1_COUNT=0;
                    }
                    if(TEMP2_COUNT==20)
                    {
                    //Printf("\r\n Send Message Alarm 1",0);
                      OSD_TEMP_STAT=TEMP_Alarm1;
                      TEMP2_COUNT=0;
                    }
                    if(TEMP3_COUNT==20)
                    {
                    //Printf("\r\n Send Message Alarm 2",0);
                      OSD_TEMP_STAT=TEMP_Alarm2;;
                      TEMP3_COUNT=0;
                    }
              
              
                    //Printf("\r\nTEMP_STAT=%d",(WORD)TEMP_STAT);
                    
                    //Printf("\r\nTEMP_STAT_TEMP=%d",(WORD)TEMP_STAT_TEMP);
                    if(TEMP_STAT_TEMP!=OSD_TEMP_STAT)
                    {
                      Printf("\r\n Send Message",0);
                      Printf("\r\nTEMP_STAT=%d",(WORD)OSD_TEMP_STAT);
              
                      Printf("\r\nADCV2=%d",(WORD)ADCV);
                      Printf("\r\nTempAlarm1=%d",(WORD)TempAlarm1);
                      Printf("\r\nTempAlarm2=%d",(WORD)TempAlarm2);
                      if(Protect_Power_Flag==0&&(OSD_TEMP_STAT==TEMP_Alarm1||OSD_TEMP_STAT==TEMP_OK))
                      {
                      PROTECT[0]=DVR_POWER;
                      protocol_send_cmd_with_param_num(0x02, (BYTE *)PROTECT, 1);       
                      SetBacklight();
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 84  

                      TL057I_GREEN_LED=0;
                      Protect_Power_Flag=1;
                      delay(10);
                      }
                      TEMP_param[0]=OSD_TEMP_STAT;
                      protocol_send_cmd_with_param_num(0x8A, (BYTE *)TEMP_param, 1);
                      
                    }
              
                    #endif
                    
                    if(tic_PWR_SAVING==0)
                    {
                      if(PWR_SAVING_ACT_FLAG==1)
                      {
                      P1_6=0;
                      AdjustBacklight(0x80);
                      #if 1
                      Wait_ms(100);
                      #endif
                      clrBacklight();
                      PWR_OFF_KEY_LOCK=1;
                      PWR_SAVING_ACT_FLAG=0;
                      }
                    }
              #endif      
2308   2          #if 0
                  if(Power_Saving_Flag)
                  {
                    if(tic_PWR_SAVING==0)
                    {
                      //if()
                      {
                        if(P4&&0xfb)
                        {
                        clrBacklight();
                        }
                        else
                        {
                        SetBacklight();
                        }
                      }
                    } 
                  }
                  #endif
2327   2      
2328   2          #if 0
                  if(Power_On_Display_Msg_Flag==0&&Display_Msg_Flag==1)
                  {
                   ClearGAUGEINFO();
                   Display_Msg_Flag=0;
                  }
                  Scankey();
              
                  #endif
2337   2          
2338   2          Scankey();
2339   2          EncorderHandler();
2340   2      
2341   2      
2342   2            
2343   2        #ifdef CHIP_MANUAL_TEST
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 85  

                ChipManualTest();
                #endif
2346   2      
2347   2      
2348   2        #ifdef SUPPORT_SDCARD
                  ACCPowerControl();  
                #endif
2351   2      
2352   2        #ifdef SUPPORT_SDCARD
                    SDCardHandler();  
                #endif
2355   2      
2356   2        
2357   2         //   {
2358   2         #if 0
                val=CheckTrigger();
                TriggerHandler(val);
              
                 //   }
                
              
                  if(TriggerFlag==0 /*&& (SelectBoxMode==0 || SelectBoxMode==5)*/)           //Dku
                   { 
                    if(SEQFlag)             // SEQ Mode
                       { 
                        if(SEQTime>=TimeStep) 
                          {
                        SEQMode();
                          SEQTime=0;
                          }
                      }
                     }
              #endif  
2377   2      
2378   2          
2379   2          //if( !CheckKeyIn() ) break;      // POWEROFF
2380   2      #if 0
              #ifndef QUAD
                if(ReadEEP(EEP_COSDMode)!=0 && displayhold_flag==1 && !(GetDisplayedOSD() & MENU))
                   {
                    if(!(GetDisplayedOSD()&TVVOL))    //william-v1.0-971203
                    {
                             ShowOSDWindow(INPUTINFO_OSDWIN-1,FALSE);
                        displayhold_flag=0;
                  } 
                   }
              #endif  
                  
                  CheckAndClearOSD();
                  //============== Check each input status ===============
                  
                  switch ( GetInputSelection() ) {
              
                  case CH_TW2835:
                       case CH_CAMD:
                  case CH_AV:   
                    //----- Check Decoder ----------------
              
                    if(!( GetDisplayedOSD() & MENU ) )
                      {   
                        CheckDecoderInput();  
                      }
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 86  

                  
                    break;
              
                  #ifdef SUPPORT_PC
                  case PC:
                    //if ( AutoDetect == 0 ) break;
                    //----- Check PC input changed -------
                      CheckPCinput();
                    break;
                  #endif
              
                  }
              #endif
2419   2      #if 1
2420   2      ////_Anderson_add_20140225_xx
2421   2      ////if(POWERLEDFLASH_FLAG ==1)
2422   2      ////  {
2423   2      ////  TL057I_GREEN_LED = 1;
2424   2      ////  Wait_ms(200);
2425   2      ////  TL057I_GREEN_LED = 0;
2426   2      ////  }
2427   2      
2428   2        #if 0
              //Check FPCLK
                if(ReadTW88(0xb2)==0)
                  {
                  WriteTW88(0xfd,0xb0);
                  PowerLED(OFF);
                  Wait_ms(500);
                  PowerLED(ON);
                  WriteTW88(0xfd,0x30);
                  }
              #endif  
2439   2          #endif
2440   2        }
2441   1      
2442   1      }
2443          
2444          void main(void)
2445          {
2446   1        
2447   1      //#ifdef QUAD
2448   1      //BYTE i;
2449   1      //#endif
2450   1      
2451   1      //BYTE  temp[1]/*,val*/;
2452   1      //WORD  TW2835Check=0;
2453   1      //BYTE  CMD_TEMP[1];
2454   1      ////P3_5=0;
2455   1      //Panel_Disable();
2456   1      //AudioMute(0); 
2457   1      
2458   1      #if 0
              #ifdef BJTSwitch
                PPWR=1;
              #else
                PPWR=0;
              #endif
              #endif
2465   1      #if 0
                Wait_ms(1000);
                TW88HWReset = 0;      //TW88 HW reset by port pin, internal MCU no meaning
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 87  

              
                Wait_ms(200);
                TW88HWReset = 0;
              #endif  
2472   1      InitCPU();
2473   1      
2474   1      CLR_PCON3V3_P();
2475   1      CLR_PCON5V_P();
2476   1      CLR_Panel_EN();
2477   1      CLR_PCON5V_P();
2478   1      CLR_Panel_EN();
2479   1      CLR_PWCTRL();
2480   1      CLR_CHG_CURR();
2481   1      CLR_AC_MODE();
2482   1      CLR_BAT_SYS();
2483   1      CLR_PCON_CAM();
2484   1      CLR_PCON3V3_TW();
2485   1      CLR_TW8836_RST();  
2486   1      CLR_GREEN();
2487   1      CLR_RED();  
2488   1      CLR_TW8836_RST();
2489   1      
2490   1      MCUTimerDelayXms(200);//delay 200ms
2491   1      
2492   1      SET_PCON3V3_P();
2493   1      SET_PCON5V_P();
2494   1      SET_Panel_EN();
2495   1      SET_PCON5V_P();
2496   1      SET_Panel_EN();
2497   1      SET_PWCTRL();
2498   1      SET_CHG_CURR();
2499   1      SET_AC_MODE();
2500   1      SET_BAT_SYS();
2501   1      SET_PCON_CAM();
2502   1      SET_PCON3V3_TW();
2503   1      SET_TW8836_RST();  
2504   1      
2505   1      
2506   1      
2507   1      Printf("\r\nStart Boot...");
2508   1      
2509   1      main_init();
2510   1      
2511   1      InitVars();
2512   1      
2513   1      LoadEEPROM();
2514   1      
2515   1      InitialTimerEvent();
2516   1      
2517   1      #if 0 
                #if 0
                P1_6=1;//P1_6 BLEN D4 
                Wait_ms(1000);
                P1_6=0;//P1_6 BLEN D4 
                Wait_ms(1000);
                P1_6=1;//P1_6 BLEN D4 
                Wait_ms(1000);
                P1_6=0;//P1_6 BLEN D4 
                Wait_ms(1000);
                P1_6=1;//P1_6 BLEN D4 
                Wait_ms(1000);
                P1_6=0;
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 88  

                #endif
                
                clrBacklight();//P1_6 BLEN D3
                AdjustBacklight(0x00);  
                P1_6=0;
              
                Printf("\r\n Enter Main SelectModeType=%d",(WORD)SelectModeType);
                #ifdef Hs_debug
                SetMonAddress(TW88I2CAddress);
                #endif
                InitVars();
                RS2_in=0; 
                RS_in=0;
                Hs_InitVars();
                InitTechwell();
              #ifdef SUPPORT_SDCARD 
                Hs_Protocol_Init();
              #endif
                //LCDPowerOFF();
                
                main_init();
              
                PowerUp = 0;
                
                Wait_ms(400);
                
                LoadEEPROM();
                
              //william-v1.1-991208
              #ifdef QUAD
              for(i=0;i<20;i++) 
              {
                TW2835Check=TW2835Command(CAM_A,Attr_A,Attr_B,Attr_C,Attr_R);
                if(TW2835Check==TRUE)
                  break;
                Wait_ms(100);
              }
              #endif
                
                //Printf("\r\n in Main SelectModeType=%d",(WORD)SelectModeType);
                TriggerFlag=0x00;         // william-1.0-test
                //Wait_ms(1000);
                //SelectModeType=SOURCE_B; 
                //WriteEEP(EEP_SelectMode,SelectModeType); 
                //Printf("\r\n Enter Main SelectModeType=%d",(WORD)SelectModeType);
                //SetNowMode();
                #if 1
                if(POWER_LINK_FLAG==1)
                {
                  while(1)
                  {
                  ScanPowerkey();
                  #if 0  
                  #ifdef USE_HI3521_UART2
                  if(RS2_in!=0 /*&& !(GetDisplayedOSD() & MENU)*/)    //william-v1410-20120524
                  #else
                  if(RS_in!=0 /*&& !(GetDisplayedOSD() & MENU)*/)   //william-v1410-20120524
                  #endif  
                  {
                  val=DvrReceivePaser();  
                  //Printf("\r\nDvrReceivePaser=%02x",(WORD)val);
                  //RS_in=0;
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 89  

                  }
                  #endif
                  if(Power_Active)
                    break;
                  }
                }
                #endif
                LED_BLINK_flag=1;
                //ChangeInput(CH_CAMD);
                TL057I_GREEN_LED=0;
                TL057I_RED_LED=1;
                COMPOSITE2Input();
                #if 1
                LCDPowerON(0);
                //SetBacklight();
                Wait_ms(100);
                P1_6=1;
                AdjustBacklight(0x80);
                #if 0
                SetBacklight();
                Wait_ms(100);
                P1_6=1;
                switch(OSD_BRIGHTNESS_FLAG)
                {
                case BRIGHTNESS_MIN:
                  
                  AdjustBacklight(0x80);
                  Printf("\r\n SET BRIGHTNESS MIN",0);  
                  break;
                case BRIGHTNESS_NORMAL:
                  //WriteEEP(EEP_OSD_BRIGHTNESS,BRIGHTNESS_NORMAL);
                  
                  //AdjustBacklight(0xBF);
                  //AdjustBacklight(0x93);
                  AdjustBacklight(0x97);
                  //AdjustBacklight(0xE8);
                  Printf("\r\n SET BRIGHTNESS NORMAL",0);  
                  break;
                case BRIGHTNESS_MAX:
                  //WriteEEP(EEP_OSD_BRIGHTNESS,BRIGHTNESS_MAX);
                  AdjustBacklight(0xFF);
                  Printf("\r\n SET BRIGHTNESS MAX",0);  
                  break;
                }
                #endif
                //ChangeInput(CH_CAMD);
                #endif
                
                P1_7=1;
                //SetVideoBrightnessReg(0xD6);
                //SetVideoContrastReg(0x76);
                DisplayPowerOnOffINFOOSD(1);  
                
                //Printf("\r\n DELAY_1",0);  
                //Wait_ms(5000);
                //Printf("\r\n DELAY_2",0);  
                //Wait_ms(5000);  
                //Printf("\r\n DELAY_3",0);  
              
                #if 1
                tic_Init_time=100000;
                while(1)
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 90  

                {
                if(tic_Init_time==0)
                  break;  
                }
                #endif
                  
                
                temp[0]=0xFE;
                protocol_send_cmd_with_param_num(0x09, (BYTE *)temp, 1);
                Printf("\r\n SEND_MESSAGE_1",0); 
                Wait_ms(1000);  
                //ChangeInput(CH_TW2835);
                //ClearGAUGEINFO();
                //WriteTW88( 0x78, 0x38); 
              #endif
2669   1      
2670   1        //PowerFlag=1;
2671   1      
2672   1        while(1) {
2673   2        if(PowerFlag)
2674   2          main_loop();    //exit when power off
2675   2          
2676   2          //PowerOff();
2677   2          //AudioMute(0);
2678   2          //PowerLED(OFF);
2679   2          //clrBacklight();
2680   2          //Wait_ms(100);
2681   2          //Panel_Disable();
2682   2          WaitPowerOn();
2683   2        }
2684   1      }
2685          
2686          void WaitPowerOn(void)
2687          {
2688   1      
2689   1      //  BYTE ikey,val;
2690   1      //  BYTE VGATrigger=0;
2691   1        //BYTE AutoKey, _RemoDataCode;
2692   1      
2693   1        dPuts("\r\n++(PowerOFF)__");
2694   1      
2695   1        while(1) 
2696   1        {
2697   2          
2698   2      #if 0///def SUPPORT_SDCARD
                  ACCPowerControl();
                  if(RS2_in!=0 && !(GetDisplayedOSD() & MENU))
                    {
                    DvrReceivePaser();  
                    RS2_in=0;
                    }
                  
                  if(GetDVRStatusflag==1)
                    {
                    Hs_DvrTxCmdPaser(GetDVRStatus);
                    Hs_DvrTxCmdPaser(GetDVRParam);
                    Hs_DvrTxCmdPaser(GetDATETIME);
                    //Hs_DvrTxCmdPaser(GetDVRVersion);    
                    GetDVRStatusflag=0;
                    }
              #endif    
2715   2          //--------------Check Trigger ---------------------
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 91  

2716   2      
2717   2      #if 0
                    SelectBoxHandler();
                  if(SelectBoxMode>0)
                    {
                      LCDPowerON(0);  
                      AudioMute(1);
                      //DisplayInput();   //william v0.2 20120223
              
                    }
                  else
              #endif      
2728   2      #if 0
                    val=CheckTrigger();
                    if(val!=0)
                    { 
                      TriggerHandler(val);
                      //DisplayInput();   //william v0.2 20120223
                      if(!(TriggerMode==0x08))
                      {
                        LCDPowerON(0);  
                        AudioMute(1);
                      }
                    }
                    else
                    {
                      PowerOff();
                      AudioMute(0);
                      TriggerHandler(val);  
                    }
              
                  if(((GetDisplayedOSD() & INPUTINFO)||(GetDisplayedOSD() & GAUGEINFO))&& DVR_Ready==1)
                    DisplayDVRStatus();
                  
                  if( (ikey = GetKey(0)) ) {
                    #ifdef POWERKEY
                    if( ikey==POWERKEY && CheckTrigger()==0)
                      {
                      PowerFlag=1;
                      WriteEEP(EEP_Powerflag,PowerFlag);//2007.3.28 Justin
                      break;    //poweron
                      }
                    #endif
                  }
                  #if 0
                  if( IsRemoDataReady(&_RemoDataCode, &AutoKey) ) {
                    if( _RemoDataCode==REMO_STANDBY && !AutoKey )   //POWERON
                      break;    //poweron
                  
                  }
                  #endif
              #endif
2768   2      
2769   2        }
2770   1      
2771   1        dPuts("\r\n++(PowerOn)__");
2772   1      
2773   1      //  PowerLED(ON);
2774   1        //AudioMute(1);
2775   1      //  ChangeVol(0);
2776   1      
2777   1      //  LCDPowerON(0);
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 92  

2778   1      //if(VGATrigger==0)
2779   1      //  DisplayInput();
2780   1      
2781   1      
2782   1      }
2783          
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 93  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION Com0040 (BEGIN)
0000         L?0065:
0000 7C45              MOV     R4,#045H
0002         L?0066:
0002 120000      E     LCALL   ?C?LLDXDATA0
0005         L?0067:
0005 120000      E     LCALL   ?C?FPMUL
0008 E4                CLR     A
0009 FB                MOV     R3,A
000A FA                MOV     R2,A
000B 797A              MOV     R1,#07AH
000D 7844              MOV     R0,#044H
000F 020000      E     LJMP    ?C?FPDIV
0012         L?0068:
0012 120000      E     LCALL   ?C?CASTF
0015 900000      R     MOV     DPTR,#EncorderLenint
0018 EF                MOV     A,R7
0019 F0                MOVX    @DPTR,A
001A 7BFF              MOV     R3,#0FFH
001C 7A00        R     MOV     R2,#HIGH ?SC_174
001E 7900        R     MOV     R1,#LOW ?SC_174
0020         L?0069:
0020 E0                MOVX    A,@DPTR
0021 FF                MOV     R7,A
0022 E4                CLR     A
0023         L?0070:
0023 900000      E     MOV     DPTR,#?_Printf?BYTE+03H
0026 F0                MOVX    @DPTR,A
0027 A3                INC     DPTR
0028 EF                MOV     A,R7
0029 F0                MOVX    @DPTR,A
002A 22                RET     
002B         L?0072:
002B 7FCD              MOV     R7,#0CDH
002D 7ECC              MOV     R6,#0CCH
002F 7D4C              MOV     R5,#04CH
0031 7C3D              MOV     R4,#03DH
0033 900000      R     MOV     DPTR,#EncorderLen
0036 120000      E     LCALL   ?C?LLDXDATA0
0039 120000      E     LCALL   ?C?FPADD
003C         L?0073:
003C E4                CLR     A
003D FB                MOV     R3,A
003E FA                MOV     R2,A
003F 7920              MOV     R1,#020H
0041 7841              MOV     R0,#041H
0043 120000      E     LCALL   ?C?FPMUL
0046 120000      E     LCALL   ?C?CASTF
0049 900000      R     MOV     DPTR,#EncorderLenfloaat
004C EE                MOV     A,R6
004D F0                MOVX    @DPTR,A
004E A3                INC     DPTR
004F EF                MOV     A,R7
0050 F0                MOVX    @DPTR,A
0051 22                RET     
0052         L?0074:
0052 7F0A              MOV     R7,#0AH
0054 7ED7              MOV     R6,#0D7H
0056 7D23              MOV     R5,#023H
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 94  

0058 7C3C              MOV     R4,#03CH
005A         L?0075:
005A 120000      E     LCALL   ?C?LLDXDATA0
005D 020000      E     LJMP    ?C?FPMUL
0060         L?0076:
0060 900000      R     MOV     DPTR,#a
0063 F0                MOVX    @DPTR,A
0064 A3                INC     DPTR
0065 EF                MOV     A,R7
0066 F0                MOVX    @DPTR,A
0067         L?0077:
0067 900000      R     MOV     DPTR,#fromRange
006A         L?0078:
006A 120000      E     LCALL   ?C?PLDXDATA
006D         L?0079:
006D 900004            MOV     DPTR,#04H
0070 020000      E     LJMP    ?C?ILDOPTR
0073         L?0081:
0073 900000      R     MOV     DPTR,#fromValue
0076 E0                MOVX    A,@DPTR
0077 FE                MOV     R6,A
0078 A3                INC     DPTR
0079 E0                MOVX    A,@DPTR
007A FF                MOV     R7,A
007B C3                CLR     C
007C EF                MOV     A,R7
007D 9B                SUBB    A,R3
007E FF                MOV     R7,A
007F EE                MOV     A,R6
0080 9A                SUBB    A,R2
0081 FE                MOV     R6,A
0082 900000      R     MOV     DPTR,#a
0085 E0                MOVX    A,@DPTR
0086 FC                MOV     R4,A
0087 A3                INC     DPTR
0088 E0                MOVX    A,@DPTR
0089 FD                MOV     R5,A
008A 120000      E     LCALL   ?C?IMUL
008D A3                INC     DPTR
008E E0                MOVX    A,@DPTR
008F FC                MOV     R4,A
0090 A3                INC     DPTR
0091 E0                MOVX    A,@DPTR
0092 FD                MOV     R5,A
0093 020000      E     LJMP    ?C?SIDIV
0096         L?0082:
0096 7403              MOV     A,#03H
0098         L?0083:
0098 7A00        R     MOV     R2,#HIGH buf
009A 7900        R     MOV     R1,#LOW buf
009C 900000      R     MOV     DPTR,#?_mcuLib_ProtocolSendCmdWithParamNum?BYTE+04H
009F F0                MOVX    @DPTR,A
00A0 22                RET     
00A1         L?0084:
00A1         L?0085:
00A1 120000      E     LCALL   ?C?LLDXDATA0
00A4 120000      E     LCALL   ?C?FPADD
00A7         L?0086:
00A7 900000      R     MOV     DPTR,#EncorderLen
00AA 020000      E     LJMP    ?C?LSTXDATA
00AD         L?0087:
00AD 120000      E     LCALL   ?C?CSTOPTR
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 95  

00B0         L?0088:
00B0 900000      R     MOV     DPTR,#piLen
00B3 020000      E     LJMP    ?C?PLDXDATA
00B6         L?0089:
00B6 7B01              MOV     R3,#01H
00B8 7A00        R     MOV     R2,#HIGH iLen
00BA 7900        R     MOV     R1,#LOW iLen
00BC 900000      R     MOV     DPTR,#?_mcuLib_ProtocolAppend?BYTE+03H
00BF 120000      E     LCALL   ?C?PSTXDATA
00C2 900000      R     MOV     DPTR,#?_mcuLib_ProtocolAppend?BYTE+06H
00C5 22                RET     
00C6         L?0090:
00C6 FF                MOV     R7,A
00C7 AEF0              MOV     R6,B
00C9 900002            MOV     DPTR,#02H
00CC 120000      E     LCALL   ?C?ILDOPTR
00CF C3                CLR     C
00D0 9F                SUBB    A,R7
00D1 FF                MOV     R7,A
00D2 E5F0              MOV     A,B
00D4 9E                SUBB    A,R6
00D5 22                RET     
00D6         L?0091:
00D6 7C00              MOV     R4,#00H
00D8 7D0A              MOV     R5,#0AH
00DA 120000      E     LCALL   ?C?UIDIV
00DD 900000      R     MOV     DPTR,#EncorderLenfloaat
00E0 EC                MOV     A,R4
00E1 F0                MOVX    @DPTR,A
00E2 A3                INC     DPTR
00E3 ED                MOV     A,R5
00E4 F0                MOVX    @DPTR,A
00E5 22                RET     
00E6         L?0092:
00E6 900000      E     MOV     DPTR,#EncorderCount
00E9         L?0093:
00E9 E0                MOVX    A,@DPTR
00EA FE                MOV     R6,A
00EB A3                INC     DPTR
00EC E0                MOVX    A,@DPTR
00ED FF                MOV     R7,A
00EE C3                CLR     C
00EF 22                RET     
00F0         L?0094:
00F0 900000      R     MOV     DPTR,#EncorderCountTemp
00F3 E0                MOVX    A,@DPTR
00F4 FC                MOV     R4,A
00F5 A3                INC     DPTR
00F6 E0                MOVX    A,@DPTR
00F7 FD                MOV     R5,A
00F8 E4                CLR     A
00F9 020000      E     LJMP    ?C?FCASTI
00FC         L?0095:
00FC 120000      E     LCALL   ?C?LSTXDATA
00FF 7F0A              MOV     R7,#0AH
0101 7ED7              MOV     R6,#0D7H
0103 7D23              MOV     R5,#023H
0105 7C3C              MOV     R4,#03CH
0107 22                RET     
0108         L?0096:
0108         L?0097:
0108 900000      R     MOV     DPTR,#EncorderCountTemp
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 96  

010B E0                MOVX    A,@DPTR
010C FE                MOV     R6,A
010D A3                INC     DPTR
010E E0                MOVX    A,@DPTR
010F 22                RET     
0110         L?0098:
0110 7BFF              MOV     R3,#0FFH
0112 900000      E     MOV     DPTR,#?_Printf?BYTE+03H
0115 EE                MOV     A,R6
0116 F0                MOVX    @DPTR,A
0117 A3                INC     DPTR
0118 EF                MOV     A,R7
0119 F0                MOVX    @DPTR,A
011A 22                RET     
011B         L?0099:
011B E4                CLR     A
011C FF                MOV     R7,A
011D FE                MOV     R6,A
011E 7DF5              MOV     R5,#0F5H
0120 7C41              MOV     R4,#041H
0122 900000      R     MOV     DPTR,#EncorderParaTemp1
0125 22                RET     
0126         L?0100:
0126 FE                MOV     R6,A
0127 900000      R     MOV     DPTR,#b
012A F0                MOVX    @DPTR,A
012B A3                INC     DPTR
012C EF                MOV     A,R7
012D F0                MOVX    @DPTR,A
012E 4E                ORL     A,R6
012F 22                RET     
0130         L?0101:
0130         L?0102:
0130 120000      E     LCALL   ?C?LLDXDATA0
0133 020000      E     LJMP    ?C?FPADD
             ; FUNCTION Com0040 (END)

             ; FUNCTION _mcuLib_ProtocolAppend (BEGIN)
                                           ; SOURCE LINE # 930
0000 900000      R     MOV     DPTR,#pucBuf
0003 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 931
0006 900000      R     MOV     DPTR,#ucByte
0009 E0                MOVX    A,@DPTR
000A FF                MOV     R7,A
000B 647E              XRL     A,#07EH
000D 6005              JZ      ?C0002
000F EF                MOV     A,R7
0010 647D              XRL     A,#07DH
0012 7026              JNZ     ?C0001
0014         ?C0002:
                                           ; SOURCE LINE # 932
0014 120000      R     LCALL   L?0088
0017 120000      E     LCALL   ?C?CLDPTR
001A FF                MOV     R7,A
001B 900000      R     MOV     DPTR,#pucBuf
001E 120000      E     LCALL   ?C?PLDXDATA
0021 8F82              MOV     DPL,R7
0023 758300            MOV     DPH,#00H
0026 747D              MOV     A,#07DH
                                           ; SOURCE LINE # 933
0028 120000      R     LCALL   L?0087
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 97  

002B 7401              MOV     A,#01H
002D 120000      E     LCALL   ?C?CILDPTR
                                           ; SOURCE LINE # 934
0030 900000      R     MOV     DPTR,#ucByte
0033 E0                MOVX    A,@DPTR
0034 540F              ANL     A,#0FH
0036 4450              ORL     A,#050H
                                           ; SOURCE LINE # 935
                                           ; SOURCE LINE # 936
0038 8004              SJMP    ?C0053
003A         ?C0001:
                                           ; SOURCE LINE # 937
003A 900000      R     MOV     DPTR,#ucByte
003D E0                MOVX    A,@DPTR
003E         ?C0053:
003E FF                MOV     R7,A
003F 120000      R     LCALL   L?0088
0042 120000      E     LCALL   ?C?CLDPTR
0045 FE                MOV     R6,A
0046 900000      R     MOV     DPTR,#pucBuf
0049 120000      E     LCALL   ?C?PLDXDATA
004C 8E82              MOV     DPL,R6
004E 758300            MOV     DPH,#00H
0051 EF                MOV     A,R7
                                           ; SOURCE LINE # 938
0052 120000      R     LCALL   L?0087
0055 7401              MOV     A,#01H
0057 120000      E     LCALL   ?C?CILDPTR
                                           ; SOURCE LINE # 939
005A         ?C0003:
                                           ; SOURCE LINE # 940
005A 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 941
005C 22                RET     
             ; FUNCTION _mcuLib_ProtocolAppend (END)

             ; FUNCTION _mcuLib_ProtocolSendCmdWithParamNum (BEGIN)
                                           ; SOURCE LINE # 943
0000 900000      R     MOV     DPTR,#pucParam
0003 120000      E     LCALL   ?C?PSTXDATA
;---- Variable 'ucType' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 944
;---- Variable 'ucChecksum' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 949
0006 900000      R     MOV     DPTR,#pucBuf
0009 747E              MOV     A,#07EH
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 950
000C 900000      R     MOV     DPTR,#iLen
000F 7401              MOV     A,#01H
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 951
0012 EF                MOV     A,R7
0013 FD                MOV     R5,A
                                           ; SOURCE LINE # 952
0014 120000      R     LCALL   L?0089
0017 EF                MOV     A,R7
0018 F0                MOVX    @DPTR,A
0019 7A00        R     MOV     R2,#HIGH pucBuf
001B 7900        R     MOV     R1,#LOW pucBuf
001D 120000      R     LCALL   _mcuLib_ProtocolAppend
                                           ; SOURCE LINE # 953
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 98  

0020 900000      R     MOV     DPTR,#ucSize
0023 E0                MOVX    A,@DPTR
                                           ; SOURCE LINE # 954
0024 120000      R     LCALL   L?0071
                                           ; SOURCE LINE # 956
0027 E4                CLR     A
0028 900000      R     MOV     DPTR,#i
002B F0                MOVX    @DPTR,A
002C         ?C0005:
002C 900000      R     MOV     DPTR,#ucSize
002F E0                MOVX    A,@DPTR
0030 FF                MOV     R7,A
0031 900000      R     MOV     DPTR,#i
0034 E0                MOVX    A,@DPTR
0035 FE                MOV     R6,A
0036 C3                CLR     C
0037 9F                SUBB    A,R7
0038 5019              JNC     ?C0006
                                           ; SOURCE LINE # 957
003A 900000      R     MOV     DPTR,#pucParam
003D 120000      E     LCALL   ?C?PLDXDATA
0040 8E82              MOV     DPL,R6
0042 758300            MOV     DPH,#00H
0045 120000      E     LCALL   ?C?CLDOPTR
                                           ; SOURCE LINE # 958
0048 120000      R     LCALL   L?0071
                                           ; SOURCE LINE # 959
004B 900000      R     MOV     DPTR,#i
004E E0                MOVX    A,@DPTR
004F 04                INC     A
0050 F0                MOVX    @DPTR,A
0051 80D9              SJMP    ?C0005
0053         ?C0006:
                                           ; SOURCE LINE # 961
0053 120000      R     LCALL   L?0089
0056 ED                MOV     A,R5
0057 F0                MOVX    @DPTR,A
0058 7A00        R     MOV     R2,#HIGH pucBuf
005A 7900        R     MOV     R1,#LOW pucBuf
005C 120000      R     LCALL   _mcuLib_ProtocolAppend
                                           ; SOURCE LINE # 964
005F E4                CLR     A
0060 900000      R     MOV     DPTR,#i
0063 F0                MOVX    @DPTR,A
0064         ?C0008:
0064 900000      R     MOV     DPTR,#iLen
0067 E0                MOVX    A,@DPTR
0068 FF                MOV     R7,A
0069 A3                INC     DPTR
006A E0                MOVX    A,@DPTR
006B FE                MOV     R6,A
006C C3                CLR     C
006D 9F                SUBB    A,R7
006E 5017              JNC     ?C0009
                                           ; SOURCE LINE # 965
0070 7400        R     MOV     A,#LOW pucBuf
0072 2E                ADD     A,R6
0073 F582              MOV     DPL,A
0075 E4                CLR     A
0076 3400        R     ADDC    A,#HIGH pucBuf
0078 F583              MOV     DPH,A
007A E0                MOVX    A,@DPTR
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 99  

007B FF                MOV     R7,A
007C 120000      E     LCALL   _RS_tx
                                           ; SOURCE LINE # 966
007F 900000      R     MOV     DPTR,#i
0082 E0                MOVX    A,@DPTR
0083 04                INC     A
0084 F0                MOVX    @DPTR,A
0085 80DD              SJMP    ?C0008
0087         ?C0009:
                                           ; SOURCE LINE # 969
0087 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 970
0089 22                RET     
008A         L?0071:
008A FF                MOV     R7,A
008B 6D                XRL     A,R5
008C FD                MOV     R5,A
008D 7B01              MOV     R3,#01H
008F 7A00        R     MOV     R2,#HIGH iLen
0091 7900        R     MOV     R1,#LOW iLen
0093 900000      R     MOV     DPTR,#?_mcuLib_ProtocolAppend?BYTE+03H
0096 120000      E     LCALL   ?C?PSTXDATA
0099 900000      R     MOV     DPTR,#?_mcuLib_ProtocolAppend?BYTE+06H
009C EF                MOV     A,R7
009D F0                MOVX    @DPTR,A
009E 7A00        R     MOV     R2,#HIGH pucBuf
00A0 7900        R     MOV     R1,#LOW pucBuf
00A2 120000      R     LCALL   _mcuLib_ProtocolAppend
00A5 22                RET     
             ; FUNCTION _mcuLib_ProtocolSendCmdWithParamNum (END)

             ; FUNCTION _MCU_SendCmdToDVR (BEGIN)
                                           ; SOURCE LINE # 973
0000 900000      R     MOV     DPTR,#ucType
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 974
                                           ; SOURCE LINE # 975
0005 7800        R     MOV     R0,#LOW buf
0007 7C00        R     MOV     R4,#HIGH buf
0009 7D01              MOV     R5,#01H
000B 7BFF              MOV     R3,#0FFH
000D 7A00        R     MOV     R2,#HIGH _?ix1000
000F 7900        R     MOV     R1,#LOW _?ix1000
0011 7E00              MOV     R6,#00H
0013 7F03              MOV     R7,#03H
0015 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 977
0018 900000      R     MOV     DPTR,#ucType
001B E0                MOVX    A,@DPTR
001C 247F              ADD     A,#07FH
001E 601C              JZ      ?C0014
0020 14                DEC     A
0021 603D              JZ      ?C0015
0023 14                DEC     A
0024 6045              JZ      ?C0016
0026 2403              ADD     A,#03H
0028 7052              JNZ     ?C0018
                                           ; SOURCE LINE # 978
                                           ; SOURCE LINE # 979
002A         ?C0013:
                                           ; SOURCE LINE # 980
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 100 

002A E4                CLR     A
002B 900000      R     MOV     DPTR,#buf
002E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 981
002F A3                INC     DPTR
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 982
0031 A3                INC     DPTR
0032 04                INC     A
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 983
0034 FB                MOV     R3,A
0035 120000      R     LCALL   L?0082
0038 7F80              MOV     R7,#080H
                                           ; SOURCE LINE # 984
003A 803D              SJMP    ?C0056
                                           ; SOURCE LINE # 985
003C         ?C0014:
                                           ; SOURCE LINE # 986
003C 900000      R     MOV     DPTR,#g_stBatteryInfo
003F E0                MOVX    A,@DPTR
0040 541F              ANL     A,#01FH
0042 900000      R     MOV     DPTR,#buf
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 987
0046 900000      R     MOV     DPTR,#EncorderLenint
0049 E0                MOVX    A,@DPTR
004A 900000      R     MOV     DPTR,#buf+01H
004D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 988
004E 900000      R     MOV     DPTR,#EncorderLenfloaat
0051 A3                INC     DPTR
0052 E0                MOVX    A,@DPTR
0053 900000      R     MOV     DPTR,#buf+02H
0056 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 989
0057 7B01              MOV     R3,#01H
0059 120000      R     LCALL   L?0082
005C 7F81              MOV     R7,#081H
005E         ?C0054:
                                           ; SOURCE LINE # 990
005E 8019              SJMP    ?C0056
                                           ; SOURCE LINE # 991
0060         ?C0015:
                                           ; SOURCE LINE # 992
0060 7B01              MOV     R3,#01H
0062 7401              MOV     A,#01H
0064 120000      R     LCALL   L?0083
0067 7F82              MOV     R7,#082H
0069         ?C0055:
                                           ; SOURCE LINE # 993
0069 800E              SJMP    ?C0056
                                           ; SOURCE LINE # 994
006B         ?C0016:
                                           ; SOURCE LINE # 995
006B 7B01              MOV     R3,#01H
006D 7A00        R     MOV     R2,#HIGH buf
006F 7900        R     MOV     R1,#LOW buf
0071 900000      R     MOV     DPTR,#?_mcuLib_ProtocolSendCmdWithParamNum?BYTE+04H
0074 7401              MOV     A,#01H
0076 F0                MOVX    @DPTR,A
0077 7F83              MOV     R7,#083H
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 101 

0079         ?C0056:
0079 120000      R     LCALL   _mcuLib_ProtocolSendCmdWithParamNum
                                           ; SOURCE LINE # 996
                                           ; SOURCE LINE # 998
                                           ; SOURCE LINE # 999
                                           ; SOURCE LINE # 1001
                                           ; SOURCE LINE # 1003
007C         ?C0018:
007C 22                RET     
             ; FUNCTION _MCU_SendCmdToDVR (END)

             ; FUNCTION InitialTimerEvent (BEGIN)
                                           ; SOURCE LINE # 1342
                                           ; SOURCE LINE # 1343
                                           ; SOURCE LINE # 1344
0000 120000      E     LCALL   MCUTimerInitialTimerEvent
                                           ; SOURCE LINE # 1346
0003 7D1D              MOV     R5,#01DH
0005 7F88              MOV     R7,#088H
0007 7E13              MOV     R6,#013H
0009 120000      E     LCALL   _MCUTimerActiveTimerEvent
                                           ; SOURCE LINE # 1348
000C 7D2D              MOV     R5,#02DH
000E 7FE8              MOV     R7,#0E8H
0010 7E03              MOV     R6,#03H
0012 020000      E     LJMP    _MCUTimerActiveTimerEvent
             ; FUNCTION InitialTimerEvent (END)

             ; FUNCTION _Mapping1 (BEGIN)
                                           ; SOURCE LINE # 1354
0000 900000      R     MOV     DPTR,#fromValue
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 1355
                                           ; SOURCE LINE # 1362
000C 120000      R     LCALL   L?0079
000F FD                MOV     R5,A
0010 D3                SETB    C
0011 EF                MOV     A,R7
0012 9D                SUBB    A,R5
0013 E5F0              MOV     A,B
0015 6480              XRL     A,#080H
0017 F8                MOV     R0,A
0018 EE                MOV     A,R6
0019 6480              XRL     A,#080H
001B 98                SUBB    A,R0
001C 5040              JNC     ?C0020
                                           ; SOURCE LINE # 1363
001E 900000      R     MOV     DPTR,#toRange
0021 120000      R     LCALL   L?0078
0024 FF                MOV     R7,A
0025 AEF0              MOV     R6,B
0027 120000      E     LCALL   ?C?ILDPTR
002A FD                MOV     R5,A
002B C3                CLR     C
002C EF                MOV     A,R7
002D 9D                SUBB    A,R5
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 102 

002E FF                MOV     R7,A
002F EE                MOV     A,R6
0030 95F0              SUBB    A,B
                                           ; SOURCE LINE # 1364
0032 120000      R     LCALL   L?0076
0035 FD                MOV     R5,A
0036 ACF0              MOV     R4,B
0038 120000      E     LCALL   ?C?ILDPTR
003B FB                MOV     R3,A
003C AAF0              MOV     R2,B
003E C3                CLR     C
003F ED                MOV     A,R5
0040 9B                SUBB    A,R3
0041 FF                MOV     R7,A
0042 EC                MOV     A,R4
0043 9A                SUBB    A,R2
                                           ; SOURCE LINE # 1366
0044 120000      R     LCALL   L?0100
0047 7002              JNZ     ?C0021
0049 FF                MOV     R7,A
004A 22                RET     
004B         ?C0021:
                                           ; SOURCE LINE # 1368
004B 120000      R     LCALL   L?0081
004E C006              PUSH    AR6
0050 C007              PUSH    AR7
0052 900000      R     MOV     DPTR,#toRange
0055 120000      E     LCALL   ?C?PLDXDATA
0058 120000      E     LCALL   ?C?ILDPTR
                                           ; SOURCE LINE # 1369
005B 020000      R     LJMP    ?C0057
005E         ?C0020:
                                           ; SOURCE LINE # 1370
                                           ; SOURCE LINE # 1371
005E 900000      R     MOV     DPTR,#toRange
0061 120000      R     LCALL   L?0078
0064 120000      R     LCALL   L?0090
                                           ; SOURCE LINE # 1372
0067 120000      R     LCALL   L?0076
006A 120000      R     LCALL   L?0090
                                           ; SOURCE LINE # 1374
006D 120000      R     LCALL   L?0100
0070 7002              JNZ     ?C0024
0072 FF                MOV     R7,A
0073 22                RET     
0074         ?C0024:
                                           ; SOURCE LINE # 1376
0074 120000      R     LCALL   L?0077
0077 FF                MOV     R7,A
0078 AEF0              MOV     R6,B
007A AB07              MOV     R3,AR7
007C AA06              MOV     R2,AR6
007E 120000      R     LCALL   L?0081
0081 C006              PUSH    AR6
0083 C007              PUSH    AR7
0085 900000      R     MOV     DPTR,#toRange
0088 120000      R     LCALL   L?0078
008B         ?C0057:
008B FF                MOV     R7,A
008C AEF0              MOV     R6,B
008E D0E0              POP     ACC
0090 2F                ADD     A,R7
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 103 

0091 FF                MOV     R7,A
0092 D0E0              POP     ACC
0094 3E                ADDC    A,R6
0095 FE                MOV     R6,A
0096 900000      R     MOV     DPTR,#toValue
0099 120000      E     LCALL   ?C?PLDXDATA
009C EE                MOV     A,R6
009D 8FF0              MOV     B,R7
009F 120000      E     LCALL   ?C?ISTPTR
                                           ; SOURCE LINE # 1377
00A2         ?C0023:
                                           ; SOURCE LINE # 1384
00A2 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 1386
00A4         ?C0022:
00A4 22                RET     
             ; FUNCTION _Mapping1 (END)

             ; FUNCTION _SetAD5110Step (BEGIN)
                                           ; SOURCE LINE # 1388
;---- Variable 'newv' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1389
                                           ; SOURCE LINE # 1393
0000 7E00              MOV     R6,#00H
0002 7B01              MOV     R3,#01H
0004 7A00        R     MOV     R2,#HIGH regv
0006 7900        R     MOV     R1,#LOW regv
0008 900000      R     MOV     DPTR,#?_Mapping1?BYTE+05H
000B 120000      E     LCALL   ?C?PSTXDATA
000E 7A00        R     MOV     R2,#HIGH AD5110Range
0010 7900        R     MOV     R1,#LOW AD5110Range
0012 900000      R     MOV     DPTR,#?_Mapping1?BYTE+08H
0015 120000      E     LCALL   ?C?PSTXDATA
0018 7A00        R     MOV     R2,#HIGH UserRange
001A 7900        R     MOV     R1,#LOW UserRange
001C 120000      R     LCALL   _Mapping1
                                           ; SOURCE LINE # 1395
001F 900000      R     MOV     DPTR,#regv
0022 E0                MOVX    A,@DPTR
0023 FC                MOV     R4,A
0024 A3                INC     DPTR
0025 E0                MOVX    A,@DPTR
0026 FD                MOV     R5,A
0027 7F02              MOV     R7,#02H
0029 7E00              MOV     R6,#00H
002B 020000      E     LJMP    _WriteAD5110
             ; FUNCTION _SetAD5110Step (END)

             ; FUNCTION LoadEEPROM (BEGIN)
                                           ; SOURCE LINE # 1485
                                           ; SOURCE LINE # 1486
                                           ; SOURCE LINE # 1489
0000 7F10              MOV     R7,#010H
0002 7E00              MOV     R6,#00H
0004 120000      E     LCALL   _ReadEEP
0007 900000      R     MOV     DPTR,#PowerFlag
000A EF                MOV     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1491
000C 7F11              MOV     R7,#011H
000E 7E00              MOV     R6,#00H
0010 120000      E     LCALL   _ReadEEP
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 104 

0013 900000      R     MOV     DPTR,#CameraVolt
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1577
0018 22                RET     
             ; FUNCTION LoadEEPROM (END)

             ; FUNCTION _GetADCValue (BEGIN)
                                           ; SOURCE LINE # 1713
;---- Variable 'sel' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1714
                                           ; SOURCE LINE # 1716
0000 EF                MOV     A,R7
0001 4488              ORL     A,#088H
0003 F5C5              MOV     ADCTL,A
0005         ?C0027:
                                           ; SOURCE LINE # 1718
0005 E5C5              MOV     A,ADCTL
0007 20E3FB            JB      ACC.3,?C0027
                                           ; SOURCE LINE # 1720
000A AFC6              MOV     R7,ADCV
000C EF                MOV     A,R7
000D 75F004            MOV     B,#04H
0010 A4                MUL     AB
0011 FF                MOV     R7,A
0012 E5E8              MOV     A,ADCVL
0014 5403              ANL     A,#03H
0016 FD                MOV     R5,A
0017 EF                MOV     A,R7
0018 4D                ORL     A,R5
0019 FF                MOV     R7,A
001A E5F0              MOV     A,B
001C 5403              ANL     A,#03H
001E FE                MOV     R6,A
                                           ; SOURCE LINE # 1722
001F 22                RET     
             ; FUNCTION _GetADCValue (END)

             ; FUNCTION GetBatteryBTH (BEGIN)
                                           ; SOURCE LINE # 1724
                                           ; SOURCE LINE # 1725
                                           ; SOURCE LINE # 1727
0000 7F06              MOV     R7,#06H
0002 120000      R     LCALL   _GetADCValue
0005 900000      R     MOV     DPTR,#adc
0008 EE                MOV     A,R6
0009 F0                MOVX    @DPTR,A
000A A3                INC     DPTR
000B EF                MOV     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1728
000D 7BFF              MOV     R3,#0FFH
000F 7A00        R     MOV     R2,#HIGH ?SC_0
0011 7900        R     MOV     R1,#LOW ?SC_0
0013 EE                MOV     A,R6
0014 120000      R     LCALL   L?0070
0017 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 1729
001A 900000      R     MOV     DPTR,#adc
001D E0                MOVX    A,@DPTR
001E FE                MOV     R6,A
001F A3                INC     DPTR
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 105 

0020 E0                MOVX    A,@DPTR
0021 FF                MOV     R7,A
                                           ; SOURCE LINE # 1730
0022 22                RET     
             ; FUNCTION GetBatteryBTH (END)

             ; FUNCTION GetBatteryVoltage (BEGIN)
                                           ; SOURCE LINE # 1732
                                           ; SOURCE LINE # 1733
                                           ; SOURCE LINE # 1735
0000 7F07              MOV     R7,#07H
0002 120000      R     LCALL   _GetADCValue
0005 900000      R     MOV     DPTR,#adc
0008 EE                MOV     A,R6
0009 F0                MOVX    @DPTR,A
000A A3                INC     DPTR
000B EF                MOV     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1736
000D 7A00        R     MOV     R2,#HIGH ?SC_16
000F 7900        R     MOV     R1,#LOW ?SC_16
0011 120000      R     LCALL   L?0098
0014 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 1737
0017 900000      R     MOV     DPTR,#adc
001A E0                MOVX    A,@DPTR
001B FE                MOV     R6,A
001C A3                INC     DPTR
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
                                           ; SOURCE LINE # 1738
001F 22                RET     
             ; FUNCTION GetBatteryVoltage (END)

             ; FUNCTION EncorderHandler (BEGIN)
                                           ; SOURCE LINE # 1741
                                           ; SOURCE LINE # 1742
                                           ; SOURCE LINE # 1748
0000 200003      E     JB      ChangeKey,$ + 6H
0003 020000      R     LJMP    ?C0042
                                           ; SOURCE LINE # 1749
                                           ; SOURCE LINE # 1751
0006 900000      R     MOV     DPTR,#Encorder1
0009 120000      R     LCALL   L?0074
000C 900000      R     MOV     DPTR,#EncorderParaTemp1
000F 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1752
0012 900000      R     MOV     DPTR,#Encorder2
0015 120000      R     LCALL   L?0074
0018 900000      R     MOV     DPTR,#EncorderParaTemp2
                                           ; SOURCE LINE # 1753
001B 120000      R     LCALL   L?0095
001E 900000      R     MOV     DPTR,#Encorder3
0021 120000      R     LCALL   L?0075
0024 900000      R     MOV     DPTR,#EncorderParaTemp3
                                           ; SOURCE LINE # 1754
0027 120000      R     LCALL   L?0095
002A 900000      R     MOV     DPTR,#Encorder4
002D 120000      R     LCALL   L?0075
0030 900000      R     MOV     DPTR,#EncorderParaTemp4
0033 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1774
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 106 

0036 7F00              MOV     R7,#00H
0038 7EB0              MOV     R6,#0B0H
003A 7DE5              MOV     R5,#0E5H
003C 900000      R     MOV     DPTR,#EncorderParaTemp1
003F 120000      R     LCALL   L?0065
0042 900000      R     MOV     DPTR,#EncorderOffset1
0045 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1775
0048 7FE1              MOV     R7,#0E1H
004A 7E98              MOV     R6,#098H
004C 7DD2              MOV     R5,#0D2H
004E 900000      R     MOV     DPTR,#EncorderParaTemp2
0051 120000      R     LCALL   L?0065
0054 900000      R     MOV     DPTR,#EncorderOffset1
0057 120000      R     LCALL   L?0101
005A 900000      R     MOV     DPTR,#EncorderOffset2
005D 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1776
0060 7F48              MOV     R7,#048H
0062 7EC1              MOV     R6,#0C1H
0064 7D2C              MOV     R5,#02CH
0066 7C46              MOV     R4,#046H
0068 900000      R     MOV     DPTR,#EncorderParaTemp3
006B 120000      R     LCALL   L?0066
006E 900000      R     MOV     DPTR,#EncorderOffset2
0071 120000      R     LCALL   L?0101
0074 900000      R     MOV     DPTR,#EncorderOffset3
0077 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1785
007A 120000      R     LCALL   L?0092
007D EE                MOV     A,R6
007E 6480              XRL     A,#080H
0080 9480              SUBB    A,#080H
0082 4008              JC      ?C0033
                                           ; SOURCE LINE # 1786
                                           ; SOURCE LINE # 1787
0084 E4                CLR     A
0085 900000      R     MOV     DPTR,#EncorderCountPN
0088 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1788
0089 FC                MOV     R4,A
                                           ; SOURCE LINE # 1789
008A 8011              SJMP    ?C0058
008C         ?C0033:
                                           ; SOURCE LINE # 1791
                                           ; SOURCE LINE # 1792
008C 900000      R     MOV     DPTR,#EncorderCountPN
008F 7401              MOV     A,#01H
0091 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1793
0092 120000      R     LCALL   L?0092
0095 E4                CLR     A
0096 9F                SUBB    A,R7
0097 FF                MOV     R7,A
0098 E4                CLR     A
0099 9E                SUBB    A,R6
009A FE                MOV     R6,A
009B 7C00              MOV     R4,#00H
009D         ?C0058:
009D 7D02              MOV     R5,#02H
009F 120000      E     LCALL   ?C?SIDIV
00A2 900000      R     MOV     DPTR,#EncorderCountTemp
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 107 

00A5 EE                MOV     A,R6
00A6 F0                MOVX    @DPTR,A
00A7 A3                INC     DPTR
00A8 EF                MOV     A,R7
00A9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1794
00AA         ?C0034:
                                           ; SOURCE LINE # 1815
00AA 120000      R     LCALL   L?0096
00AD D3                SETB    C
00AE 94F0              SUBB    A,#0F0H
00B0 EE                MOV     A,R6
00B1 9400              SUBB    A,#00H
00B3 4003              JC      $ + 5H
00B5 020000      R     LJMP    ?C0035
00B8 C3                CLR     C
00B9 EE                MOV     A,R6
00BA 9400              SUBB    A,#00H
00BC 5003              JNC     $ + 5H
00BE 020000      R     LJMP    ?C0035
                                           ; SOURCE LINE # 1816
                                           ; SOURCE LINE # 1818
00C1 7BFF              MOV     R3,#0FFH
00C3 7A00        R     MOV     R2,#HIGH ?SC_36
00C5 7900        R     MOV     R1,#LOW ?SC_36
00C7 900000      R     MOV     DPTR,#EncorderCountTemp
00CA A3                INC     DPTR
00CB E0                MOVX    A,@DPTR
00CC FF                MOV     R7,A
00CD 900000      E     MOV     DPTR,#?_Printf?BYTE+03H
00D0 EE                MOV     A,R6
                                           ; SOURCE LINE # 1819
00D1 120000      R     LCALL   L?0062
                                           ; SOURCE LINE # 1820
00D4 7BFF              MOV     R3,#0FFH
00D6 7A00        R     MOV     R2,#HIGH ?SC_85
00D8 7900        R     MOV     R1,#LOW ?SC_85
00DA 900000      R     MOV     DPTR,#EncorderCountPN
00DD 120000      R     LCALL   L?0069
00E0 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 1825
00E3 120000      R     LCALL   L?0099
00E6 120000      R     LCALL   L?0075
00E9 C004              PUSH    AR4
00EB C005              PUSH    AR5
00ED C006              PUSH    AR6
00EF C007              PUSH    AR7
00F1 120000      R     LCALL   L?0094
00F4 D003              POP     AR3
00F6 D002              POP     AR2
00F8 D001              POP     AR1
00FA D000              POP     AR0
00FC 120000      R     LCALL   L?0067
00FF 120000      R     LCALL   L?0086
                                           ; SOURCE LINE # 1830
0102 120000      R     LCALL   L?0099
0105 120000      R     LCALL   L?0075
0108 C004              PUSH    AR4
010A C005              PUSH    AR5
010C C006              PUSH    AR6
010E C007              PUSH    AR7
0110 120000      R     LCALL   L?0094
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 108 

0113 D003              POP     AR3
0115 D002              POP     AR2
0117 D001              POP     AR1
0119 D000              POP     AR0
011B 120000      E     LCALL   ?C?FPMUL
011E 120000      E     LCALL   ?C?CASTF
0121 900000      R     MOV     DPTR,#temp_val
0124 EE                MOV     A,R6
0125 F0                MOVX    @DPTR,A
0126 A3                INC     DPTR
0127 EF                MOV     A,R7
0128 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1831
0129 7FCD              MOV     R7,#0CDH
012B 7ECC              MOV     R6,#0CCH
012D 7D4C              MOV     R5,#04CH
012F 7C3D              MOV     R4,#03DH
0131 900000      R     MOV     DPTR,#EncorderLen
0134 120000      R     LCALL   L?0102
0137 120000      E     LCALL   ?C?CASTF
013A 900000      R     MOV     DPTR,#EncorderLenint
013D EF                MOV     A,R7
013E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1834
013F 120000      R     LCALL   L?0072
                                           ; SOURCE LINE # 1835
0142 120000      R     LCALL   L?0091
                                           ; SOURCE LINE # 1844
0145 020000      R     LJMP    ?C0036
0148         ?C0035:
                                           ; SOURCE LINE # 1845
0148 120000      R     LCALL   L?0096
014B FF                MOV     R7,A
014C D3                SETB    C
014D 94F0              SUBB    A,#0F0H
014F EE                MOV     A,R6
0150 9400              SUBB    A,#00H
0152 5003              JNC     $ + 5H
0154 020000      R     LJMP    ?C0037
0157 D3                SETB    C
0158 EF                MOV     A,R7
0159 94C2              SUBB    A,#0C2H
015B EE                MOV     A,R6
015C 9401              SUBB    A,#01H
015E 4003              JC      $ + 5H
0160 020000      R     LJMP    ?C0037
                                           ; SOURCE LINE # 1846
                                           ; SOURCE LINE # 1851
0163 7F2F              MOV     R7,#02FH
0165 7E5D              MOV     R6,#05DH
0167 7D00              MOV     R5,#00H
0169 7C42              MOV     R4,#042H
016B 900000      R     MOV     DPTR,#EncorderParaTemp2
016E 120000      R     LCALL   L?0075
0171 C004              PUSH    AR4
0173 C005              PUSH    AR5
0175 C006              PUSH    AR6
0177 C007              PUSH    AR7
0179 900000      R     MOV     DPTR,#EncorderCountTemp+01H
017C E0                MOVX    A,@DPTR
017D 2410              ADD     A,#010H
017F FD                MOV     R5,A
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 109 

0180 900000      R     MOV     DPTR,#EncorderCountTemp
0183 E0                MOVX    A,@DPTR
0184 34FF              ADDC    A,#0FFH
0186 FC                MOV     R4,A
0187 E4                CLR     A
0188 120000      E     LCALL   ?C?FCASTI
018B D003              POP     AR3
018D D002              POP     AR2
018F D001              POP     AR1
0191 D000              POP     AR0
0193 120000      R     LCALL   L?0067
0196 900000      R     MOV     DPTR,#EncorderOffset1
0199 120000      R     LCALL   L?0084
                                           ; SOURCE LINE # 1854
019C 7BFF              MOV     R3,#0FFH
019E 7A00        R     MOV     R2,#HIGH ?SC_107
01A0 7900        R     MOV     R1,#LOW ?SC_107
01A2 900000      R     MOV     DPTR,#EncorderLen_Offset
01A5 120000      R     LCALL   L?0093
01A8 74F0              MOV     A,#0F0H
01AA 9F                SUBB    A,R7
01AB FF                MOV     R7,A
01AC E4                CLR     A
01AD 9E                SUBB    A,R6
01AE FE                MOV     R6,A
01AF C3                CLR     C
01B0 900000      R     MOV     DPTR,#temp_EncorderCountTemp+01H
01B3 E0                MOVX    A,@DPTR
01B4 9F                SUBB    A,R7
01B5 FF                MOV     R7,A
01B6 900000      R     MOV     DPTR,#temp_EncorderCountTemp
01B9 E0                MOVX    A,@DPTR
01BA 9E                SUBB    A,R6
01BB 900000      E     MOV     DPTR,#?_Printf?BYTE+03H
                                           ; SOURCE LINE # 1855
01BE 120000      R     LCALL   L?0062
                                           ; SOURCE LINE # 1856
01C1 7A00        R     MOV     R2,#HIGH ?SC_107
01C3 7900        R     MOV     R1,#LOW ?SC_107
01C5 900000      R     MOV     DPTR,#temp_EncorderCountTemp
                                           ; SOURCE LINE # 1857
01C8 120000      R     LCALL   L?0080
01CB 7BFF              MOV     R3,#0FFH
01CD 7A00        R     MOV     R2,#HIGH ?SC_136
01CF 7900        R     MOV     R1,#LOW ?SC_136
01D1 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 1859
                                           ; SOURCE LINE # 1861
01D4 120000      R     LCALL   L?0061
                                           ; SOURCE LINE # 1862
01D7 120000      R     LCALL   L?0068
01DA 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 1864
                                           ; SOURCE LINE # 1865
                                           ; SOURCE LINE # 1866
                                           ; SOURCE LINE # 1867
01DD 020000      R     LJMP    ?C0059
01E0         ?C0037:
                                           ; SOURCE LINE # 1869
01E0 120000      R     LCALL   L?0097
01E3 FF                MOV     R7,A
01E4 D3                SETB    C
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 110 

01E5 94C2              SUBB    A,#0C2H
01E7 EE                MOV     A,R6
01E8 9401              SUBB    A,#01H
01EA 4053              JC      ?C0039
01EC D3                SETB    C
01ED EF                MOV     A,R7
01EE 940C              SUBB    A,#0CH
01F0 EE                MOV     A,R6
01F1 9403              SUBB    A,#03H
01F3 504A              JNC     ?C0039
                                           ; SOURCE LINE # 1870
                                           ; SOURCE LINE # 1874
01F5 7F19              MOV     R7,#019H
01F7 7E04              MOV     R6,#04H
01F9 7D06              MOV     R5,#06H
01FB 7C42              MOV     R4,#042H
01FD 900000      R     MOV     DPTR,#EncorderParaTemp3
0200 120000      R     LCALL   L?0075
0203 C004              PUSH    AR4
0205 C005              PUSH    AR5
0207 C006              PUSH    AR6
0209 C007              PUSH    AR7
020B 900000      R     MOV     DPTR,#EncorderCountTemp+01H
020E E0                MOVX    A,@DPTR
020F 243E              ADD     A,#03EH
0211 FD                MOV     R5,A
0212 900000      R     MOV     DPTR,#EncorderCountTemp
0215 E0                MOVX    A,@DPTR
0216 34FE              ADDC    A,#0FEH
0218 FC                MOV     R4,A
0219 E4                CLR     A
021A 120000      E     LCALL   ?C?FCASTI
021D D003              POP     AR3
021F D002              POP     AR2
0221 D001              POP     AR1
0223 D000              POP     AR0
0225 120000      R     LCALL   L?0067
0228 900000      R     MOV     DPTR,#EncorderOffset2
022B 120000      R     LCALL   L?0084
                                           ; SOURCE LINE # 1876
                                           ; SOURCE LINE # 1878
022E 120000      R     LCALL   L?0061
0231 120000      E     LCALL   ?C?CASTF
0234 900000      R     MOV     DPTR,#EncorderLenint
0237 EF                MOV     A,R7
0238 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1881
0239         ?C0059:
0239 120000      R     LCALL   L?0072
                                           ; SOURCE LINE # 1882
                                           ; SOURCE LINE # 1883
                                           ; SOURCE LINE # 1884
023C 020000      R     LJMP    ?C0060
023F         ?C0039:
                                           ; SOURCE LINE # 1913
023F D3                SETB    C
0240 900000      R     MOV     DPTR,#EncorderCountTemp+01H
0243 E0                MOVX    A,@DPTR
0244 940C              SUBB    A,#0CH
0246 900000      R     MOV     DPTR,#EncorderCountTemp
0249 E0                MOVX    A,@DPTR
024A 9403              SUBB    A,#03H
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 111 

024C 5003              JNC     $ + 5H
024E 020000      R     LJMP    ?C0036
                                           ; SOURCE LINE # 1914
                                           ; SOURCE LINE # 1918
0251 7F81              MOV     R7,#081H
0253 7E95              MOV     R6,#095H
0255 7D0B              MOV     R5,#0BH
0257 7C42              MOV     R4,#042H
0259 900000      R     MOV     DPTR,#EncorderParaTemp4
025C 120000      R     LCALL   L?0075
025F C004              PUSH    AR4
0261 C005              PUSH    AR5
0263 C006              PUSH    AR6
0265 C007              PUSH    AR7
0267 900000      R     MOV     DPTR,#EncorderCountTemp+01H
026A E0                MOVX    A,@DPTR
026B 24F4              ADD     A,#0F4H
026D FD                MOV     R5,A
026E 900000      R     MOV     DPTR,#EncorderCountTemp
0271 E0                MOVX    A,@DPTR
0272 34FC              ADDC    A,#0FCH
0274 FC                MOV     R4,A
0275 E4                CLR     A
0276 120000      E     LCALL   ?C?FCASTI
0279 D003              POP     AR3
027B D002              POP     AR2
027D D001              POP     AR1
027F D000              POP     AR0
0281 120000      R     LCALL   L?0067
0284 900000      R     MOV     DPTR,#EncorderOffset3
0287 120000      R     LCALL   L?0085
                                           ; SOURCE LINE # 1920
028A 7A00        R     MOV     R2,#HIGH ?SC_154
028C 7900        R     MOV     R1,#LOW ?SC_154
028E 900000      E     MOV     DPTR,#EncorderCount
                                           ; SOURCE LINE # 1922
0291 120000      R     LCALL   L?0080
0294 7BFF              MOV     R3,#0FFH
0296 7A00        R     MOV     R2,#HIGH ?SC_136
0298 7900        R     MOV     R1,#LOW ?SC_136
                                           ; SOURCE LINE # 1923
029A 120000      R     LCALL   L?0063
                                           ; SOURCE LINE # 1924
029D 120000      R     LCALL   L?0068
                                           ; SOURCE LINE # 1926
02A0 120000      R     LCALL   L?0063
02A3 120000      R     LCALL   L?0073
                                           ; SOURCE LINE # 1927
02A6 7A00        R     MOV     R2,#HIGH ?SC_221
02A8 7900        R     MOV     R1,#LOW ?SC_221
02AA 120000      R     LCALL   L?0098
02AD 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 1928
02B0 900000      R     MOV     DPTR,#EncorderLenfloaat
02B3 E0                MOVX    A,@DPTR
02B4 FE                MOV     R6,A
02B5 A3                INC     DPTR
02B6 E0                MOVX    A,@DPTR
02B7 FF                MOV     R7,A
02B8         ?C0060:
02B8 120000      R     LCALL   L?0091
                                           ; SOURCE LINE # 1929
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 112 

02BB 7BFF              MOV     R3,#0FFH
02BD 7A00        R     MOV     R2,#HIGH ?SC_195
02BF 7900        R     MOV     R1,#LOW ?SC_195
02C1 900000      R     MOV     DPTR,#EncorderLenint
02C4 120000      R     LCALL   L?0069
02C7 A3                INC     DPTR
02C8 EC                MOV     A,R4
02C9 F0                MOVX    @DPTR,A
02CA A3                INC     DPTR
02CB ED                MOV     A,R5
02CC F0                MOVX    @DPTR,A
02CD 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 1930
02D0         ?C0036:
                                           ; SOURCE LINE # 1932
02D0 C200        E     CLR     ChangeKey
                                           ; SOURCE LINE # 1933
02D2 900000      R     MOV     DPTR,#EncorderLenint
02D5 E0                MOVX    A,@DPTR
02D6 900000      R     MOV     DPTR,#param
02D9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1934
02DA 900000      R     MOV     DPTR,#EncorderLenfloaat
02DD A3                INC     DPTR
02DE E0                MOVX    A,@DPTR
02DF 900000      R     MOV     DPTR,#param+01H
02E2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1935
02E3 900000      R     MOV     DPTR,#EncorderCountPN
02E6 E0                MOVX    A,@DPTR
02E7 900000      R     MOV     DPTR,#param+02H
02EA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1940
                                           ; SOURCE LINE # 1942
02EB         ?C0042:
02EB 22                RET     
02EC         L?0061:
02EC 7BFF              MOV     R3,#0FFH
02EE 7A00        R     MOV     R2,#HIGH ?SC_154
02F0 7900        R     MOV     R1,#LOW ?SC_154
02F2 900000      E     MOV     DPTR,#EncorderCount
02F5 E0                MOVX    A,@DPTR
02F6 FF                MOV     R7,A
02F7 A3                INC     DPTR
02F8 E0                MOVX    A,@DPTR
02F9 900000      E     MOV     DPTR,#?_Printf?BYTE+03H
02FC CF                XCH     A,R7
02FD F0                MOVX    @DPTR,A
02FE A3                INC     DPTR
02FF EF                MOV     A,R7
0300 F0                MOVX    @DPTR,A
0301 120000      E     LCALL   _Printf
0304 7FCD              MOV     R7,#0CDH
0306 7ECC              MOV     R6,#0CCH
0308 7D4C              MOV     R5,#04CH
030A 7C3D              MOV     R4,#03DH
030C 900000      R     MOV     DPTR,#EncorderLen
030F 120000      E     LCALL   ?C?LLDXDATA0
0312 120000      E     LCALL   ?C?FPADD
0315 22                RET     
0316         L?0062:
0316 F0                MOVX    @DPTR,A
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 113 

0317 A3                INC     DPTR
0318 EF                MOV     A,R7
0319 F0                MOVX    @DPTR,A
031A 120000      E     LCALL   _Printf
031D 7BFF              MOV     R3,#0FFH
031F 7A00        R     MOV     R2,#HIGH ?SC_60
0321 7900        R     MOV     R1,#LOW ?SC_60
0323 900000      R     MOV     DPTR,#EncorderLen_Offset
0326 E0                MOVX    A,@DPTR
0327 FF                MOV     R7,A
0328 A3                INC     DPTR
0329 E0                MOVX    A,@DPTR
032A 900000      E     MOV     DPTR,#?_Printf?BYTE+03H
032D CF                XCH     A,R7
032E F0                MOVX    @DPTR,A
032F A3                INC     DPTR
0330 EF                MOV     A,R7
0331 F0                MOVX    @DPTR,A
0332 120000      E     LCALL   _Printf
0335 22                RET     
0336         L?0063:
0336 120000      E     LCALL   _Printf
0339 7FCD              MOV     R7,#0CDH
033B 7ECC              MOV     R6,#0CCH
033D 7D4C              MOV     R5,#04CH
033F 7C3D              MOV     R4,#03DH
0341 900000      R     MOV     DPTR,#EncorderLen
0344 120000      E     LCALL   ?C?LLDXDATA0
0347 120000      E     LCALL   ?C?FPADD
034A 22                RET     
034B         L?0080:
034B 7BFF              MOV     R3,#0FFH
034D E0                MOVX    A,@DPTR
034E FF                MOV     R7,A
034F A3                INC     DPTR
0350 E0                MOVX    A,@DPTR
0351 900000      E     MOV     DPTR,#?_Printf?BYTE+03H
0354 CF                XCH     A,R7
0355 F0                MOVX    @DPTR,A
0356 A3                INC     DPTR
0357 EF                MOV     A,R7
0358 F0                MOVX    @DPTR,A
0359 120000      E     LCALL   _Printf
035C 900000      R     MOV     DPTR,#EncorderLen
035F 120000      E     LCALL   ?C?LLDXDATA
0362 120000      E     LCALL   ?C?CASTF
0365 900000      E     MOV     DPTR,#?_Printf?BYTE+03H
0368 EE                MOV     A,R6
0369 F0                MOVX    @DPTR,A
036A A3                INC     DPTR
036B EF                MOV     A,R7
036C F0                MOVX    @DPTR,A
036D 22                RET     
             ; FUNCTION EncorderHandler (END)

             ; FUNCTION main_loop (BEGIN)
                                           ; SOURCE LINE # 1945
                                           ; SOURCE LINE # 1946
                                           ; SOURCE LINE # 1951
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_245
0004 7900        R     MOV     R1,#LOW ?SC_245
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 114 

0006 120000      E     LCALL   _Printf
0009         ?C0043:
                                           ; SOURCE LINE # 1956
                                           ; SOURCE LINE # 1966
0009 120000      E     LCALL   DvrReceivePaser
                                           ; SOURCE LINE # 2002
000C 120000      E     LCALL   SysJudgeHandler
                                           ; SOURCE LINE # 2003
000F 120000      E     LCALL   SysTimerHandler
                                           ; SOURCE LINE # 2005
0012 120000      E     LCALL   SysPowerHandler
                                           ; SOURCE LINE # 2338
0015 120000      E     LCALL   Scankey
                                           ; SOURCE LINE # 2339
0018 120000      R     LCALL   EncorderHandler
                                           ; SOURCE LINE # 2440
001B 80EC              SJMP    ?C0043
             ; FUNCTION main_loop (END)

             ; FUNCTION main (BEGIN)
                                           ; SOURCE LINE # 2444
                                           ; SOURCE LINE # 2445
                                           ; SOURCE LINE # 2472
0000 120000      E     LCALL   InitCPU
                                           ; SOURCE LINE # 2474
0003 D283              SETB    P0_3
                                           ; SOURCE LINE # 2475
0005 D284              SETB    P0_4
                                           ; SOURCE LINE # 2476
0007 C2A1              CLR     P2_1
                                           ; SOURCE LINE # 2477
0009 D284              SETB    P0_4
                                           ; SOURCE LINE # 2478
000B C2A1              CLR     P2_1
                                           ; SOURCE LINE # 2479
000D C2B7              CLR     P3_7
                                           ; SOURCE LINE # 2480
000F C286              CLR     P0_6
                                           ; SOURCE LINE # 2481
0011 C2EA              CLR     P4_2
                                           ; SOURCE LINE # 2482
0013 C2A6              CLR     P2_6
                                           ; SOURCE LINE # 2483
0015 C2A2              CLR     P2_2
                                           ; SOURCE LINE # 2484
0017 D2B6              SETB    P3_6
                                           ; SOURCE LINE # 2485
0019 D2A0              SETB    P2_0
                                           ; SOURCE LINE # 2486
001B D2E8              SETB    P4_0
                                           ; SOURCE LINE # 2487
001D D2E9              SETB    P4_1
                                           ; SOURCE LINE # 2488
001F D2A0              SETB    P2_0
                                           ; SOURCE LINE # 2490
0021 7FC8              MOV     R7,#0C8H
0023 7E00              MOV     R6,#00H
0025 120000      E     LCALL   _MCUTimerDelayXms
                                           ; SOURCE LINE # 2492
0028 C283              CLR     P0_3
                                           ; SOURCE LINE # 2493
002A C284              CLR     P0_4
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 115 

                                           ; SOURCE LINE # 2494
002C D2A1              SETB    P2_1
                                           ; SOURCE LINE # 2495
002E C284              CLR     P0_4
                                           ; SOURCE LINE # 2496
0030 D2A1              SETB    P2_1
                                           ; SOURCE LINE # 2497
0032 D2B7              SETB    P3_7
                                           ; SOURCE LINE # 2498
0034 D286              SETB    P0_6
                                           ; SOURCE LINE # 2499
0036 D2EA              SETB    P4_2
                                           ; SOURCE LINE # 2500
0038 D2A6              SETB    P2_6
                                           ; SOURCE LINE # 2501
003A D2A2              SETB    P2_2
                                           ; SOURCE LINE # 2502
003C C2B6              CLR     P3_6
                                           ; SOURCE LINE # 2503
003E C2A0              CLR     P2_0
                                           ; SOURCE LINE # 2507
0040 7BFF              MOV     R3,#0FFH
0042 7A00        R     MOV     R2,#HIGH ?SC_266
0044 7900        R     MOV     R1,#LOW ?SC_266
0046 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 2509
0049 120000      E     LCALL   main_init
                                           ; SOURCE LINE # 2511
004C 120000      E     LCALL   InitVars
                                           ; SOURCE LINE # 2513
004F 120000      R     LCALL   LoadEEPROM
                                           ; SOURCE LINE # 2515
0052 120000      R     LCALL   InitialTimerEvent
0055         ?C0046:
                                           ; SOURCE LINE # 2672
                                           ; SOURCE LINE # 2673
0055 900000      R     MOV     DPTR,#PowerFlag
0058 E0                MOVX    A,@DPTR
0059 6003              JZ      ?C0048
                                           ; SOURCE LINE # 2674
005B 120000      R     LCALL   main_loop
005E         ?C0048:
                                           ; SOURCE LINE # 2682
005E 120000      R     LCALL   WaitPowerOn
                                           ; SOURCE LINE # 2683
0061 80F2              SJMP    ?C0046
             ; FUNCTION main (END)

             ; FUNCTION WaitPowerOn (BEGIN)
                                           ; SOURCE LINE # 2686
                                           ; SOURCE LINE # 2687
0000         ?C0050:
                                           ; SOURCE LINE # 2695
                                           ; SOURCE LINE # 2696
                                           ; SOURCE LINE # 2769
0000 80FE              SJMP    ?C0050
             ; FUNCTION WaitPowerOn (END)

C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 116 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_SCALER_TIMER_EVENT_DP_LINK_STATUS_IRQ  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_GO_TO_POWER_SAVING .  E_CONST  -----  U_CHAR   -----  1
POWER_SEL_SAVING . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
InitCPU. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_SCALER_TIMER_EVENT_AUDIO_LOAD_STABLE_  E_CONST  -----  U_CHAR   -----  1
EnumBatteryStatus. . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_START. . . . . . .  E_CONST  -----  U_CHAR   -----  1
_Mapping1. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  fromValue. . . . . . . . . . . . . .  AUTO     XDATA  INT      0000H  2
  fromRange. . . . . . . . . . . . . .  AUTO     XDATA  PTR      0002H  3
  toValue. . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0005H  3
  toRange. . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0008H  3
  a. . . . . . . . . . . . . . . . . .  AUTO     XDATA  INT      000BH  2
  b. . . . . . . . . . . . . . . . . .  AUTO     XDATA  INT      000DH  2
_mcuLib_ProtocolSendCmdWithParamNum. .  PUBLIC   CODE   PROC     0000H  -----
  ucType . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0007H  1
  pucParam . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0001H  3
  ucSize . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0004H  1
  ucChecksum . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
  pucBuf . . . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0005H  16
  iLen . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0015H  1
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0016H  1
EnumModeAction . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
DWORD. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
_POWER_ACTION_NORMAL_TO_NOSUPPORT_PS .  E_CONST  -----  U_CHAR   -----  1
P4 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
_SYSTEM_TIMER_EVENT_JUDGE_BTH_STATE. .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_CAPACITY_HIGH . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_DISABLE. . . . .  E_CONST  -----  U_CHAR   -----  1
SysTimerHandler. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_BATT_STATUS_STOP_CHARGE . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_RED_OFF. . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_SOURCE_CLEAR_DETEC  E_CONST  -----  U_CHAR   -----  1
BATERY_10. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_ABNORMAL_MODE . . . . . .  E_CONST  -----  U_CHAR   -----  1
EnumPowerAction. . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_SHOW_NO_CABLE. .  E_CONST  -----  U_CHAR   -----  1
PowerFlag. . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0000H  1
_MODE_STATUS_NOSIGNAL. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_STATUS_NOSUPPORT . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_RESET_TO_DISPLAY_SETTING.  E_CONST  -----  U_CHAR   -----  1
BATERY_50. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
POWER_SEL_OFF. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
BATERY_25. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
UserRange. . . . . . . . . . . . . . .  PUBLIC   XDATA  STRUCT   0001H  6
_BATT_STATUS_CAPACITY_LEVEL1 . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_NO_RESET_MODE . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_KEY_SCAN_READY . . .  E_CONST  -----  U_CHAR   -----  1
P2_0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
_BATT_STATUS_CAPACITY_LEVEL2 . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_GRN_RED_ON . . . .  E_CONST  -----  U_CHAR   -----  1
P2_1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
P0_3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0083H  1
_BATT_STATUS_CAPACITY_LEVEL3 . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_RESET_TO_FACTORY_MODE . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_NOSUPPORT_PS_TO_OFF. . .  E_CONST  -----  U_CHAR   -----  1
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 117 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


P4_0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E8H  1
P2_2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
P0_4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0084H  1
SysPowerHandler. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_BATT_STATUS_CAPACITY_LEVEL4 . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_GRN_OFF. . . . . .  E_CONST  -----  U_CHAR   -----  1
P4_1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E9H  1
BATERY_75. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P4_2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EAH  1
P0_6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0086H  1
EnumMCUTimerEventID. . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_MCUTimerDelayXms. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_BATT_STATUS_TEMP_NORMAL . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_NR_DETECTION_FINIS  E_CONST  -----  U_CHAR   -----  1
P2_6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A6H  1
_POWER_STATUS_AC_ON. . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P3_6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B6H  1
P3_7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B7H  1
_SetAD5110Step . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  newv . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  regv . . . . . . . . . . . . . . . .  AUTO     XDATA  INT      0000H  2
_MCU_SendCmdToDVR. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ucType . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  buf. . . . . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0001H  3
TEMP_State . . . . . . . . . . . . . .  * TAG *  -----  ENUM     -----  -----
_SCALER_TIMER_EVENT_END. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_SHOW_BURN_IN . . . .  E_CONST  -----  U_CHAR   -----  1
StructBatteryInfoType. . . . . . . . .  TYPEDEF  -----  STRUCT   -----  4
  b5BatteryStatus. . . . . . . . . . .  MEMBER   -----  FIELD    0000H  5.0
  b1NoBattery. . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.5
  b1AC_PLUG. . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.6
  b3BTHStatus. . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  3.0
  b1BatteryCapacityLow . . . . . . . .  MEMBER   -----  FIELD    0001H  1.3
  b1BatteryAbnormal. . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.4
  b2BatteryChargeStatus. . . . . . . .  MEMBER   -----  FIELD    0001H  2.5
  BatteryCapacity. . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
_USER_TIMER_EVENT_OSD_ENCODER_DEVIATIO  E_CONST  -----  U_CHAR   -----  1
g_stBatteryInfo. . . . . . . . . . . .  PUBLIC   XDATA  STRUCT   0007H  4
_SYSTEM_TIMER_EVENT_RED_BLINK. . . . .  E_CONST  -----  U_CHAR   -----  1
ADCV . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C6H  1
_SCALER_TIMER_EVENT_DP_HOTPLUG_ASSERTED E_CONST  -----  U_CHAR   -----  1
_POWER_STATUS_NOSUPPORT_SAVING . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_JUDGE_PSW_STATE. .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_END. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_NONE . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_AC_ON_TO_NORMAL. . . . .  E_CONST  -----  U_CHAR   -----  1
EncorderLen_Offset . . . . . . . . . .  PUBLIC   XDATA  U_INT    000BH  2
_MODE_ACTION_RESET_TO_DISPLAY_SETTING_  E_CONST  -----  U_CHAR   -----  1
StructTimerEventTableType. . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  b1EventValid . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.0
  b7EventID. . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  7.1
  usTime . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0001H  2
EncorderLenint . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   000DH  1
main . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_USER_TIMER_EVENT_PANEL_BACKLIGHT_ON .  E_CONST  -----  U_CHAR   -----  1
EnumModeStatus . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_CHECK. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 118 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


BRIGHTNESS_NORMAL. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_RESET_TO_SEARCH . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_GRN_BLINK. . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_RESET_TO_POWER_SAVING . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_DVR_REBOOT . . .  E_CONST  -----  U_CHAR   -----  1
BATERY_State . . . . . . . . . . . . .  * TAG *  -----  ENUM     -----  -----
BATERY_AC. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_MHL_D0_READY_TO_TR  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_MHL_D1_READY_TO_TR  E_CONST  -----  U_CHAR   -----  1
EnumPowerStatus. . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
TEMP_OK. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_PANEL_USED_TIMER . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_AC_ON_TO_OFF . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_JUDGE_WDT_ECHO . .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_LOW_CHARGE. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
InitVars . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_SYSTEM_TIMER_EVENT_JUDGE_POWER_STATE.  E_CONST  -----  U_CHAR   -----  1
BYTE . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
TEMP_Alarm1. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_NONE. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TEMP_Alarm2. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_TMDS_HDMI_PACKET_D  E_CONST  -----  U_CHAR   -----  1
EnumSystemTimerEventID . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_LED_POWER_SAVING . .  E_CONST  -----  U_CHAR   -----  1
BATERY_100 . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_STATUS_INITIAL . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_RESET_TO_POWER_OFF. . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_MHL_D0_ACTIVE_VBUS  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_JUDGE_DVR_COMM . .  E_CONST  -----  U_CHAR   -----  1
WORD . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
AD5110Range. . . . . . . . . . . . . .  PUBLIC   XDATA  STRUCT   000EH  6
main_init. . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_SCALER_TIMER_EVENT_MHL_D1_ACTIVE_VBUS  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_TEMP_LOW. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_AC_MODE . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_PHASE_CNT_CHECK. .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_HLWIN_TYPE5_MOVE . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_GET_MCU_VERSION.  E_CONST  -----  U_CHAR   -----  1
_?ix1000 . . . . . . . . . . . . . . .  STATIC   CODE   ARRAY    011AH  3
BRIGHTNESS_MIN . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
main_loop. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
EncorderCount. . . . . . . . . . . . .  EXTERN   XDATA  INT      -----  2
_POWER_ACTION_NORMAL_TO_PS . . . . . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_PS_TO_NORMAL . . . . . .  E_CONST  -----  U_CHAR   -----  1
BRIGHTNESS_MAX . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
MCUTimerInitialTimerEvent. . . . . . .  EXTERN   CODE   PROC     -----  -----
StructModeInfoType . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  b5ModeState. . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  5.0
  b1DisplaySettingReady. . . . . . . .  MEMBER   -----  FIELD    0000H  1.5
  b1TimingConfirm. . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.6
  b1ModeStateChanged . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.7
  b4ModeResetFlag. . . . . . . . . . .  MEMBER   -----  FIELD    0001H  4.0
  b1NoWaitForActive. . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.4
  b1ActiveReady. . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.5
_USER_TIMER_EVENT_OSD_DISTANCE_RESET .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_PHASE_CALIBRATION.  E_CONST  -----  U_CHAR   -----  1
_POWER_STATUS_NONE . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 119 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_SYSTEM_TIMER_EVENT_END. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_STATUS_FACTORY . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_STATUS_DISPLAY_SETTING . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_RED_ON . . . . . .  E_CONST  -----  U_CHAR   -----  1
Register . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
LoadEEPROM . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_SYSTEM_TIMER_EVENT_JUDGE_AC_MODE. . .  E_CONST  -----  U_CHAR   -----  1
StructPowerInfoType. . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  b4PowerAction. . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  4.0
  b4PowerStatus. . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  4.4
  b1GDIIsolationFlag . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.0
  b1TopIsolationFlag . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.1
  b1AnalogIsolationFlag. . . . . . . .  MEMBER   -----  FIELD    0001H  1.2
_USER_TIMER_EVENT_OSD_MCU_ENTRY_SLEEP_  E_CONST  -----  U_CHAR   -----  1
EncorderCountPN_offset . . . . . . . .  PUBLIC   XDATA  U_CHAR   0014H  1
_MODE_ACTION_RESET_TO_NOSIGNAL . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_RESET_TO_NOSUPPORT. . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_COUNT. . . . . . .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_START_CHARGE. . . . . . .  E_CONST  -----  U_CHAR   -----  1
POWER_SEL_ON . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
Scankey. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_SYSTEM_TIMER_EVENT_JUDGE_BATT_STATE .  E_CONST  -----  U_CHAR   -----  1
EnumUserTimerEventID . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
EncorderLenfloaat. . . . . . . . . . .  PUBLIC   XDATA  U_INT    0015H  2
_POWER_ACTION_PS_TO_OFF. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_COUNT. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_START. . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MCUTimerActiveTimerEvent. . . . . . .  EXTERN   CODE   PROC     -----  -----
_SYSTEM_TIMER_EVENT_GRN_ON . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_JUDGE_TW8836_COMM.  E_CONST  -----  U_CHAR   -----  1
EncorderLen. . . . . . . . . . . . . .  PUBLIC   XDATA  FLOAT    0017H  4
_SCALER_TIMER_EVENT_DP_HDCP_LONG_HOTPL  E_CONST  -----  U_CHAR   -----  1
GetBatteryVoltage. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  adc. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0000H  2
InitialTimerEvent. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_ReadEEP . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
RegisterInfo . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  6
  Min. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  Max. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0002H  2
  Default. . . . . . . . . . . . . . .  MEMBER   -----  INT      0004H  2
_BATT_STATUS_CAPACITY_LOW. . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_DO_AUTO_COLOR. . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_START. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_NOSUPPORT_PS_TO_PS . . .  E_CONST  -----  U_CHAR   -----  1
_WriteAD5110 . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_BATT_STATUS_NO_BATT . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_MHL_D0_RECONNECT_1K E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_DVR_SHUTDOWN . .  E_CONST  -----  U_CHAR   -----  1
_MODE_STATUS_NONE. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_MHL_D1_RECONNECT_1K E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_CAMERA_VOLTAGE_DECE_CONST  -----  U_CHAR   -----  1
GetBatteryBTH. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  adc. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0000H  2
BRIGHTNESS_STATE . . . . . . . . . . .  * TAG *  -----  ENUM     -----  -----
_POWER_STATUS_SAVING . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_KEY_REPEAT_ENABLE. .  E_CONST  -----  U_CHAR   -----  1
_POWER_STATUS_NORMAL . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 120 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


EncorderCountPN. . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   001BH  1
DebugLevel . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   001CH  1
_BATT_STATUS_NONE. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_GRN_ON_RED_BLINK .  E_CONST  -----  U_CHAR   -----  1
WaitPowerOn. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_MODE_STATUS_SEARCH. . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_POWER_STATUS_SAVING_BATTERY_MODE. . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_GRN_RED_BLINK. . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_PANEL_POWER_OFF. . .  E_CONST  -----  U_CHAR   -----  1
Encorder1. . . . . . . . . . . . . . .  PUBLIC   XDATA  FLOAT    001DH  4
_POWER_STATUS_NORMAL_BATTERY_MODE. . .  E_CONST  -----  U_CHAR   -----  1
_MODE_STATUS_POWER_SAVING. . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_STANDBY_MODE . . . .  E_CONST  -----  U_CHAR   -----  1
Encorder2. . . . . . . . . . . . . . .  PUBLIC   XDATA  FLOAT    0021H  4
ADCTL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C5H  1
Encorder3. . . . . . . . . . . . . . .  PUBLIC   XDATA  FLOAT    0025H  4
_GetADCValue . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  sel. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
Encorder4. . . . . . . . . . . . . . .  PUBLIC   XDATA  FLOAT    0029H  4
_USER_TIMER_EVENT_FACTORY_MODE . . . .  E_CONST  -----  U_CHAR   -----  1
ADCVL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
LongRegisterInfo . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  6
  Min. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  Max. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
  Default. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0004H  2
_MODE_STATUS_ACTIVE. . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_TEMP_HIGH . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_DCC_HISTOGRAM_THD_  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_CAMERA_VOLTAGE_INCE_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_SHOW_POWER_SAVING E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_FAST_CHARGE . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_DISPLAY_INFO . . . .  E_CONST  -----  U_CHAR   -----  1
_POWER_STATUS_NORMAL_NO_MATTERY_MODE .  E_CONST  -----  U_CHAR   -----  1
POWER_STATE. . . . . . . . . . . . . .  * TAG *  -----  ENUM     -----  -----
_RS_tx . . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_POWER_STATUS_OFF. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_SHOW_NO_SIGNAL .  E_CONST  -----  U_CHAR   -----  1
ChangeKey. . . . . . . . . . . . . . .  EXTERN   DATA   BIT      -----  1
CameraVolt . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   002DH  1
DvrReceivePaser. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_mcuLib_ProtocolAppend . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  pucBuf . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
  piLen. . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0003H  3
  ucByte . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0006H  1
_SCALER_TIMER_EVENT_TMDS_VIDEO_DETECT.  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_LIGHT_SENSER_ON. . .  E_CONST  -----  U_CHAR   -----  1
_Printf. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
SysJudgeHandler. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_SCALER_TIMER_EVENT_D0_PORT_DIGITAL_SW  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_BURN_IN_ON . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_D1_PORT_DIGITAL_SW  E_CONST  -----  U_CHAR   -----  1
_MODE_STATUS_POWER_OFF . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
EncorderHandler. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  EncorderCountTemp. . . . . . . . . .  AUTO     XDATA  U_INT    0000H  2
  temp_val . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0002H  2
  temp_EncorderCountTemp . . . . . . .  AUTO     XDATA  U_INT    0004H  2
  param. . . . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0006H  4
C51 COMPILER V9.60.0.0   MAIN                                                              03/02/2020 12:07:33 PAGE 121 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  EncorderParaTemp1. . . . . . . . . .  AUTO     XDATA  FLOAT    000AH  4
  EncorderParaTemp2. . . . . . . . . .  AUTO     XDATA  FLOAT    000EH  4
  EncorderParaTemp3. . . . . . . . . .  AUTO     XDATA  FLOAT    0012H  4
  EncorderParaTemp4. . . . . . . . . .  AUTO     XDATA  FLOAT    0016H  4
  EncorderOffset1. . . . . . . . . . .  AUTO     XDATA  FLOAT    001AH  4
  EncorderOffset2. . . . . . . . . . .  AUTO     XDATA  FLOAT    001EH  4
  EncorderOffset3. . . . . . . . . . .  AUTO     XDATA  FLOAT    0022H  4
_SCALER_TIMER_EVENT_MHL_D0_READY_TO_RE  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_COUNT. . . . . . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_NORMAL_TO_OFF. . . . . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_OFF_TO_NORMAL. . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_MHL_D1_READY_TO_RE  E_CONST  -----  U_CHAR   -----  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2058    ----
   CONSTANT SIZE    =    285    ----
   XDATA SIZE       =     46      93
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
