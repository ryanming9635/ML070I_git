C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE CPU
OBJECT MODULE PLACED IN .\Output\cpu.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE cpu.c LARGE OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Include\) DEBUG OBJECTEXTEN
                    -D CODE LISTINCLUDE SYMBOLS PRINT(.\Source\cpu.lst) TABS(2) OBJECT(.\Output\cpu.obj)

line level    source

   1          /*****************************************************************************/
   2          /*                                                                                              */
   3          /*  TELI ML070I   MCU                                             */
   4          /*                                                                                              */
   5          /*****************************************************************************/
   6          
   7          /* CPU.c */
   8          
   9          #include "config.h"
   1      =1  /*****************************************************************************/
   2      =1  /*                                                                                              */
   3      =1  /*  TELI ML070I   MCU                                             */
   4      =1  /*                                                                                              */
   5      =1  /*****************************************************************************/
   6      =1  
   7      =1  #ifndef __CONFIG_H__
   8      =1  #define __CONFIG_H__
   9      =1  
  10      =1  //#define INTERNAL_MCU -- defined by Project Compiler session
  11      =1  //#define   HS      
  12      =1  //#define   E_Wintek  
  13      =1  //#define   AWT 
  14      =1  //#define Holtz
  15      =1  
  16      =1  
  17      =1  
  18      =1  //#define QUAD
  19      =1  /*
  20      =1  #ifdef QUAD
  21      =1    #define AWT_ML072Q
  22      =1  #else
  23      =1    #define AWT_ML072S
  24      =1  #endif
  25      =1  */
  26      =1  //#define SUPPORT_SVIDEO                     //andy Awt 20090914
  27      =1  //#define SUPPORT_COMPONENT     // support component analog to decoder//andy Awt 20090914
  28      =1  
  29      =1  //#define SUPPORT_DTV           // support DTV input through component( to ADC ).//andy Awt 20090914
  30      =1  //#define SUPPORT_PC          // support PC function
  31      =1  //#define SUPPORT_DVI       // support DVI input
  32      =1  //#define SUPPORT_SDCARD
  33      =1  
  34      =1  //#define SUPPORT_RS485
  35      =1  //-----------------------------------------------------------------------------
  36      =1  //    Firmware Version
  37      =1  //-----------------------------------------------------------------------------
  38      =1  #define FWVER     0x0001      // Rev 0001
  39      =1  
  40      =1  #define MCU_FW_Major      0x00      
  41      =1  #define MCU_FW_Sub0     0x00      
  42      =1  #define MCU_FW_Sub1     0x01      
  43      =1  //-----------------------------------------------------------------------------
  44      =1  //    Compiler
  45      =1  //-----------------------------------------------------------------------------
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 2   

  46      =1  #define KEILC           // Keil C 5.0
  47      =1  //-----------------------------------------------------------------------------
  48      =1  //    MPU Clock
  49      =1  //-----------------------------------------------------------------------------
  50      =1  #ifndef INTERNAL_MCU
  51      =1  //#define CLOCK_11M         // 11.0592MHz
  52      =1  #define CLOCK_22M         // 22.1184MHz
  53      =1  #else                 // INTERNAL_MCU
           =1 #define CLOCK_27M         // 27MHz
           =1 #define REG_START_ADDRESS 0xc000    // register start 0xc000, for page0, 0xc100-page1 
           =1 #endif
  57      =1  //-----------------------------------------------------------------------------
  58      =1  //    TW88 Version
  59      =1  //-----------------------------------------------------------------------------
  60      =1  #define TW8816
  61      =1  //-----------------------------------------------------------------------------
  62      =1  //    Options for Backlight control
  63      =1  //-----------------------------------------------------------------------------
  64      =1  //#define BACKLIGHT_CCFL
  65      =1  //#define BACKLIGHT_LED
  66      =1  #define BACKLIGHT_PWM
  67      =1  
  68      =1  //-----------------------------------------------------------------------------
  69      =1  //    Panel Resolution
  70      =1  //-----------------------------------------------------------------------------
  71      =1  // ---- Select Default Panel
  72      =1  //
  73      =1  //#define UXGA            // 1600 x 1200
  74      =1  //#define SXGA              // 1280 x 1024
  75      =1  //#define XGA  // 1024 x 768
  76      =1  /*
  77      =1  #ifdef XGA
  78      =1    #define LVDS          
  79      =1    #define PWIDTH  1024
  80      =1    #define PHEIGHT 768
  81      =1  #endif
  82      =1  //#define SVGA            //  800 x 600
  83      =1  #define VGA             //  640 x 480
  84      =1  #ifdef VGA
  85      =1    #define PWIDTH  640
  86      =1    #define PHEIGHT 480
  87      =1    //#define HITACHI_640_B_160   //--> 640 x 160
  88      =1    #define AND_640_480
  89      =1  #endif
  90      =1  //#define WXGA            // 1280 x 768 (15:9) // 1366 x 768 (16:9)
  91      =1  #ifdef WXGA
  92      =1      //#define WX_SHARP_LQ106K1LA
  93      =1    #define PWIDTH  1280
  94      =1    #define PHEIGHT 768
  95      =1  #endif
  96      =1  //#define WSVGA           // 1024 x 600 *** only video mode
  97      =1  #ifdef WSVGA
  98      =1    #define PWIDTH  1024
  99      =1    #define PHEIGHT 600
 100      =1    #define UNIDEN_1024_600
 101      =1  #endif
 102      =1  */
 103      =1  //#define WVGA            //  800 x 480
 104      =1  //#ifdef WVGA
 105      =1    //#define PWIDTH  800
 106      =1    //#define PHEIGHT 480//600
 107      =1    // If WVGA, you have to select panel.
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 3   

 108      =1    //#define AU_10INCH
 109      =1    //#define WVGA_TPO
 110      =1    //#define SAMSUNG_10INCH
 111      =1    //#define SAMSUNG_TICONLESS_10INCH
 112      =1    //#define SHARP_TICONLESS_7INCH
 113      =1    //#define AU_TICONLESS_7INCH
 114      =1    //#define AU_G084SN05V8_8_4INCH 
 115      =1  //  #define HSD070IDW1_7INCH
 116      =1    //#define INNOLUX_AT080TN03
 117      =1    //#define AU_TICONLESS_7INCH_CCFL
 118      =1    //#define CMO     // CHIMEI panel
 119      =1    //#define AU_TICONLESS_10INCH
 120      =1    //#define HITACHI_T01
 121      =1    //#define HITACHI_TX23D12
 122      =1    //#define HITACHI_TX18D24
 123      =1    //#define HITACHI_TX18D16
 124      =1    //#define TMD_LTA070A320F
 125      =1    //#define TMD_LTA080B
 126      =1  //#endif  //WVGA
 127      =1  //#define HVGA            //  480 x 320
 128      =1  //#define QVGA            //  320 x 240 *** only video mode
 129      =1  /*
 130      =1  #ifdef QVGA
 131      =1    #define PWIDTH  320
 132      =1    #define PHEIGHT 240
 133      =1    //#define HITACHI_TX09D73
 134      =1    //#define AU_DELTARGB
 135      =1    //#define SHARP_LQ050Q5DR01
 136      =1    //#define SHARP_LQ035
 137      =1    //#define TMD
 138      =1  #endif
 139      =1  
 140      =1  //#define WQVGA           //  480 x 234 *** only video mode
 141      =1  #ifdef WQVGA
 142      =1    #define PWIDTH  480
 143      =1    #define PHEIGHT 240
 144      =1    // If WQVGA, you have to select panel 
 145      =1      #define ANALOG_7INCH
 146      =1    //#define PWIDTH  400
 147      =1    //#define PHEIGHT 240
 148      =1    //#define SHARP_LQ043T3DX02   //  400 x 237
 149      =1    //#define LG_ANALOG
 150      =1    //#define TMD_ANALOG        //TMD_LTA05B352A
 151      =1    //#define T_51945GD       // Optorex Panel
 152      =1  #endif  // WQVGA
 153      =1  */
 154      =1  //if LVDS pannel disable TICONLESS
 155      =1  
 156      =1  //-----------------------------------------------------------------------------
 157      =1  //---- Add Support One more panel with DIPSW#1
 158      =1  //---- Ex. Add Analog AU 7" Panel with Default Panel for evalution
 159      =1  //#define ADD_ANALOGPANEL   // Added Analog panel(AU7") from default set panel(expect WQVGA) with DIP #1 sw
             -itch.(DIP#1=L:ANALOG, H:DEFAULT)
 160      =1                // It can't support WQVGA and ADD_ANALOGPANEL same time!!
 161      =1    //#define ADD_ANALOG_7INCH
 162      =1    //#define ADD_TMD_LTA05B352A
 163      =1                    
 164      =1  //---- Support Wide panel function
 165      =1  /*
 166      =1  #if (defined WXGA) || (defined WSVGA) || (defined WVGA) || (defined WQVGA)
 167      =1  #define WIDE_SCREEN         // Can support 4 display mode, i.e. Normal, Wide, Full, Zoom
 168      =1  #endif                // Tested panasonic WVGA panel.
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 4   

 169      =1  */
 170      =1  //-----------------------------------------------------------------------------
 171      =1  //    Panel Vendor Specific
 172      =1  //-----------------------------------------------------------------------------
 173      =1  /*
 174      =1  //-----------------------------------------------------------------------------
 175      =1  //    TV Tuner
 176      =1  //-----------------------------------------------------------------------------
 177      =1  #define PHILIPS       0
 178      =1  #define ALPS        1   // ALPS, LG
 179      =1  #define TEMIC       2
 180      =1  #define TVAVA       3
 181      =1  #define LGTUNER       4
 182      =1  #define SAMSUNGMUTITUNER  5
 183      =1  
 184      =1  #define TVTunerDevice   4
 185      =1  //-----------------------------------------------------------------------------
 186      =1  //    IR Remote Controller Type
 187      =1  //-----------------------------------------------------------------------------
 188      =1  //#define REMO_RC5          // RC5 style
 189      =1  #define TECHWELL_REMOCON
 190      =1  //#define REMO_NEC          // NEC style
 191      =1  //#define PHILIPS_REMOCON // New remocon 
 192      =1  */
 193      =1  
 194      =1  //-----------------------------------------------------------------------------
 195      =1  //    I2C Device Access Address Mapping
 196      =1  //-----------------------------------------------------------------------------
 197      =1  #define EEPROMI2CAddress  0xa0  // EEPROM (24C16)
 198      =1  #define TW88I2CAddress    0x8a  // TW880x
 199      =1  
 200      =1  /*
 201      =1  #define MSPI2CAddress   0x80  // MSP
 202      =1  #define ALC106I2CAddress    0x4A  // MSP
 203      =1  */
 204      =1  #define  AD5110I2CAddress    0x5E//0x58
 205      =1  
 206      =1  //-----------------------------------------------------------------------------
 207      =1  //    AD5110 Command Operation Truth table
 208      =1  //-----------------------------------------------------------------------------
 209      =1  
 210      =1  #define AD5110_CMD_No_Operation           0
 211      =1  #define AD5110_CMD_Write_RDAC_To_EEPROM       1
 212      =1  #define AD5110_CMD_Write_Data_To_RDAC       2
 213      =1  #define AD5110_CMD_Shutdown             3
 214      =1  #define AD5110_CMD_Soft_Refresh_RDAC    4
 215      =1  #define AD5110_CMD_Read_RDAC        5
 216      =1  #define AD5110_CMD_Read_EEPROM              6
 217      =1  
 218      =1  
 219      =1  
 220      =1  //-----------------------------------------------------------------------------
 221      =1  //    Options for Possible Inputs
 222      =1  //-----------------------------------------------------------------------------
 223      =1  
 224      =1  
 225      =1  
 226      =1  
 227      =1  
 228      =1  //-----------------------------------------------------------------------------
 229      =1  //    Options for Possible Standards
 230      =1  //    Default:NTSC
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 5   

 231      =1  //-----------------------------------------------------------------------------
 232      =1  /*
 233      =1  #define SUPPORT_PAL     
 234      =1  #define SUPPORT_SECAM
 235      =1  #define SUPPORT_NTSC4   
 236      =1  #define SUPPORT_PALM  
 237      =1  #define SUPPORT_PALN    
 238      =1  #define SUPPORT_PAL60   
 239      =1  */
 240      =1  
 241      =1  //#define ID_CHECK_BY_FW        // in Video mode, check input system ID by firmware
 242      =1  
 243      =1  //-----------------------------------------------------------------------------
 244      =1  //    Options for Debugging/Release
 245      =1  //-----------------------------------------------------------------------------
 246      =1  //#define SUPPORT_PATTERN       // support LCD test pattern
 247      =1  
 248      =1  /*
 249      =1  #ifndef WQVGA
 250      =1    #ifndef QVGA
 251      =1    #define SUPPORT_OSDPOSITIONMOVE
 252      =1    #endif
 253      =1  #endif
 254      =1  */
 255      =1  #define SERIAL              // include serial communication routines
 256      =1  //#define USE_HI3521_UART2
 257      =1  
 258      =1  //#define SUPPORT_DEBUG       // Support to use Read & Write in debug OSD Window by remocon.
 259      =1  
 260      =1  //#define DEBUG           // include debug information
 261      =1  #if 0///def DEBUG
           =1   //#define DEBUG_MAIN
           =1   //#define DEBUG_TIME
           =1   //#define DEBUG_KEYREMO
           =1   //#define DEBUG_TW88
           =1   //#define DEBUG_DECODER
           =1   //#define DEBUG_I2C
           =1   //#define DEBUG_EEP
           =1   //#define DEBUG_OSD
           =1   //#define DEBUG_AUDIO
           =1   //#define DEBUG_SETPANEL
           =1   //#define DEBUG_DTV
           =1   #define DEBUG_PC
           =1   //#define DEBUG_PC_MEAS
           =1   #define DEBUG_PC_COLOR
           =1   //#define DEBUG_COMPONENT
           =1   //#define DEBUG_BANK
           =1   //#define DEBUG_PAUSE
           =1   //#define DEBUG_MCU
           =1 #endif
 281      =1  
 282      =1  //#define AUTOCALC_PC         // in PC mode, Enable Auto Calcuration
 283      =1  //#define SUPPORT_USERCOLORFROMTXT  // Use color setting of text file in Color mode=USER MODE which is as B
             -rightness(Reg10), Contast(Reg11),
 284      =1                    //    Sat_U(Reg13),Sat_V(Reg14),Sharpness(Reg12,Reg78)                  
 285      =1  //#define SUPPORT_GAMMA
 286      =1  
 287      =1  //#define CHIP_MANUAL_TEST      // DIPSW#1
 288      =1  
 289      =1  //#ifndef INTERNAL_MCU
 290      =1  //#define NO_INITIALIZE       // After Power switch turn on with DIP SW4 Enable(Low), or pressed MENU button 
             -for internal MCU
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 6   

 291      =1                                      //     micom works to access only I2C bus by serial command.
 292      =1  //#endif
 293      =1  
 294      =1  //#define SUPPORT_KRS_OSDDEMO   // For KRS Company Demo 
 295      =1  //#define SUPPORT_LINE_OSDDEMO
 296      =1  
 297      =1  //-----------------------------------------------------------------------------
 298      =1  //    Special Features
 299      =1  //-----------------------------------------------------------------------------
 300      =1  
 301      =1  //#ifndef INTERNAL_MCU
 302      =1  //#define SUPPORT_DELTA_RGB
 303      =1  //#endif
 304      =1  //#define SUPPORT_SELECTKEY     // choose the keymap of using select key or left,right key.
 305      =1  //-----------------------------------------------------------------------------
 306      =1  
 307      =1  //#define HS_NEWOSDMENU     //Weylis -@121008 for Hor. Style OSD
 308      =1  //#define HS_NEWOSDMENU_2     //Weylis -@121008 for Hor. Style OSD(2 line)
 309      =1  #endif  //__CONFIG_H__
  10          #include "typedefs.h"
   1      =1  #ifndef __TYPEDEFS__
   2      =1  #define __TYPEDEFS__
   3      =1  
   4      =1  
   5      =1  #define DATA    data
   6      =1  #define PDATA   pdata
   7      =1  #define IDATA   data
   8      =1  #define CODE    code
   9      =1  #define CODE_P
  10      =1  #define PDATA_P
  11      =1  #define IDATA_P
  12      =1  #define DATA_P
  13      =1  
  14      =1  #define INTERRUPT( num, name ) name() interrupt num
  15      =1  
  16      =1  #define _between(x, a, b) (a<=x && x<=b)
  17      =1  #define _swap(a, b)     { a^=b; b^=a; a^=b; }
  18      =1  
  19      =1  #define SEC(x)                                  (1000 * (x))
  20      =1  
  21      =1  typedef unsigned char Register;
  22      =1  typedef unsigned char BYTE;
  23      =1  typedef unsigned short  WORD;
  24      =1  typedef unsigned long DWORD;
  25      =1  
  26      =1  #define TRUE  1
  27      =1  #define FALSE 0
  28      =1  #define _TRUE 1
  29      =1  #define _FALSE  0
  30      =1  
  31      =1  //VInputStdDetectMode
  32      =1  #define AUTO  0
  33      =1  
  34      =1  //VInputStd
  35      =1  #define NTSC  1     
  36      =1  #define PAL   2
  37      =1  #define SECAM 3
  38      =1  #define NTSC4 4
  39      =1  #define PALM  5
  40      =1  #define PALN  6
  41      =1  #define PAL60 7
  42      =1  
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 7   

  43      =1  #define MAXINPUTSTD PAL60+1 // 
  44      =1  
  45      =1  #define UNKNOWN 0xfe
  46      =1  #define NOINPUT 0 //0xff
  47      =1  
  48      =1  
  49      =1  
  50      =1  
  51      =1  #define NIL     0xff
  52      =1  //****************************************************************************
  53      =1  // DEFINITIONS / MACROS
  54      =1  //****************************************************************************
  55      =1  
  56      =1  #define GET_MODE_STATE()                            (g_stModeInfo.b5ModeState)
  57      =1  #define SET_MODE_STATE(x)                         (g_stModeInfo.b5ModeState = x)
  58      =1  #define GET_MODE_STATE_CHANGE()                 (bit)(g_stModeInfo.b1ModeStateChanged)
  59      =1  #define SET_MODE_STATE_CHANGE()                 (g_stModeInfo.b1ModeStateChanged = _TRUE)
  60      =1  #define CLR_MODE_STATE_CHANGE()                 (g_stModeInfo.b1ModeStateChanged = _FALSE)
  61      =1  #define GET_MODE_RESET_TARGET()                   (g_stModeInfo.b4ModeResetFlag)
  62      =1  #define SET_MODE_RESET_TARGET(x)                (g_stModeInfo.b4ModeResetFlag = x)
  63      =1  #define GET_TARGET_POWER_STATUS()           (g_stPowerInfo.b4PowerAction)
  64      =1  #define SET_TARGET_POWER_STATUS(x)          (g_stPowerInfo.b4PowerAction = x)
  65      =1  
  66      =1  #define GET_BATTERY_STATE()       (g_stBatteryInfo.b5BatteryStatus)
  67      =1  #define SET_BATTERY_STATE(x)        (g_stBatteryInfo.b5BatteryStatus = x)
  68      =1  #define GET_NO_BATTERY()        (bit)(g_stBatteryInfo.b1NoBattery)
  69      =1  #define SET_NO_BATTERY()        (g_stBatteryInfo.b1NoBattery =_TRUE)
  70      =1  #define CLR_NO_BATTERY()        (g_stBatteryInfo.b1NoBattery = _FALSE)
  71      =1  
  72      =1  #define GET_AC_PLUG()       (bit)(g_stBatteryInfo.b1AC_PLUG)
  73      =1  #define SET_AC_PLUG()       (g_stBatteryInfo.b1AC_PLUG =_TRUE)
  74      =1  #define CLR_AC_PLUG()       (g_stBatteryInfo.b1AC_PLUG = _FALSE)
  75      =1        
  76      =1  
  77      =1  #define GET_BTH_STATE()         (g_stBatteryInfo.b3BTHStatus)
  78      =1  #define SET_BTH_STATE(x)          (g_stBatteryInfo.b3BTHStatus = x)
  79      =1  
  80      =1  #define GET_BATTERY_CAPACITY()        (g_stBatteryInfo.BatteryCapacity)
  81      =1  #define SET_BATTERY_CAPACITY(x)     (g_stBatteryInfo.BatteryCapacity = x)
  82      =1  #define GET_BATTERY_CAPACITY_FLAG()       (bit)(g_stBatteryInfo.b1BatteryCapacityLow)
  83      =1  #define SET_BATTERY_CAPACITY_FLAG()       (g_stBatteryInfo.b1BatteryCapacityLow =_TRUE)
  84      =1  #define CLR_BATTERY_CAPACITY_FLAG()     (g_stBatteryInfo.b1BatteryCapacityLow =_FALSE)
  85      =1  
  86      =1  #define GET_BATTERY_ABNORMAL()        (bit)(g_stBatteryInfo.b1BatteryAbnormal)
  87      =1  #define SET_BATTERY_ABNORMAL()        (g_stBatteryInfo.b1BatteryAbnormal=_TRUE)
  88      =1  #define CLR_BATTERY_ABNORMAL()        (g_stBatteryInfo.b1BatteryAbnormal=_FALSE)
  89      =1  
  90      =1  #define GET_BATTERY_CHARGE_STATE()        (g_stBatteryInfo.b2BatteryChargeStatus)
  91      =1  #define SET_BATTERY_CHARGE_STATE(x)     (g_stBatteryInfo.b2BatteryChargeStatus = x)
  92      =1  
  93      =1  //--------------------------------------------------
  94      =1  // Power status
  95      =1  //--------------------------------------------------
  96      =1  #define GET_POWER_STATUS()                 (g_stPowerInfo.b4PowerStatus)
  97      =1  #define SET_POWER_STATUS(x)                (g_stPowerInfo.b4PowerStatus = x)
  98      =1  
  99      =1  //--------------------------------------------------
 100      =1  // Enumerations of Timer Events
 101      =1  //--------------------------------------------------
 102      =1  
 103      =1  typedef struct
 104      =1  {
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 8   

 105      =1      BYTE b1EventValid : 1;
 106      =1      BYTE b7EventID : 7;
 107      =1      WORD usTime;
 108      =1  } StructTimerEventTableType;
 109      =1  
 110      =1  typedef enum
 111      =1  {
 112      =1      _USER_TIMER_EVENT_START,
 113      =1      _USER_TIMER_EVENT_KEY_REPEAT_ENABLE = _USER_TIMER_EVENT_START,   
 114      =1      _USER_TIMER_EVENT_KEY_SCAN_READY,
 115      =1      _USER_TIMER_EVENT_OSD_CAMERA_VOLTAGE_INC,
 116      =1      _USER_TIMER_EVENT_OSD_CAMERA_VOLTAGE_DEC,
 117      =1      _USER_TIMER_EVENT_OSD_GET_MCU_VERSION,
 118      =1      _USER_TIMER_EVENT_OSD_MCU_ENTRY_SLEEP_MODE,
 119      =1      _USER_TIMER_EVENT_OSD_DISTANCE_RESET,
 120      =1      _USER_TIMER_EVENT_OSD_DVR_REBOOT,
 121      =1      _USER_TIMER_EVENT_OSD_DVR_SHUTDOWN,
 122      =1      _USER_TIMER_EVENT_OSD_ENCODER_DEVIATION_SETTING,
 123      =1      //
 124      =1       _USER_TIMER_EVENT_OSD_SHOW_NO_CABLE,
 125      =1      _USER_TIMER_EVENT_OSD_SHOW_NO_SIGNAL,
 126      =1      _USER_TIMER_EVENT_OSD_SHOW_POWER_SAVING,
 127      =1      _USER_TIMER_EVENT_GO_TO_POWER_SAVING,
 128      =1      _USER_TIMER_EVENT_OSD_DISABLE,
 129      =1      _USER_TIMER_EVENT_PANEL_BACKLIGHT_ON,
 130      =1      _USER_TIMER_EVENT_PANEL_POWER_OFF,
 131      =1      _USER_TIMER_EVENT_DO_AUTO_COLOR,
 132      =1      _USER_TIMER_EVENT_PANEL_USED_TIMER,
 133      =1      _USER_TIMER_EVENT_HLWIN_TYPE5_MOVE,    
 134      =1    _USER_TIMER_EVENT_LED_POWER_SAVING,
 135      =1    _USER_TIMER_EVENT_LIGHT_SENSER_ON,
 136      =1    _USER_TIMER_EVENT_SHOW_BURN_IN,//ryan@20151230
 137      =1    _USER_TIMER_EVENT_BURN_IN_ON,//ryan@20151230
 138      =1    _USER_TIMER_EVENT_CHECK,//ryan@20151231
 139      =1    _USER_TIMER_EVENT_DISPLAY_INFO,//ryan@20151231
 140      =1    _USER_TIMER_EVENT_STANDBY_MODE,
 141      =1    _USER_TIMER_EVENT_FACTORY_MODE,//ryan@20160113
 142      =1      _USER_TIMER_EVENT_END,
 143      =1      _USER_TIMER_EVENT_COUNT = _USER_TIMER_EVENT_END,
 144      =1  } EnumUserTimerEventID;
 145      =1  
 146      =1  typedef enum
 147      =1  {
 148      =1      _SYSTEM_TIMER_EVENT_START = _USER_TIMER_EVENT_COUNT,
 149      =1      _SYSTEM_TIMER_EVENT_SOURCE_CLEAR_DETECTING = _SYSTEM_TIMER_EVENT_START,
 150      =1      _SYSTEM_TIMER_EVENT_JUDGE_BATT_STATE,
 151      =1      _SYSTEM_TIMER_EVENT_JUDGE_POWER_STATE,
 152      =1      _SYSTEM_TIMER_EVENT_JUDGE_BTH_STATE,
 153      =1      _SYSTEM_TIMER_EVENT_JUDGE_PSW_STATE,    
 154      =1      _SYSTEM_TIMER_EVENT_JUDGE_AC_MODE,
 155      =1      _SYSTEM_TIMER_EVENT_JUDGE_DVR_COMM,
 156      =1      _SYSTEM_TIMER_EVENT_JUDGE_TW8836_COMM,
 157      =1      _SYSTEM_TIMER_EVENT_JUDGE_WDT_ECHO,
 158      =1       _SYSTEM_TIMER_EVENT_GRN_ON,    
 159      =1      _SYSTEM_TIMER_EVENT_GRN_OFF,    
 160      =1      _SYSTEM_TIMER_EVENT_RED_ON,      
 161      =1      _SYSTEM_TIMER_EVENT_RED_OFF,   
 162      =1      _SYSTEM_TIMER_EVENT_GRN_BLINK,    
 163      =1      _SYSTEM_TIMER_EVENT_RED_BLINK,   
 164      =1      _SYSTEM_TIMER_EVENT_GRN_RED_BLINK,    
 165      =1      _SYSTEM_TIMER_EVENT_GRN_RED_ON,    
 166      =1      _SYSTEM_TIMER_EVENT_GRN_ON_RED_BLINK,    
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 9   

 167      =1      _SYSTEM_TIMER_EVENT_END,
 168      =1      _SYSTEM_TIMER_EVENT_COUNT,
 169      =1  } EnumSystemTimerEventID;
 170      =1  
 171      =1  
 172      =1  typedef enum
 173      =1  {
 174      =1      _SCALER_TIMER_EVENT_START = _SYSTEM_TIMER_EVENT_COUNT,
 175      =1      _SCALER_TIMER_EVENT_TMDS_HDMI_PACKET_DETECT = _SCALER_TIMER_EVENT_START, 
 176      =1      _SCALER_TIMER_EVENT_TMDS_VIDEO_DETECT,  
 177      =1      _SCALER_TIMER_EVENT_AUDIO_LOAD_STABLE_I_CODE,
 178      =1      _SCALER_TIMER_EVENT_DP_HOTPLUG_ASSERTED,
 179      =1      _SCALER_TIMER_EVENT_DP_HDCP_LONG_HOTPLUG_EVENT,
 180      =1      _SCALER_TIMER_EVENT_DP_LINK_STATUS_IRQ,    
 181      =1      _SCALER_TIMER_EVENT_D0_PORT_DIGITAL_SWITCH,
 182      =1      _SCALER_TIMER_EVENT_D1_PORT_DIGITAL_SWITCH,  
 183      =1      _SCALER_TIMER_EVENT_NR_DETECTION_FINISHED,  
 184      =1      _SCALER_TIMER_EVENT_PHASE_CALIBRATION,    
 185      =1      _SCALER_TIMER_EVENT_PHASE_CNT_CHECK,
 186      =1      _SCALER_TIMER_EVENT_MHL_D0_READY_TO_TRANSMIT,
 187      =1      _SCALER_TIMER_EVENT_MHL_D0_READY_TO_RESEND,
 188      =1      _SCALER_TIMER_EVENT_MHL_D0_RECONNECT_1K,
 189      =1      _SCALER_TIMER_EVENT_MHL_D0_ACTIVE_VBUS,
 190      =1      _SCALER_TIMER_EVENT_MHL_D1_READY_TO_TRANSMIT,
 191      =1      _SCALER_TIMER_EVENT_MHL_D1_READY_TO_RESEND,
 192      =1      _SCALER_TIMER_EVENT_MHL_D1_RECONNECT_1K,
 193      =1      _SCALER_TIMER_EVENT_MHL_D1_ACTIVE_VBUS,
 194      =1      _SCALER_TIMER_EVENT_DCC_HISTOGRAM_THD_CHANGE,
 195      =1      _SCALER_TIMER_EVENT_END,
 196      =1      _SCALER_TIMER_EVENT_COUNT = _SCALER_TIMER_EVENT_END,
 197      =1  } EnumMCUTimerEventID;
 198      =1  
 199      =1  #define _SIMULTANEOUS_SCALER_EVENT_COUNT       0//     (5 + (_D0_INPUT_PORT_TYPE == _D0_MHL_PORT) + (_D1_I
             -NPUT_PORT_TYPE == _D1_MHL_PORT))
 200      =1  #define _SIMULTANEOUS_USER_EVENT_COUNT             5
 201      =1  #define _SIMULTANEOUS_SYSTEM_EVENT_COUNT            3
 202      =1  
 203      =1  
 204      =1  #define _TIMER_EVENT_COUNT    (_SIMULTANEOUS_USER_EVENT_COUNT + _SIMULTANEOUS_SYSTEM_EVENT_COUNT + _SIMULT
             -ANEOUS_SCALER_EVENT_COUNT)
 205      =1  
 206      =1  
 207      =1  //--------------------------------------------------
 208      =1  // Power action
 209      =1  //--------------------------------------------------
 210      =1  
 211      =1  typedef enum
 212      =1  {
 213      =1      _POWER_ACTION_OFF_TO_NORMAL = 0x00,          
 214      =1      _POWER_ACTION_AC_ON_TO_NORMAL,         
 215      =1      _POWER_ACTION_AC_ON_TO_OFF,  ////2          
 216      =1      _POWER_ACTION_PS_TO_NORMAL,           
 217      =1      _POWER_ACTION_PS_TO_OFF,              
 218      =1      _POWER_ACTION_NORMAL_TO_PS,   //5        
 219      =1      _POWER_ACTION_NORMAL_TO_OFF,          
 220      =1      _POWER_ACTION_NORMAL_TO_NOSUPPORT_PS, 
 221      =1      _POWER_ACTION_NOSUPPORT_PS_TO_PS,
 222      =1      _POWER_ACTION_NOSUPPORT_PS_TO_OFF, 
 223      =1      _POWER_ACTION_NONE = 0xFF,
 224      =1  } EnumPowerAction;
 225      =1  
 226      =1  typedef enum
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 10  

 227      =1  {
 228      =1      _MODE_ACTION_NO_RESET_MODE = 0x00,                
 229      =1      _MODE_ACTION_RESET_TO_SEARCH,
 230      =1      _MODE_ACTION_RESET_TO_DISPLAY_SETTING, 
 231      =1      _MODE_ACTION_RESET_TO_DISPLAY_SETTING_WITHOUT_FORCETOBG,
 232      =1      _MODE_ACTION_RESET_TO_NOSUPPORT,    
 233      =1      _MODE_ACTION_RESET_TO_NOSIGNAL,
 234      =1      _MODE_ACTION_RESET_TO_POWER_SAVING,    
 235      =1      _MODE_ACTION_RESET_TO_POWER_OFF,           
 236      =1      _MODE_ACTION_RESET_TO_FACTORY_MODE,   
 237      =1      _MODE_ACTION_NONE = 0xFF,
 238      =1  } EnumModeAction;
 239      =1  
 240      =1  
 241      =1  //--------------------------------------------------
 242      =1  // Power status
 243      =1  //--------------------------------------------------
 244      =1  
 245      =1  typedef enum
 246      =1  {
 247      =1      _MODE_STATUS_INITIAL = 0x00,            
 248      =1      _MODE_STATUS_SEARCH,             
 249      =1      _MODE_STATUS_DISPLAY_SETTING,    
 250      =1      _MODE_STATUS_ACTIVE,             
 251      =1      _MODE_STATUS_NOSUPPORT,          
 252      =1      _MODE_STATUS_NOSIGNAL,           
 253      =1      _MODE_STATUS_POWER_SAVING,       
 254      =1      _MODE_STATUS_POWER_OFF,          
 255      =1      _MODE_STATUS_FACTORY,     
 256      =1      _MODE_STATUS_NONE = 0xFF,
 257      =1  } EnumModeStatus;
 258      =1  
 259      =1  typedef enum
 260      =1  {
 261      =1      _POWER_STATUS_AC_ON = 0x00,
 262      =1      _POWER_STATUS_OFF,
 263      =1      _POWER_STATUS_NORMAL,
 264      =1      _POWER_STATUS_NORMAL_BATTERY_MODE,   
 265      =1      _POWER_STATUS_NORMAL_NO_MATTERY_MODE,
 266      =1      _POWER_STATUS_SAVING,
 267      =1      _POWER_STATUS_SAVING_BATTERY_MODE,   
 268      =1      _POWER_STATUS_NOSUPPORT_SAVING,
 269      =1      _POWER_STATUS_NONE = 0xFF,
 270      =1  } EnumPowerStatus;
 271      =1  
 272      =1  
 273      =1  //--------------------------------------------------
 274      =1  // Battery status
 275      =1  //--------------------------------------------------
 276      =1  
 277      =1  typedef enum
 278      =1  {
 279      =1    _BATT_STATUS_CAPACITY_LEVEL4=0x00,
 280      =1    _BATT_STATUS_CAPACITY_LEVEL3,
 281      =1    _BATT_STATUS_CAPACITY_LEVEL2,
 282      =1    _BATT_STATUS_CAPACITY_LEVEL1,
 283      =1    _BATT_STATUS_AC_MODE,
 284      =1    _BATT_STATUS_TEMP_HIGH, 
 285      =1    _BATT_STATUS_TEMP_NORMAL,
 286      =1    _BATT_STATUS_TEMP_LOW, 
 287      =1    _BATT_STATUS_NO_BATT,
 288      =1    _BATT_STATUS_CAPACITY_LOW,
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 11  

 289      =1    _BATT_STATUS_CAPACITY_HIGH,
 290      =1    _BATT_STATUS_ABNORMAL_MODE,
 291      =1    _BATT_STATUS_FAST_CHARGE,
 292      =1    _BATT_STATUS_LOW_CHARGE,
 293      =1    _BATT_STATUS_STOP_CHARGE,
 294      =1    _BATT_STATUS_START_CHARGE,
 295      =1        _BATT_STATUS_NONE = 0xFF,
 296      =1  } EnumBatteryStatus;
 297      =1  
 298      =1  //--------------------------------------------------
 299      =1  // Battery action
 300      =1  //--------------------------------------------------
 301      =1  /*
 302      =1  typedef enum
 303      =1  {
 304      =1      _POWER_ACTION_OFF_TO_NORMAL = 0x00,          
 305      =1      _POWER_ACTION_AC_ON_TO_NORMAL,         
 306      =1      _POWER_ACTION_AC_ON_TO_OFF,  ////2          
 307      =1      _POWER_ACTION_PS_TO_NORMAL,           
 308      =1      _POWER_ACTION_PS_TO_OFF,              
 309      =1      _POWER_ACTION_NORMAL_TO_PS,   //5        
 310      =1      _POWER_ACTION_NORMAL_TO_OFF,          
 311      =1      _POWER_ACTION_NORMAL_TO_NOSUPPORT_PS, 
 312      =1      _POWER_ACTION_NOSUPPORT_PS_TO_PS,
 313      =1      _POWER_ACTION_NOSUPPORT_PS_TO_OFF, 
 314      =1      _POWER_ACTION_NONE = 0xFF,
 315      =1  } EnumPowerAction;
 316      =1  */
 317      =1  /*
 318      =1  typedef enum
 319      =1  {
 320      =1      _MODE_ACTION_NO_RESET_MODE = 0x00,                
 321      =1      _MODE_ACTION_RESET_TO_SEARCH,
 322      =1      _MODE_ACTION_RESET_TO_DISPLAY_SETTING, 
 323      =1      _MODE_ACTION_RESET_TO_DISPLAY_SETTING_WITHOUT_FORCETOBG,
 324      =1      _MODE_ACTION_RESET_TO_NOSUPPORT,    
 325      =1      _MODE_ACTION_RESET_TO_NOSIGNAL,
 326      =1      _MODE_ACTION_RESET_TO_POWER_SAVING,    
 327      =1      _MODE_ACTION_RESET_TO_POWER_OFF,           
 328      =1      _MODE_ACTION_RESET_TO_FACTORY_MODE,   
 329      =1      _MODE_ACTION_NONE = 0xFF,
 330      =1  } EnumModeAction;
 331      =1  */
 332      =1  
 333      =1  typedef struct
 334      =1  {
 335      =1      BYTE b5BatteryStatus:5;
 336      =1      BYTE b1NoBattery:1;
 337      =1      BYTE b1AC_PLUG:1;
 338      =1      BYTE b3BTHStatus:3;
 339      =1      BYTE b1BatteryCapacityLow:1;
 340      =1      BYTE b1BatteryAbnormal:1;
 341      =1      BYTE b2BatteryChargeStatus:2;
 342      =1      WORD BatteryCapacity;
 343      =1  } StructBatteryInfoType;
 344      =1  
 345      =1  
 346      =1  typedef struct
 347      =1  {
 348      =1      BYTE b4PowerAction : 4;
 349      =1      BYTE b4PowerStatus : 4;
 350      =1      BYTE b1GDIIsolationFlag : 1;
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 12  

 351      =1      BYTE b1TopIsolationFlag : 1;
 352      =1      BYTE b1AnalogIsolationFlag : 1;
 353      =1  } StructPowerInfoType;
 354      =1  
 355      =1  
 356      =1  typedef struct
 357      =1  {
 358      =1      BYTE b5ModeState : 5;
 359      =1      BYTE b1DisplaySettingReady : 1;
 360      =1      BYTE b1TimingConfirm : 1;
 361      =1      BYTE b1ModeStateChanged : 1;
 362      =1      BYTE b4ModeResetFlag : 4;    
 363      =1      BYTE b1NoWaitForActive : 1;
 364      =1      BYTE b1ActiveReady : 1;
 365      =1  } StructModeInfoType;
 366      =1  
 367      =1  
 368      =1  
 369      =1  /*
 370      =1  
 371      =1  enum SourceModeTypeEnum
 372      =1  { 
 373      =1    AVMode,      // 0   0X00
 374      =1    //VGAMode,       // 1
 375      =1  #ifdef USE_CAMD 
 376      =1    CAM_D,         // 2
 377      =1  #endif
 378      =1    CAM_A,         // 3     0x01
 379      =1    CAM_B,         // 4     0x02
 380      =1    CAM_C,         // 5     0x03
 381      =1    CAM_R,         // 6     0x04
 382      =1    CAM_AB,        // 7     0x05
 383      =1    CAM_CR,        // 8     0x06
 384      =1    CAM_AR,        // 9     0x07
 385      =1    CAM_RB,        // 10    0x08
 386      =1    CAM_AC,        // 11    0x09
 387      =1    CAM_CB,        // 12    0x0a
 388      =1    CAM_RAB_T,     // 13    0x0b
 389      =1    CAM_RAB_H,     // 14    0x0c
 390      =1  
 391      =1    CAM_QUAD,      // 15    0x0d
 392      =1    CAM_ABR_T3,    // 16    0x0e
 393      =1    CAM_ABR_T4,    // 17    0x0f
 394      =1    CAM_RAC_T,      //0x10  
 395      =1    CAM_RBC_T,      //0x11
 396      =1    CAM_RAC_T2,     //0x12  
 397      =1    CAM_RBC_T2,     //0x13  
 398      =1    CAM_BA,       //0x14
 399      =1    CAM_BC,
 400      =1    CAM_BR,
 401      =1    CAM_CA,
 402      =1    CAM_ABC,
 403      =1    CAM_ABR,
 404      =1    CAM_ACR,
 405      =1    CAM_BAC,
 406      =1    CAM_BAR,
 407      =1    CAM_BCR,
 408      =1    CAM_CAB,
 409      =1    CAM_CAR,
 410      =1    CAM_CBR,  
 411      =1    SEQ,           // 18      0x10
 412      =1    CAM_NUM
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 13  

 413      =1  };
 414      =1  */
 415      =1  //#define _TIMER_EVENT_COUNT      _SYSTEM_TIMER_EVENT_END////                    (_SIMULTANEOUS_USER_EVENT
             -_COUNT + _SIMULTANEOUS_SYSTEM_EVENT_COUNT + _SIMULTANEOUS_SCALER_EVENT_COUNT)
 416      =1  
 417      =1  //typedef unsigned char SourceModeType;
 418      =1  
 419      =1  #endif  /* __TYPEDEFS__ */
  11          #include "reg.h"
   1      =1  //
   2      =1  //Registers.h : Register declaration
   3      =1  //
   4      =1  
   5      =1  #ifndef __REGISTERS__
   6      =1  #define __REGISTERS__
   7      =1  
   8      =1  #ifdef INTERNAL_MCU
           =1 /*  BYTE Registers  */
           =1 sfr P0    = 0x80;
           =1 sfr P1    = 0x90;
           =1 sfr P2    = 0xA0;
           =1 sfr P3    = 0xB0;
           =1 sfr PSW   = 0xD0;
           =1 sfr ACC   = 0xE0;
           =1 sfr B     = 0xF0;
           =1 sfr SP    = 0x81;
           =1 sfr DPL   = 0x82;
           =1 sfr DPH   = 0x83;
           =1 sfr PCON  = 0x87;
           =1 sfr TCON  = 0x88;
           =1 sfr TMOD  = 0x89;
           =1 sfr TL0   = 0x8A;
           =1 sfr TL1   = 0x8B;
           =1 sfr TH0   = 0x8C;
           =1 sfr TH1   = 0x8D;
           =1 sfr IE    = 0xA8;
           =1 sfr IP    = 0xB8;
           =1 sfr SCON  = 0x98;
           =1 sfr SBUF  = 0x99;
           =1 
           =1 //sfr P4    = 0xd8;
           =1 
           =1 /*  8052 Extensions  */
           =1 sfr EXIF  = 0x91;   // external interrupt 2,3,4,5 flags should be cleared by software
           =1 sfr T2CON = 0xC8;
           =1 sfr RCAP2L = 0xCA;
           =1 sfr RCAP2H = 0xCB;
           =1 sfr TL2   = 0xCC;
           =1 sfr TH2   = 0xCD;
           =1 sfr EICON = 0xD8;
           =1 sfr EIE   = 0xE8;
           =1 sfr EIP   = 0xF8;
           =1 
           =1 /*  TW88 Core Extension */
           =1 sfr BANKREG   = 0x9A;
           =1 sfr SPICONTROL  = 0x9B;
           =1 sfr T0HIGH    = 0x9C;
           =1 sfr T0LOW     = 0x9D;
           =1 sfr T1HIGH    = 0x9E;
           =1 sfr T1LOW     = 0x9F;
           =1 sfr T2HIGH    = 0x93;
           =1 sfr T2LOW     = 0x94;
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 14  

           =1 
           =1 /*  BIT Registers  */
           =1 /*  PSW  */
           =1 sbit CY    = 0xD7;
           =1 sbit AC    = 0xD6;
           =1 sbit F0    = 0xD5;
           =1 sbit RS1   = 0xD4;
           =1 sbit RS0   = 0xD3;
           =1 sbit OV    = 0xD2;
           =1 sbit P     = 0xD0;
           =1 
           =1 /*  TCON  */
           =1 sbit TF1   = 0x8F;
           =1 sbit TR1   = 0x8E;
           =1 sbit TF0   = 0x8D;
           =1 sbit TR0   = 0x8C;
           =1 sbit IE1   = 0x8B;
           =1 sbit IT1   = 0x8A;
           =1 sbit IE0   = 0x89;
           =1 sbit IT0   = 0x88;
           =1 
           =1 /*  IE  */
           =1 sbit EA    = 0xAF;
           =1 sbit ES    = 0xAC;
           =1 sbit ET1   = 0xAB;
           =1 sbit EX1   = 0xAA;
           =1 sbit ET0   = 0xA9;
           =1 sbit EX0   = 0xA8;
           =1 
           =1 /*  EIE  */
           =1 sbit EWDI  = 0xEC;    // Watch dog timer interrupt enable
           =1 sbit EX5   = 0xEB;    // external interrupt 5 enable
           =1 sbit EX4   = 0xEA;    // external interrupt 4 enable
           =1 sbit EX3   = 0xE9;    // external interrupt 3 enable
           =1 sbit EX2   = 0xE8;    // external interrupt 2 enable
           =1 
           =1 /*  IP  */
           =1 sbit PS    = 0xBC;
           =1 sbit PT1   = 0xBB;
           =1 sbit PX1   = 0xBA;
           =1 sbit PT0   = 0xB9;
           =1 sbit PX0   = 0xB8;
           =1 
           =1 /*  EIP  */
           =1 sbit PWDI  = 0xFC;    // Watch dog timer interrupt priority
           =1 sbit PX5   = 0xFB;    // external interrupt5 priority
           =1 sbit PX4   = 0xFA;    // external interrupt4 priority
           =1 sbit PX3   = 0xF9;    // external interrupt3 priority
           =1 sbit PX2   = 0xF8;    // external interrupt2 priority
           =1 
           =1 /*  P3  */
           =1 sbit RD    = 0xB7;
           =1 sbit WR    = 0xB6;
           =1 sbit T1    = 0xB5;
           =1 sbit T0    = 0xB4;
           =1 sbit INT1  = 0xB3;
           =1 sbit INT0  = 0xB2;
           =1 sbit TXD   = 0xB1;
           =1 sbit RXD   = 0xB0;
           =1 
           =1 /*  SCON  */
           =1 sbit SM0   = 0x9F;
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 15  

           =1 sbit SM1   = 0x9E;
           =1 sbit SM2   = 0x9D;
           =1 sbit REN   = 0x9C;
           =1 sbit TB8   = 0x9B;
           =1 sbit RB8   = 0x9A;
           =1 sbit TI    = 0x99;
           =1 sbit RI    = 0x98;
           =1 
           =1 /*  8052 Extensions  */
           =1 /*  IE  */
           =1 sbit ET2   = 0xAD;
           =1 
           =1 /*  IP  */
           =1 sbit PT2   = 0xBD;
           =1 
           =1 /*  P1  */
           =1 sbit T2EX  = 0x91;
           =1 sbit T2    = 0x90;
           =1              
           =1 /*  T2CON  */
           =1 sbit TF2   = 0xCF;
           =1 sbit EXF2  = 0xCE;
           =1 sbit RCLK  = 0xCD;
           =1 sbit TCLK  = 0xCC;
           =1 sbit EXEN2 = 0xCB;
           =1 sbit TR2   = 0xCA;
           =1 sbit C_T2  = 0xC9;
           =1 sbit CP_RL2= 0xC8;
           =1 
           =1 sfr CHPENR = 0xF6;
           =1 sfr CHPCON = 0xBF;
           =1 sfr SFRAL  = 0xC4;
           =1 sfr SFRAH  = 0xC5;
           =1 sfr SFRFD  = 0xC6;
           =1 sfr SFRCN  = 0xC7;
           =1 
           =1 sbit P0_0  = 0x80;
           =1 sbit P0_1  = 0x81;
           =1 sbit P0_2  = 0x82;
           =1 sbit P0_3  = 0x83;
           =1 sbit P0_4  = 0x84;
           =1 sbit P0_5  = 0x85;
           =1 sbit P0_6  = 0x86;
           =1 sbit P0_7  = 0x87;
           =1 
           =1 sbit P1_0  = 0x90;
           =1 sbit P1_1  = 0x91;
           =1 sbit P1_2  = 0x92;
           =1 sbit P1_3  = 0x93;
           =1 sbit P1_4  = 0x94;
           =1 sbit P1_5  = 0x95;
           =1 sbit P1_6  = 0x96;
           =1 sbit P1_7  = 0x97;
           =1 
           =1 sbit P2_0  = 0xa0;
           =1 sbit P2_1  = 0xa1;
           =1 sbit P2_2  = 0xa2;
           =1 sbit P2_3  = 0xa3;
           =1 sbit P2_4  = 0xa4;
           =1 sbit P2_5  = 0xa5;
           =1 sbit P2_6  = 0xa6;
           =1 sbit P2_7  = 0xa7;
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 16  

           =1 
           =1 sbit P3_0  = 0xb0;
           =1 sbit P3_1  = 0xb1;
           =1 sbit P3_2  = 0xb2;
           =1 sbit P3_3  = 0xb3;
           =1 sbit P3_4  = 0xb4;
           =1 sbit P3_5  = 0xb5;
           =1 sbit P3_6  = 0xb6;
           =1 sbit P3_7  = 0xb7;
           =1 
           =1 #else // external MCU=WINBOND
 189      =1  /*  BYTE Registers  */
 190      =1  sfr P0    = 0x80;
 191      =1  sfr P1    = 0x90;
 192      =1  sfr P2    = 0xA0;
 193      =1  sfr P3    = 0xB0;
 194      =1  sfr PSW   = 0xD0;
 195      =1  sfr ACC   = 0xE0;
 196      =1  sfr B     = 0xF0;
 197      =1  sfr SP    = 0x81;
 198      =1  sfr DPL   = 0x82;
 199      =1  sfr DPH   = 0x83;
 200      =1  sfr PCON  = 0x87;
 201      =1  sfr TCON  = 0x88;
 202      =1  sfr TMOD  = 0x89;
 203      =1  sfr TL0   = 0x8A;
 204      =1  sfr TL1   = 0x8B;
 205      =1  sfr TH0   = 0x8C;
 206      =1  sfr TH1   = 0x8D;
 207      =1  sfr CKCON = 0x8E;   //clock control register, default =0x01
 208      =1  sfr IE    = 0xA8;
 209      =1  sfr IP    = 0xB8;
 210      =1  sfr SCON  = 0x98;
 211      =1  sfr SBUF  = 0x99;
 212      =1  sfr P4 = 0xE8; //Megawin Ryan@970716
 213      =1  //sfr P4    = 0xa5;      //SST MCU
 214      =1  //sfr P4    = 0xd8;   //winbond<960820>
 215      =1  
 216      =1  
 217      =1  /*  8052 Extensions  */
 218      =1  sfr ADCTL = 0xC5;   //william-20111017
 219      =1  sfr ADCV = 0xC6;    //william-20111017
 220      =1  sfr ADCVL = 0xE8;   //william-20111017
 221      =1  sfr T2CON = 0xC8;
 222      =1  sfr RCAP2L = 0xCA;
 223      =1  sfr RCAP2H = 0xCB;
 224      =1  sfr TL2   = 0xCC;
 225      =1  sfr TH2   = 0xCD;
 226      =1  
 227      =1  // for UART2
 228      =1  sfr S2CON  = 0xAA;
 229      =1  sfr S2BRT  = 0xBA;
 230      =1  sfr S2BUF  = 0x9A;
 231      =1  sfr AUXR2  = 0xA6;
 232      =1  sfr AUXIE  = 0xAD;
 233      =1  
 234      =1  
 235      =1  sfr P1M0  = 0x91;
 236      =1  sfr P1M1  = 0x92;
 237      =1  sfr P0M0  = 0x93;
 238      =1  sfr P0M1  = 0x94;
 239      =1  sfr P2M0  = 0x95;
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 17  

 240      =1  sfr P2M1  = 0x96;
 241      =1  sfr P3M0  = 0xB1;
 242      =1  sfr P3M1  = 0xB2;
 243      =1  
 244      =1  
 245      =1  // for PCA
 246      =1  sfr CCON   = 0xD8;
 247      =1  sfr CMOD   = 0xD9;
 248      =1  sfr CCAPM0 = 0xDA;
 249      =1  sfr CCAPM1 = 0xDB;
 250      =1  sfr CCAPM2 = 0xDC;
 251      =1  sfr CCAPM3 = 0xDD;
 252      =1  sfr CCAPM4 = 0xDE;
 253      =1  sfr CCAPM5 = 0xDF;
 254      =1  sfr CL     = 0xE9;
 255      =1  sfr CH     = 0xF9;
 256      =1  sfr CCAP0L = 0xEA;
 257      =1  sfr CCAP0H = 0xFA;
 258      =1  sfr CCAP1L = 0xEB;
 259      =1  sfr CCAP1H = 0xFB;
 260      =1  sfr CCAP2L = 0xEC;
 261      =1  sfr CCAP2H = 0xFC;
 262      =1  sfr CCAP3L = 0xED;
 263      =1  sfr CCAP3H = 0xFD;
 264      =1  sfr CCAP4L = 0xEE;
 265      =1  sfr CCAP4H = 0xFE;
 266      =1  sfr CCAP5L = 0xEF;
 267      =1  sfr CCAP5H = 0xFF;
 268      =1  sfr PCAPWM0= 0xF2;
 269      =1  sfr PCAPWM1= 0xF3;
 270      =1  sfr PCAPWM2= 0xF4;
 271      =1  sfr PCAPWM3= 0xF5;
 272      =1  sfr PCAPWM4= 0xF6;
 273      =1  sfr PCAPWM5= 0xF7;
 274      =1  
 275      =1  /*  BIT Registers  */
 276      =1  /*  PSW  */
 277      =1  sbit CY    = 0xD7;
 278      =1  sbit AC    = 0xD6;
 279      =1  sbit F0    = 0xD5;
 280      =1  sbit RS1   = 0xD4;
 281      =1  sbit RS0   = 0xD3;
 282      =1  sbit OV    = 0xD2;
 283      =1  sbit P     = 0xD0;
 284      =1  
 285      =1  /*  TCON  */
 286      =1  sbit TF1   = 0x8F;
 287      =1  sbit TR1   = 0x8E;
 288      =1  sbit TF0   = 0x8D;
 289      =1  sbit TR0   = 0x8C;
 290      =1  sbit IE1   = 0x8B;
 291      =1  sbit IT1   = 0x8A;
 292      =1  sbit IE0   = 0x89;
 293      =1  sbit IT0   = 0x88;
 294      =1  
 295      =1  /*  IE  */
 296      =1  sbit EA    = 0xAF;
 297      =1  sbit ES    = 0xAC;
 298      =1  sbit ET1   = 0xAB;
 299      =1  sbit EX1   = 0xAA;
 300      =1  sbit ET0   = 0xA9;
 301      =1  sbit EX0   = 0xA8;
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 18  

 302      =1  
 303      =1  /*  IP  */
 304      =1  sbit PS    = 0xBC;
 305      =1  sbit PT1   = 0xBB;
 306      =1  sbit PX1   = 0xBA;
 307      =1  sbit PT0   = 0xB9;
 308      =1  sbit PX0   = 0xB8;
 309      =1  
 310      =1  /*  P3  */
 311      =1  sbit RD    = 0xB7;
 312      =1  sbit WR    = 0xB6;
 313      =1  sbit T1    = 0xB5;
 314      =1  sbit T0    = 0xB4;
 315      =1  sbit INT1  = 0xB3;
 316      =1  sbit INT0  = 0xB2;
 317      =1  sbit TXD   = 0xB1;
 318      =1  sbit RXD   = 0xB0;
 319      =1  
 320      =1  /*  SCON  */
 321      =1  sbit SM0   = 0x9F;
 322      =1  sbit SM1   = 0x9E;
 323      =1  sbit SM2   = 0x9D;
 324      =1  sbit REN   = 0x9C;
 325      =1  sbit TB8   = 0x9B;
 326      =1  sbit RB8   = 0x9A;
 327      =1  sbit TI    = 0x99;
 328      =1  sbit RI    = 0x98;
 329      =1  
 330      =1  /*  8052 Extensions  */
 331      =1  /*  IE  */
 332      =1  sbit ET2   = 0xAD;
 333      =1  
 334      =1  /*  IP  */
 335      =1  sbit PT2   = 0xBD;
 336      =1  
 337      =1  /*  P1  */
 338      =1  sbit T2EX  = 0x91;
 339      =1  sbit T2    = 0x90;
 340      =1               
 341      =1  /*  T2CON  */
 342      =1  sbit TF2   = 0xCF;
 343      =1  sbit EXF2  = 0xCE;
 344      =1  sbit RCLK  = 0xCD;
 345      =1  sbit TCLK  = 0xCC;
 346      =1  sbit EXEN2 = 0xCB;
 347      =1  sbit TR2   = 0xCA;
 348      =1  sbit C_T2  = 0xC9;
 349      =1  sbit CP_RL2= 0xC8;
 350      =1  
 351      =1  sfr CHPENR = 0xF6;
 352      =1  sfr CHPCON = 0xBF;
 353      =1  sfr SFRAL  = 0xC4;
 354      =1  sfr SFRAH  = 0xC5;
 355      =1  sfr SFRFD  = 0xC6;
 356      =1  sfr SFRCN  = 0xC7;
 357      =1  
 358      =1  sbit P0_0  = 0x80;
 359      =1  sbit P0_1  = 0x81;
 360      =1  sbit P0_2  = 0x82;
 361      =1  sbit P0_3  = 0x83;
 362      =1  sbit P0_4  = 0x84;
 363      =1  sbit P0_5  = 0x85;
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 19  

 364      =1  sbit P0_6  = 0x86;
 365      =1  sbit P0_7  = 0x87;
 366      =1  
 367      =1  sbit P1_0  = 0x90;
 368      =1  sbit P1_1  = 0x91;
 369      =1  sbit P1_2  = 0x92;
 370      =1  sbit P1_3  = 0x93;
 371      =1  sbit P1_4  = 0x94;
 372      =1  sbit P1_5  = 0x95;
 373      =1  sbit P1_6  = 0x96;
 374      =1  sbit P1_7  = 0x97;
 375      =1  
 376      =1  sbit P2_0  = 0xa0;
 377      =1  sbit P2_1  = 0xa1;
 378      =1  sbit P2_2  = 0xa2;
 379      =1  sbit P2_3  = 0xa3;
 380      =1  sbit P2_4  = 0xa4;
 381      =1  sbit P2_5  = 0xa5;
 382      =1  sbit P2_6  = 0xa6;
 383      =1  sbit P2_7  = 0xa7;
 384      =1  
 385      =1  sbit P3_0  = 0xb0;
 386      =1  sbit P3_1  = 0xb1;
 387      =1  sbit P3_2  = 0xb2;
 388      =1  sbit P3_3  = 0xb3;
 389      =1  sbit P3_4  = 0xb4;
 390      =1  sbit P3_5  = 0xb5;
 391      =1  sbit P3_6  = 0xb6;
 392      =1  sbit P3_7  = 0xb7;
 393      =1  
 394      =1  sbit P4_0  = P4^0;
 395      =1  sbit P4_1  = P4^1;
 396      =1  sbit P4_2  = P4^2;
 397      =1  sbit P4_3  = P4^3;
 398      =1  #endif  // INTERNAL_MCU
 399      =1  
 400      =1  #endif  //__REGISTERS__
  12          //#include "regmap.h"
  13          #include "cpu.h"
   1      =1  #ifndef __CPU__
   2      =1  #define __CPU__
   3      =1  
   4      =1  /*
   5      =1  #ifdef INTERNAL_MCU
   6      =1  #define I2C_SCL   P2_0
   7      =1  #else
   8      =1  #define I2C_SCL   P1_0
   9      =1  #endif
  10      =1  #define I2C_SDA   P1_1
  11      =1  */
  12      =1  #define I2C_SCL   P1_0
  13      =1  #define I2C_SDA   P1_1
  14      =1  #define BUF_MAX   8
  15      =1  #define DVR_BUF_MAX   30
  16      =1  
  17      =1  //--------------------------------------------------
  18      =1  // Panel  Related MACRO
  19      =1  //--------------------------------------------------
  20      =1  #define GET_P_IO1()   (P3_4)  
  21      =1  #define SET_P_IO1()   (P3_4 = 1)    
  22      =1  #define CLR_P_IO1()   (P3_4 = 0)  
  23      =1  
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 20  

  24      =1  #define GET_P_IO2()   (P3_5)  
  25      =1  #define SET_P_IO2()   (P3_5 = 1)    
  26      =1  #define CLR_P_IO2()   (P3_5 = 0)  
  27      =1  
  28      =1  #define GET_BL_PWM()    (P1_4)  
  29      =1  #define SET_BL_PWM()    (P1_4 = 1)    //ON
  30      =1  #define CLR_BL_PWM()    (P1_4 = 0)  //OFF
  31      =1  
  32      =1  #define GET_PCON3V3_P()  (P0_3) 
  33      =1  #define SET_PCON3V3_P()  (P0_3 = 0)    //ON
  34      =1  #define CLR_PCON3V3_P()  (P0_3 = 1) //OFF
  35      =1  
  36      =1  #define GET_PCON5V_P()   (P0_4) 
  37      =1  #define SET_PCON5V_P()   (P0_4 = 0)    //ON
  38      =1  #define CLR_PCON5V_P()   (P0_4 = 1) //OFF
  39      =1  
  40      =1  #define GET_Panel_EN()   (P2_1) 
  41      =1  #define SET_Panel_EN()   (P2_1 = 1)    //ON
  42      =1  #define CLR_Panel_EN()   (P2_1 = 0) //OFF
  43      =1  
  44      =1  #define GET_CTP_INT()   (P2_4)  
  45      =1  #define SET_CTP_INT()   (P2_4 = 1)     //ON
  46      =1  #define CLR_CTP_INT()   (P2_4 = 0)  //OFF
  47      =1  
  48      =1  #define GET_CTP_RST()   (P2_5)  
  49      =1  #define SET_CTP_RST()   (P2_5 = 1)     //ON
  50      =1  #define CLR_CTP_RST()   (P2_5 = 0)  //OFF
  51      =1  
  52      =1  #define GET_PWCTRL()    (P3_7)  
  53      =1  #define SET_PWCTRL()    (P3_7 = 1)     //ON
  54      =1  #define CLR_PWCTRL()    (P3_7 = 0)  //OFF
  55      =1  
  56      =1  //--------------------------------------------------
  57      =1  // Battery  Related MACRO
  58      =1  //--------------------------------------------------
  59      =1  
  60      =1  #define GET_PWR_GOOD()  (P1_5)    
  61      =1  
  62      =1  #define GET_STAT1()   (P0_0)    
  63      =1  #define GET_STAT2()   (P0_1)    
  64      =1  
  65      =1  #define GET_CHG_CURR()    (P0_6)  
  66      =1  #define SET_CHG_CURR()    (P0_6 = 1)     //ON
  67      =1  #define CLR_CHG_CURR()    (P0_6 = 0)  //OFF
  68      =1  
  69      =1  #define GET_AC_MODE()   (P4_2)  
  70      =1  #define SET_AC_MODE()   (P4_2 = 1)     //ON
  71      =1  #define CLR_AC_MODE()   (P4_2 = 0)  //OFF
  72      =1  
  73      =1  //--------------------------------------------------
  74      =1  // DVR Power  Related MACRO
  75      =1  //--------------------------------------------------
  76      =1  
  77      =1  #define GET_BAT_SYS()   (P2_6)  
  78      =1  #define SET_BAT_SYS()   (P2_6 = 1)     //ON
  79      =1  #define CLR_BAT_SYS()   (P2_6 = 0)  //OFF
  80      =1  
  81      =1  //--------------------------------------------------
  82      =1  // CAM Power  Related MACRO
  83      =1  //--------------------------------------------------
  84      =1  
  85      =1  #define GET_PCON_CAM()    (P2_2)  
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 21  

  86      =1  #define SET_PCON_CAM()    (P2_2 = 1)     //ON
  87      =1  #define CLR_PCON_CAM()    (P2_2 = 0)  //OFF
  88      =1  
  89      =1  //--------------------------------------------------
  90      =1  // TW8836 Power  Related MACRO
  91      =1  //--------------------------------------------------
  92      =1  
  93      =1  #define GET_PCON3V3_TW()    (P3_6)  
  94      =1  #define SET_PCON3V3_TW()    (P3_6 = 0)     //ON
  95      =1  #define CLR_PCON3V3_TW()    (P3_6 = 1)  //OFF
  96      =1  
  97      =1  #define GET_TW8836_RST()      (P2_0)  
  98      =1  #define SET_TW8836_RST()      (P2_0 = 0)     //ON
  99      =1  #define CLR_TW8836_RST()      (P2_0 = 1)  //OFF
 100      =1  
 101      =1  
 102      =1  //--------------------------------------------------
 103      =1  // I/O board  Related MACRO
 104      =1  //--------------------------------------------------
 105      =1  
 106      =1  #define GET_GREEN()       (P4_0)  
 107      =1  #define SET_GREEN()       (P4_0 = 0)     
 108      =1  #define CLR_GREEN()       (P4_0 = 1)  
 109      =1  
 110      =1  #define GET_RED()         (P4_1)  
 111      =1  #define SET_RED()         (P4_1 = 0)     
 112      =1  #define CLR_RED()         (P4_1 = 1)  
 113      =1  
 114      =1  #define GET_PSW()       (P4_3)  
 115      =1  #define SET_PSW()       (P4_3 = 1)     
 116      =1  #define CLR_PSW()       (P4_3 = 0)  
 117      =1  
 118      =1  #define GET_ADAP_12()     (P0_5)  
 119      =1  #define SET_ADAP_12()     (P0_5 = 1)     
 120      =1  #define CLR_ADAP_12()     (P0_5 = 0)  
 121      =1  
 122      =1  
 123      =1  #ifdef REMO_RC5
           =1 #define EnableRemoconInt()  { RemoDataReady = 0;  EX0 = 1;}
           =1 #endif
 126      =1  void  InitCPU(void);
 127      =1  void  InitVars(void);
 128      =1  void  InitTechwell(void);
 129      =1  void  main_init (void);
 130      =1  void  PowerDown( void );
 131      =1  #if 0
           =1 BYTE  OKSleepTime(void);
           =1 #endif
 134      =1  #ifdef REMO_RC5
           =1 void  InitForRemo(void);
           =1 #endif
 137      =1  void  PowerLED(BYTE flag);
 138      =1  void    Wait_ms(WORD Tms);
 139      =1  BYTE    TW2835Command(char,char,char,char,char);
 140      =1  void SET_PWM(BYTE index, BYTE val);
 141      =1  
 142      =1  #endif
  14          #include "main.h"
   1      =1  #ifndef __MAIN__
   2      =1  #define __MAIN__
   3      =1  
   4      =1  #define ON          1
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 22  

   5      =1  #define OFF         0
   6      =1  #define Hs_debug
   7      =1  //#define DVR
   8      =1  #define Format_SDCard
   9      =1  #define BJTSwitch
  10      =1  
  11      =1  
  12      =1  
  13      =1  #define Panel_Enable()          P4=P4|0x08 //andy 980908
  14      =1  #define Panel_Disable()     P4=P4&0xf7
  15      =1  
  16      =1  #if 0
           =1 #define SetBacklight()      P4=P4|0x04
           =1 #define clrBacklight()      P4=P4&0xfb
           =1 #else
  20      =1  #define SetBacklight()      P4=P4&0xfb
  21      =1  #define clrBacklight()       P4=P4|0x04
  22      =1  #endif
  23      =1  /*
  24      =1  #define COLUMN1_PIN   P2_3
  25      =1  #define COLUMN2_PIN   P2_4
  26      =1  #define COLUMN3_PIN   P2_5
  27      =1  */
  28      =1  
  29      =1  //InputSelection
  30      =1  /*
  31      =1  struct struct_IdName {
  32      =1    BYTE  Id;
  33      =1    BYTE  Name[16];
  34      =1  };
  35      =1  /*
  36      =1  
  37      =1  #define CH_TW2835              1
  38      =1  #define CH_CAMD                2
  39      =1  #define CH_AV                  3
  40      =1  #define PC             7
  41      =1  #define ChineseDefaultMenu   8
  42      =1  
  43      =1  #define SVIDEO        2
  44      =1  #define COMPONENT     3
  45      =1  //#define ANALOGDTV     4
  46      =1  #define DTV         4
  47      =1  #define TV          5
  48      =1  #define SCART       6
  49      =1  
  50      =1  #define DIGITALVGA      8
  51      =1  
  52      =1  #define AIRTV       0 //9
  53      =1  #define CABLETV       1 //0xa
  54      =1  
  55      =1  
  56      =1  #define TVTUNER       0xd   //10
  57      =1  #define MUTE        1 
  58      =1  #define MENU        2 
  59      =1  #define TVVOL       4 
  60      =1  #define CC          8 
  61      =1  #define INPUTINFO     0x10
  62      =1  #define PCINFO        0x20
  63      =1  #define GAUGEINFO           0x40
  64      =1  //#define RATINGINFO      0x40
  65      =1  #define TVCHN       0x80
  66      =1  //#define MUTE        0x40
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 23  

  67      =1  
  68      =1  #define YPBPR_480i      0
  69      =1  #define YPBPR_576i      1
  70      =1  #define YPBPR_480p      2
  71      =1  #define YPBPR_576p      3
  72      =1  #define YPBPR_1080i     4
  73      =1  #define YPBPR_720p      5
  74      =1  #define YPBPR_720p50    6
  75      =1  */
  76      =1  
  77      =1  #define _STOP_PWM     0x00
  78      =1  #define _RUN_PWM    0xFF
  79      =1  #define _BL_PWM     0x14
  80      =1  #define _CHG_CURR   0x15
  81      =1  
  82      =1  //ADC
  83      =1  #define P16_BTH   6  //P1.6
  84      =1  #define P17_BAT   7  //P1.7
  85      =1  
  86      =1  
  87      =1  
  88      =1  //--------------------------- P0 Define -----------------------------
  89      =1  //#define SEL_MIX     P0_6  // 
  90      =1  //--------------------------- P1 Define -----------------------------
  91      =1  //#define SEL_DVI     P3_5  //LJY062001   
  92      =1  
  93      =1  #define TW88HWReset     P3_4  //LJY001010 //LJY000721
  94      =1  #define PowerUp             P3_7
  95      =1  #define LBEN P1_6
  96      =1  //======================= CDS Control ================================= 
  97      =1  //#define CDS_CTRL           P1_5
  98      =1  /*
  99      =1  extern BYTE SelectModeType;
 100      =1  extern BYTE InputSelection;
 101      =1  extern BYTE SEQTime;
 102      =1  extern BYTE Priority;
 103      =1  extern BYTE PowerFlag;
 104      =1  //extern bit AutoDayNight;
 105      =1  extern bit SDCardCoverDetect;
 106      =1  */
 107      =1  BYTE keyIn(void);
 108      =1  void TimerForRemocon(void);
 109      =1  void TimerForTick(void);
 110      =1  void DisableRemoconInt(void);
 111      =1  BYTE SetSupport_remocon(BYTE newd);
 112      =1  
 113      =1  void delay(BYTE cnt);
 114      =1  
 115      =1  BYTE RS_ready(void);
 116      =1  #ifdef Hs_debug
 117      =1  BYTE RS_rx(void);
 118      =1  #endif
 119      =1  void RS_tx(BYTE tx_buf);
 120      =1  
 121      =1  BYTE RS2_rx(void);
 122      =1  void RS2_tx(BYTE tx_buf);
 123      =1  
 124      =1  //void NewLine(void);
 125      =1  //void PutsP(PDATA_P BYTE *ptr);
 126      =1  #ifdef Hs_debug
 127      =1  //void MonWriteI2C(BYTE addr, BYTE index, BYTE val);
 128      =1  //BYTE MonReadI2C(BYTE addr, BYTE index);
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 24  

 129      =1  #endif
 130      =1  BYTE Asc1Bin(BYTE asc);
 131      =1  BYTE Asc2Bin(PDATA_P BYTE *s);
 132      =1  
 133      =1  //void I2CDeviceInitialize( CODE_P BYTE *RegSet);
 134      =1  
 135      =1  //void RestartSystemClock(WORD clock_hm);
 136      =1  //WORD GetTime_ms(void);
 137      =1  #if 0
           =1 BYTE GetTime_H(void);
           =1 BYTE GetTime_M(void);
           =1 #endif
 141      =1  //void ChangeTime_H( char add );
 142      =1  //void ChangeTime_M( char add );
 143      =1  //WORD GetWakeupTime(void);
 144      =1  //void SetWakeupTime(WORD wtime);
 145      =1  
 146      =1  
 147      =1  //WORD GetOffTime(void);
 148      =1  //void SetOffTime(WORD wtime);
 149      =1  //BYTE GetSleepTimer(void);
 150      =1  //void SetSleepTimer(BYTE stime);
 151      =1  /*
 152      =1  WORD DiffTime_ms( WORD stime, WORD etime );
 153      =1  //void SetLastBlockedTime(void);
 154      =1  void SetLastCCTime(void);       //ljy010904...CC_FIX_CLEAR_ON_TIME
 155      =1  
 156      =1  void SetOSDLastKeyInTime(void);
 157      =1  WORD GetOSDLastKeyInTime(void);
 158      =1  WORD GetIVF(void);
 159      =1  DWORD GetIHF(void);
 160      =1  BYTE ReadVInputSTD(void);
 161      =1  void SetVInputStd(BYTE newd);
 162      =1  BYTE GetVInputStd(void);
 163      =1  BYTE GetInputSelection(void);
 164      =1  #ifdef ADD_ANALOGPANEL
 165      =1  BYTE IsAnalogOn(void);
 166      =1  #endif
 167      =1  void InitVideoData(BYTE src);
 168      =1  void ChangeVInputStdDetectMode(BYTE val);
 169      =1  BYTE GetVInputStdInx(void);
 170      =1  
 171      =1  void MonWriteI2Cn_(BYTE addr, BYTE *val, BYTE cnt) ;
 172      =1  */
 173      =1  ///void Usage(void);
 174      =1  #ifdef Hs_debug
 175      =1    void Prompt(void);
 176      =1  #endif
 177      =1  /*
 178      =1  void DebugKeyIn(BYTE ikey);
 179      =1  void DVIPowerDown(bit flag);
 180      =1  void PowerDown_XTAL(bit flag);
 181      =1  */
 182      =1  //void ChangeInput(BYTE newsel);
 183      =1  
 184      =1  
 185      =1  void WaitPowerOn(void);
 186      =1  //void PowerOff(void);
 187      =1  //BYTE GetNextInputSelection(void);
 188      =1  
 189      =1  //BYTE WantToStopTVScan(void);
 190      =1  
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 25  

 191      =1  //BYTE IsTW8801(void);
 192      =1  //BYTE IsTW8803(void);
 193      =1  //BYTE ConvertVideoVSAT(BYTE reg);
 194      =1  
 195      =1  //BYTE IsNoInput(void);
 196      =1  void LoadEEPROM (void);
 197      =1  void Hs_InitVars(void);
 198      =1  /*
 199      =1  void AdjustAutoDayNight(BYTE val);
 200      =1  void ACCPowerControl(void);
 201      =1  void AdjustBacklight(BYTE val);//val=0~110
 202      =1  */
 203      =1  BYTE mcuLib_ProtocolAppend(BYTE *pucBuf, BYTE* piLen, BYTE ucByte);
 204      =1  BYTE mcuLib_ProtocolSendCmdWithParamNum(BYTE ucType, BYTE* pucParam, BYTE ucSize);
 205      =1  void MCU_SendCmdToDVR(BYTE ucType);
 206      =1  void SetAD5110Step(BYTE newv) ;
 207      =1  
 208      =1  
 209      =1  
 210      =1  extern BYTE ScanPowerkey(void);
 211      =1  extern void MCUTimerInitialTimerEvent(void);
 212      =1  extern void MCUTimerActiveTimerEvent(WORD usTime, BYTE ucEventID);
 213      =1  extern void SysTimerHandler(void);
 214      =1  extern void SysJudgeHandler(void);
 215      =1  extern void SysModeHandler(void);
 216      =1  extern void SysPowerHandler(void);
 217      =1  
 218      =1  extern void MCUTimerDelayXms(WORD usNum);
 219      =1  
 220      =1  
 221      =1  struct RegisterInfo
 222      =1  {
 223      =1     int  Min;
 224      =1     int  Max;
 225      =1     int  Default;
 226      =1  };
 227      =1  struct LongRegisterInfo
 228      =1  {
 229      =1     WORD Min;
 230      =1     WORD Max;
 231      =1     WORD Default;
 232      =1  };
 233      =1  
 234      =1  
 235      =1  
 236      =1  
 237      =1  #endif  // __MAIN__
  15          #include "I2C.h"
   1      =1  #ifndef __I2C_H__
   2      =1  #define __I2C_H__
   3      =1  //AD5110 table
   4      =1  /*   
   5      =1  "RA=100K+5.1K, RB=10K+10K  "        //  
   6      =1    D7D6D5D4D3D2D1D0  Vout        //
   7      =1  0 0 4.90                            //
   8      =1  1 1 4.92      
   9      =1  2 10  4.93      
  10      =1  3 11  4.95      
  11      =1  4 100 4.97      
  12      =1  5 101 4.99      
  13      =1  6 110 5.00      
  14      =1  7 111 5.02      
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 26  

  15      =1  8 1000  5.03      
  16      =1  9 1001  5.05      
  17      =1  10  1010  5.07      
  18      =1  11  1011  5.09      
  19      =1  12  1100  5.11      
  20      =1  13  1101  5.12      
  21      =1  14  1110  5.14      
  22      =1  15  1111  5.16      
  23      =1  16  10000 5.18      
  24      =1  17  10001 5.20      
  25      =1  18  10010 5.21      
  26      =1  19  10011 5.23      
  27      =1  20  10100 5.25      
  28      =1  21  10101 5.27      
  29      =1  22  10110 5.29      
  30      =1  23  10111 5.31      
  31      =1  24  11000 5.33      
  32      =1  25  11001 5.35      
  33      =1  26  11010 5.37      
  34      =1  27  11011 5.39      
  35      =1  28  11100 5.41      
  36      =1  29  11101 5.43      
  37      =1  30  11110 5.45      
  38      =1  31  11111 5.47      
  39      =1  32  100000  5.48      
  40      =1  33  100001  5.51      
  41      =1  34  100010  5.54      
  42      =1  35  100011  5.56      
  43      =1  36  100100  5.58      
  44      =1  37  100101  5.60      
  45      =1  38  100110  5.63      
  46      =1  39  100111  5.65      
  47      =1  40  101000  5.67      
  48      =1  41  101001  5.69      
  49      =1  42  101010  5.72      
  50      =1  43  101011  5.74      
  51      =1  44  101100  5.76      
  52      =1  45  101101  5.78      
  53      =1  46  101110  5.81      
  54      =1  47  101111  5.84      
  55      =1  48  110000  5.86      
  56      =1  49  110001  5.88      
  57      =1  50  110010  5.91      
  58      =1  51  110011  5.93      
  59      =1  52  110100  5.96      
  60      =1  53  110101  5.98      
  61      =1  54  110110  6.01      
  62      =1  55  110111  6.04      
  63      =1  56  111000  6.06      
  64      =1  57  111001  6.09      
  65      =1  58  111010  6.11      
  66      =1  59  111011  6.15      
  67      =1  60  111100  6.17      
  68      =1  61  111101  6.20      
  69      =1  62  111110  6.23      
  70      =1  63  111111  6.26      
  71      =1  64  1000000 6.28      
  72      =1  65  1000001 6.32      
  73      =1  66  1000010 6.35      
  74      =1  67  1000011 6.37      
  75      =1  68  1000100 6.40      
  76      =1  69  1000101 6.44      
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 27  

  77      =1  70  1000110 6.47      
  78      =1  71  1000111 6.50      
  79      =1  72  1001000 6.53      
  80      =1  73  1001001 6.56      
  81      =1  74  1001010 6.59      
  82      =1  75  1001011 6.62      
  83      =1  76  1001100 6.66      
  84      =1  77  1001101 6.69      
  85      =1  78  1001110 6.72      
  86      =1  79  1001111 6.76      
  87      =1  80  1010000 6.79      
  88      =1  81  1010001 6.83      
  89      =1  82  1010010 6.86      
  90      =1  83  1010011 6.90      
  91      =1  84  1010100 6.93      
  92      =1  85  1010101 6.97      
  93      =1  86  1010110 7.01      
  94      =1  87  1010111 7.04      
  95      =1  88  1011000 7.08      
  96      =1  89  1011001 7.12      
  97      =1  90  1011010 7.16      
  98      =1  91  1011011 7.20      
  99      =1  92  1011100 7.24      
 100      =1  93  1011101 7.28      
 101      =1  94  1011110 7.32      
 102      =1  95  1011111 7.36      
 103      =1  96  1100000 7.40      
 104      =1  97  1100001 7.44      
 105      =1  98  1100010 7.48      
 106      =1  99  1100011 7.53      
 107      =1  100 1100100 7.57      
 108      =1  101 1100101 7.61      
 109      =1  102 1100110 7.66      
 110      =1  103 1100111 7.71      
 111      =1  104 1101000 7.75      
 112      =1  105 1101001 7.80      
 113      =1  106 1101010 7.84      
 114      =1  107 1101011 7.89      
 115      =1  108 1101100 7.94      
 116      =1  109 1101101 7.99      
 117      =1  110 1101110 8.04      
 118      =1  111 1101111 8.09      
 119      =1  112 1110000 8.14      
 120      =1  113 1110001 8.19      
 121      =1  114 1110010 8.25      
 122      =1  115 1110011 8.30      
 123      =1  116 1110100 8.35      
 124      =1  117 1110101 8.41      
 125      =1  118 1110110 8.47      
 126      =1  119 1110111 8.52      
 127      =1  120 1111000 8.58      
 128      =1  121 1111001 8.64      
 129      =1  122 1111010 8.70      
 130      =1  123 1111011 8.76      
 131      =1  124 1111100 8.82      
 132      =1  125 1111101 8.88      
 133      =1  126 1111110 8.95      
 134      =1  127 1111111 9.01      
 135      =1  */
 136      =1  void I2CReadByte3(BYTE *);
 137      =1  void I2CRead8Byte(BYTE *);
 138      =1  #if 0
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 28  

           =1 void I2CReadByteMSP(BYTE addr, BYTE index, BYTE *pd, BYTE cnt);
           =1 #endif
 141      =1  BYTE I2CWriteByte2(BYTE);
 142      =1  BYTE I2CWriteByte3(BYTE*);
 143      =1  BYTE I2CWrite8Byte(BYTE *);
 144      =1  
 145      =1  void I2CStart(void);
 146      =1  void I2CWriteData(BYTE value);
 147      =1  BYTE I2CReadData(void);
 148      =1  #if 0
           =1 BYTE I2CReadDataWithACK(void);
           =1 #endif
 151      =1  void I2CStop(void);
 152      =1  void I2Cdelay(void);
 153      =1  
 154      =1  
 155      =1  
 156      =1  #define WriteTW88(a,b)    WriteI2C(TW88I2CAddress, a, b)
 157      =1  #define ReadTW88(a)     ReadI2C(TW88I2CAddress, a)
 158      =1  /*
 159      =1  
 160      =1  
 161      =1  BYTE WriteTW88_Wait (BYTE, BYTE);
 162      =1  void WriteADC   (BYTE, BYTE);
 163      =1  BYTE ReadADC    (BYTE);
 164      =1  //BYTE ReadADC_TW88(BYTE index);
 165      =1  void WriteADC_TW88(BYTE index, BYTE dat);
 166      =1  */
 167      =1  void WriteEEP   (WORD, BYTE);
 168      =1  BYTE ReadEEP    (WORD);
 169      =1  //WORD ReadALC106(WORD index);
 170      =1  //void WriteALC106(WORD index, WORD  dat);
 171      =1  
 172      =1  WORD ReadI2CWORD(BYTE addr, BYTE index);
 173      =1  BYTE ReadI2C    (BYTE addr, BYTE index);
 174      =1  void WriteI2C   (BYTE addr, BYTE index, BYTE val);
 175      =1  
 176      =1  void WriteI2Cn_(BYTE addr, BYTE *val, BYTE cnt);
 177      =1  void WriteI2Cn (BYTE addr, BYTE index, BYTE *val, BYTE cnt);
 178      =1  void WriteI2CnD(BYTE addr, BYTE index, BYTE val, BYTE cnt);
 179      =1  
 180      =1  void ReadI2Cmn(BYTE addr, BYTE wcnt, BYTE rcnt, BYTE *rwdata);
 181      =1  void WriteAD5110(WORD index, WORD  dat);
 182      =1  WORD ReadAD5110(WORD index);
 183      =1  
 184      =1  
 185      =1  #define   WriteADC(a,b) WriteADC_TW88(a,b)
 186      =1  #define   ReadADC(a)    ReadADC_TW88(a)
 187      =1  
 188      =1  #endif  /* __I2C_H__ */
  16          //#include "TW88.h"
  17          #include "Printf.h"
   1      =1  #ifndef __PRINTF__
   2      =1  #define __PRINTF__
   3      =1  
   4      =1  #define _outchar(c) while(1) { if( !RS_Xbusy ) { SBUF = c; RS_Xbusy=1; break; } }
   5      =1  #define Putch(c) _outchar(c)
   6      =1  
   7      =1  #ifdef SERIAL
   8      =1  
   9      =1   void Printf ( const char CODE_P *fmt, ... );
  10      =1   void Puts ( CODE_P char *ptr );
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 29  

  11      =1  
  12      =1  #define TW2835Cmd(a)   Puts ( a )
  13      =1  
  14      =1  #else
           =1 
           =1  #undef  DEBUG
           =1  #define Printf(a,b)  //
           =1  #define Puts(a)      //
           =1 
           =1 #endif
  21      =1  
  22      =1  
  23      =1  #ifndef DEBUG
  24      =1  
  25      =1   #define dPuts(a)   //
  26      =1   #define wPuts(a)   //
  27      =1   #define ePuts(a)   //
  28      =1  
  29      =1  #else
           =1 
           =1  void dPrintf( const char CODE_P *fmt, ... );
           =1  void wPrintf( const char CODE_P *fmt, ... );
           =1  void ePrintf( const char CODE_P *fmt, ... );
           =1 
           =1  void dPuts( CODE_P char *ptr );
           =1  void wPuts( CODE_P char *ptr );
           =1  void ePuts( CODE_P char *ptr );
           =1 
           =1 #endif  // DEBUG
  40      =1  
  41      =1  BYTE Getch(void);
  42      =1  BYTE Getche(void);
  43      =1  
  44      =1  
  45      =1  #endif  //__PRINTF__
  18          //#include "KeyRemo.h"
  19          #include "etc_eep.h"
   1      =1  #ifndef __ETC_EEP__
   2      =1  #define __ETC_EEP__
   3      =1  
   4      =1  
   5      =1  ////eeprom.h
   6      =1  
   7      =1  
   8      =1  #define  EEP_Powerflag            0x10   
   9      =1  #define  EEP_CameraVolt           0x11   
  10      =1  
  11      =1  
  12      =1  //=========================================================================
  13      =1  //  EEPROM structure
  14      =1  //  0x00  BYTE  4 'TW88'
  15      =1  #define EEP_FWREV_MAJOR     0x04  //BYTE  1 F/W Rev.-major(Hex) 
  16      =1  #define EEP_FWREV_MINOR     0x05  //BYTE  1 F/W Rev.-minor(Hex)
  17      =1  #define EEP_DEBUGLEVEL      0x06  //BYTE  1 DebugLevel
  18      =1  /*//
  19      =1  #define EEP_AUTODETECT      0x07  //BYTE  1 Flag for Input Auto Detect  -0:Auto, 1:NTSC,....
  20      =1  #define EEP_AUTODETECTTYTE    0x08  //BYTE  1 Type of Auto-detect(will be value of register 0x1d)
  21      =1  //      ---------------------------------------------------------------
  22      =1  #define EEP_WIDEMODE      0x09  //BYTE  1   Wide Mode
  23      =1  
  24      =1  #define EEP_AUTORECOGNITION   0x0a  //BYTE  1 Auto Recognition
  25      =1  #define EEP_VIDEOMODE     0x0b  //BYTE  1   Video Mode
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 30  

  26      =1  
  27      =1  #define EEP_OSDLANG       0x0c  //BYTE  1   OSDLang           // 0
  28      =1  
  29      =1  #define EEP_OSDPOSITIONMODE   0x0d  //BYTE  1 OSD Position Mode
  30      =1  #define EEP_CCD         0x0e  //BYTE  1 Closed Caption- 0: off, 1:on
  31      =1  
  32      =1  #define EEP_INPUTSELECTION    0x0f  //BYTE  1 InputSelection
  33      =1  
  34      =1  //
  35      =1  #define EEP_PC_CONTRAST     0x10
  36      =1  #define EEP_PC_BRIGHT     0x11
  37      =1  
  38      =1  #define EEP_CONTRAST      0x12  //BYTE  1 Contrast 
  39      =1  #define EEP_BRIGHTNESS      0x13  //BYTE  1 Brightness
  40      =1  #define EEP_SATURATION_U    0x14  //BYTE  1 Saturation :U
  41      =1  #define EEP_SATURATION_V    0x15  //BYTE  1 Saturation :V
  42      =1  #define EEP_SHARPNESS     0x16  //BYTE  1 Sharpness 
  43      =1  #define EEP_HUE         0x17  //BYTE  1 Hue                    
  44      =1  
  45      =1  //====================================HS AWT 981001
  46      =1  #define  EEP_AutoMode           0xa0
  47      =1  #define  EEP_IMAGEMode          0xa1
  48      =1  #define  EEP_RearMode           0xa2
  49      =1  #define  EEP_COSDMode           0xa3
  50      =1  #define  EEP_GAUGEMode          0xa4
  51      =1  #define  EEP_CAMAMode           0xa5 
  52      =1  #define  EEP_CAMBMode           0xa6
  53      =1  #define  EEP_CAMCMode           0xa7
  54      =1  #define  EEP_CAMRMode           0xa8
  55      =1  #define  EEP_CAMOutMode         0xa9  
  56      =1  #define  EEP_TimeStep           0xaa
  57      =1  
  58      =1  
  59      =1  
  60      =1  #define  EEP_ONOFFChoice        0xac 
  61      =1  
  62      =1  #define  EEP_PRIORITY           0xad
  63      =1  #define  EEP_JUMPMode           0xae
  64      =1  #define  EEP_NowModeState       0xaf
  65      =1  #define  EEP_SelectMode         0xb0
  66      =1  #define  EEP_PriorityOffSelectMode  0xb1
  67      =1  #define  EEP_AudioRecord    0xb2
  68      =1  
  69      =1  #define  EEP_FirstNumber    0xb3
  70      =1  #define  EEP_SecondNumber   0xb4
  71      =1  #define  EEP_ThridNumber    0xb5
  72      =1  #define  EEP_FourthNumber   0xb6
  73      =1  
  74      =1  #define  EEP_CAMNUMBER     0xb7
  75      =1  #define  EEP_PELCO       0xb8
  76      =1  #define  EEP_Baud_rate     0xb9
  77      =1  #define  EEP_TriggerVGA    0xba
  78      =1  #define  EEP_DVRDisplay    0xbb
  79      =1  #define  EEP_IMAGE_A_Mode    0xbc//andy A1.4 20100113
  80      =1  #define  EEP_IMAGE_B_Mode    0xbd//andy A1.4 20100113
  81      =1  #define  EEP_IMAGE_C_Mode    0xbe//andy A1.4 20100113
  82      =1  
  83      =1  #define  EEP_SDCardDetect    0xbf//andy A1.4 20100113
  84      =1  
  85      =1  
  86      =1  #define  EEP_DELAYCAMA           0xC0 
  87      =1  #define  EEP_DELAYCAMB           0xC1
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 31  

  88      =1  #define  EEP_DELAYCAMC           0xC2
  89      =1  #define  EEP_DELAYCAMR           0xC3
  90      =1  #ifdef USE_CAMD
  91      =1  #define  EEP_DELAYCAMD           0xC4
  92      =1  #endif
  93      =1  //#define  EEP_SelectModeBuf         0xb2
  94      =1  #define  EEP_ReverseMode    0xc5
  95      =1  #define  EEP_JUMPAV_TIMESET 0xc6
  96      =1  
  97      =1  #define EEP_OSD_TYPE    0xc7
  98      =1  #define EEP_OSD_LANGUAGE  0xc8
  99      =1  #define EEP_OSD_BRIGHTNESS  0xc9
 100      =1  #define EEP_OSD_PWR_LINK  0xca
 101      =1  
 102      =1  #if 0
 103      =1  #define  EEP_Resolution     0xc0
 104      =1  #define  EEP_FPS        0xc1
 105      =1  #define  EEP_Quality      0xc2
 106      =1  #define  EEP_RecordMode     0xc3
 107      =1  #define  EEP_RecordLength   0xc4
 108      =1  #define  EEP_PreAlarmLength   0xc5
 109      =1  #define  EEP_PostAlarmLength  0xc6
 110      =1  #endif
 111      =1  //====================================HS AWT 981001
 112      =1  
 113      =1  //
 114      =1  //        ---------------------------------------------------------------
 115      =1  #define EEP_PCAUDIOPVOL   0x37  //BYTE  1   AudioVol
 116      =1  #define EEP_AUDIOPVOL     0x38  //BYTE  1   AudioVol
 117      =1  #define EEP_AUDIOBALANCE    0x39  //BYTE  1   AudioBalance
 118      =1  //
 119      =1  //        ---------------------------------------------------------------
 120      =1  
 121      =1  #define EEP_BLOCKMOVIE      0x40  //BYTE  1 BlockedMovie:Blocked rating for Movie 
 122      =1  #define EEP_BLOCKTV       0x41  //BYTE  1 BlockedTV:Blocked rating for TV     
 123      =1  #define EEP_FVSLD       0x42  //BYTE  6
 124      =1  //                            7    6       4    3    2    1    0
 125      =1  //  FVSLD Level                        ALL   FV(V)   S    L    D    
 126      =1  //  0x43    BYTE    1   TV-Y            X  
 127      =1  //  0x44  BYTE    1   TV-Y7           X    X 
 128      =1  //  0x45  BYTE    1   TV-G            X 
 129      =1  //  0x46  BYTE    1   TV-PG           X       X    X    X    X
 130      =1  //  0x47  BYTE    1   TV-14           X       X    X    X    X 
 131      =1  //  0x48  BYTE    1   TV-MA           X       X    X    X
 132      =1  //
 133      =1  #define EEP_VCHIPPASSWORD   0x49  //BYTE  4   OSDPassword         //Defualt:3366
 134      =1  */
 135      =1  //      ---------------------------------------------------------------
 136      =1  //
 137      =1  //
 138      =1  //  0x61  WORD  2   PanelXRes
 139      =1  //  0x63  WORD  2 PanelYRes
 140      =1  //  0x65  BYTE  1 PanelHsyncMinPulseWidth
 141      =1  //  0x66  BYTE  1 PanelVsyncMinPulseWidth
 142      =1  //  0x67  WORD  2 PanelHminBackPorch
 143      =1  //  0x69  BYTE  1 PanelHsyncPolarity
 144      =1  //  0x6a  BYTE  1 PanelVsyncPolarity
 145      =1  //  0x6b  WORD  2 PanelDotClock
 146      =1  //  0x6d  BYTE  1 PanelPixsPerClock
 147      =1  //  0x6e  BYTE  1 PanelDEonly
 148      =1  //      ---------------------------------------------------------------
 149      =1  //
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 32  

 150      =1  //  0x80  PC Data
 151      =1  //
 152      =1  //      ---------------------------------------------------------------
 153      =1  //
 154      =1  //  0x300 TV Data
 155      =1  //
 156      =1  //  --- NTSC_TV -------------------------------------------------------------
 157      =1  //  CNT_SAVEDAIR      BYTE  1   Total count of saved Air TV Channel.
 158      =1  //  IDX_CURAIR        BYTE  1   Index of Current Air TV Channel
 159      =1  //  CHN_CURAIR        BYTE    1   Current Air TV Channel.
 160      =1  //
 161      =1  //  FIRSTSAVED_AIRCHN   BYTE    1 First saved Air TV channel no (maximum 100)
 162      =1  //  ....
 163      =1  //
 164      =1  //  CNT_SAVEDCABLE      BYTE  1   Total count of saved Cable TV Channel.
 165      =1  //  IDX_CURCABLE      BYTE  1   Index of Current Cable TV Channel
 166      =1  //  CHN_CURCABLE      BYTE    1   Current Cable TV Channel.
 167      =1  //
 168      =1  //  FIRSTSAVED_CABLECHN   BYTE  1 First saved Cable TV channel no (maximum 100)
 169      =1  //
 170      =1  //  --- PAL_TV --------------------------------------------------------------
 171      =1  //  PR_CUR          BYTE  1   Current PR no.
 172      =1  //  FIRST_SAVEDPR     DWORD 4   Freq of PR0.  (TOTAL_PR)
 173      =1  //  FIRST_SAVEDPR+4     DWORD   4   Freq of PR1.
 174      =1  //  .....
 175      =1  //
 176      =1  
 177      =1  
 178      =1  
 179      =1  //
 180      =1  // Offset of EEPROM
 181      =1  //
 182      =1  /*
 183      =1  #define VIDEOCONTRAST   0x18    // for NTSC.(PAL:0x20,SECAM:0x28)
 184      =1  #define VIDEOBRIGHTNESS   0x19
 185      =1  #define VIDEOSATURATION_U 0x1a
 186      =1  #define VIDEOSATURATION_V 0x1b
 187      =1  #define VIDEOHUE      0x1c    // only for NTSC
 188      =1  #define VIDEOSHARPNESS    0x1d
 189      =1  */
 190      =1  /*
 191      =1  #define CCCOLOR   0x52
 192      =1  #define VOLZOOM   0x53
 193      =1  
 194      =1  #define PANELINFO 0x61
 195      =1  
 196      =1  // PAL_TV
 197      =1  #define  PR_CUR         0x301 
 198      =1  #define  FIRST_SAVEDPR      0x308 
 199      =1   #define TVFREQ_HIGH 0 
 200      =1   #define TVFREQ_LOW  1
 201      =1  #ifdef PAL_TV
 202      =1   #define TVFINETUNE  2
 203      =1      // NOT Finetune: 0 , Range: -32 ~ +32
 204      =1   #define TVPRSYSTEM  3  
 205      =1      // bit 7: Add:1 Ereased :0
 206      =1      // 
 207      =1   #define TVCHNAME    4
 208      =1  
 209      =1   #define BYTEPERCHANNEL 9 
 210      =1  #endif
 211      =1  // NTSC_TV
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 33  

 212      =1  #define  EEP_TVInputSel     0x302
 213      =1  #define  CHN_CURAIR       0x303 
 214      =1  #define  FIRSTSAVED_AIRCHN    0x308 
 215      =1  #define  CHN_CURCABLE     0x403 
 216      =1  #define  FIRSTSAVED_CABLECHN  0x408 
 217      =1  #ifdef NTSC_TV
 218      =1   #define TVFINETUNE  0
 219      =1      // NOT Finetune: 0 , Range: -32 ~ +32
 220      =1   #define TVPRSYSTEM  1  
 221      =1      // bit 7: Add:1 Ereased :0
 222      =1      // 
 223      =1   #define BYTEPERCHANNEL 2
 224      =1  #endif
 225      =1  
 226      =1  */
 227      =1  
 228      =1  
 229      =1  WORD GetFWRevEE(void);
 230      =1  void SaveFWRevEE(WORD);
 231      =1  
 232      =1  BYTE GetDebugLevelEE(void);
 233      =1  void SaveDebugLevelEE(BYTE);
 234      =1  
 235      =1  #if 0//def WIDE_SCREEN
           =1 BYTE GetWideModeEE(void);
           =1 void SaveWideModeEE(BYTE dl);
           =1 #endif
 239      =1  
 240      =1  /*
 241      =1  //BYTE GetRange4CoarseEE(void);
 242      =1  //void SaveRange4CoarseEE(BYTE);
 243      =1  
 244      =1  BYTE GetPossibleAutoDetectStdEE(void);
 245      =1  void SetPossibleAutoDetectStdEE(void);
 246      =1  
 247      =1  //BYTE GetOSDXPositionEE(void);
 248      =1  //BYTE GetOSDYPositionEE(void);
 249      =1  BYTE GetClosedCaptionFlagEE(void);
 250      =1  
 251      =1  BYTE GetVideoDatafromEE(BYTE);
 252      =1  void SaveVideoDatatoEE(BYTE offset, BYTE ndata);
 253      =1  
 254      =1  //BYTE GetVideoBrightnessEE(void);
 255      =1  //BYTE GetVideoSaturationEE(BYTE);
 256      =1  //BYTE GetVideoHueEE(void);
 257      =1  //BYTE GetVideoSharpnessEE(void);
 258      =1  
 259      =1  //void SaveVideoContrastEE(BYTE ndata);
 260      =1  //void SaveVideoBrightnessEE(BYTE ndata);
 261      =1  //void SaveVideoSaturationEE(BYTE, BYTE ndata);
 262      =1  //void SaveVideoHueEE(BYTE ndata);
 263      =1  //void SaveVideoSharpnessEE(BYTE ndata);
 264      =1  
 265      =1  BYTE GetOSDPositionModeEE(void);
 266      =1  void SaveOSDPositionModeEE(BYTE ndata);
 267      =1  //void SaveOSDXPositionEE(BYTE);
 268      =1  //void SaveOSDYPositionEE(BYTE);
 269      =1  
 270      =1  void SaveClosedCaptionFlagEE(BYTE);
 271      =1  
 272      =1  BYTE GetBlockedTVEE(void);      
 273      =1  void SaveBlockedTVEE(BYTE vi);    
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 34  

 274      =1  BYTE GetBlockedTV_FLDSLEE( BYTE level ) ;
 275      =1  void SaveBlockedTV_FLDSLEE(BYTE level, BYTE vi) ;
 276      =1  
 277      =1  BYTE GetBlockedMovieEE(void);   
 278      =1  void SaveBlockedMovieEE(BYTE vi); 
 279      =1  #if 0
 280      =1  BYTE GetInputSelectionEE(void);
 281      =1  #endif
 282      =1  void SaveInputSelectionEE(BYTE val);
 283      =1  
 284      =1  //BYTE GetOSDDurationEE(void);
 285      =1  //void SaveOSDDurationEE(BYTE val);
 286      =1  
 287      =1  BYTE GetOSDLangEE(void);
 288      =1  void SaveOSDLangEE(BYTE val);
 289      =1  
 290      =1  //ljy100303...BYTE GetOSDZoomEE(void);
 291      =1  //ljy100303...void SaveOSDZoomEE(BYTE val);
 292      =1  
 293      =1  BYTE GetAudioVolEE(void);
 294      =1  void SetAudioVolEE( BYTE vol );
 295      =1  BYTE GetPCAudioVolEE(void);
 296      =1  void SetPCAudioVolEE( BYTE vol );
 297      =1  */
 298      =1  #if 0
           =1 BYTE GetAudioBalanceEE(void);
           =1 void SetAudioBalanceEE( BYTE vol );
           =1 BYTE GetAudioBassEE(void);
           =1 void SetAudioBassEE( BYTE vol );
           =1 BYTE GetAudioTrebleEE(void);
           =1 void SetAudioTrebleEE( BYTE vol );
           =1 #endif
 306      =1  //BYTE GetAudioEffectEE(void);
 307      =1  //void SetAudioEffectEE( BYTE vol );
 308      =1  
 309      =1  void ClearBasicEE(void);
 310      =1  /*
 311      =1  BYTE ValidPassword(DATA_P BYTE *numstr, BYTE index);
 312      =1  BYTE SetNewPassword(DATA_P BYTE *numstr, BYTE index);
 313      =1  */
 314      =1  //WORD GetPanelXRes(void);
 315      =1  //WORD GetPanelYRes(void);
 316      =1  /*
 317      =1  BYTE GetPanelHsyncMinPulseWidth(void);
 318      =1  BYTE GetPanelVsyncMinPulseWidth(void);
 319      =1  WORD GetPanelHMinBackPorch(void);
 320      =1  BYTE GetPanelHsyncPolarity(void);
 321      =1  BYTE GetPanelVsyncPolarity(void);
 322      =1  WORD GetPanelDotClock(void);
 323      =1  WORD GetPanelMaxClock(void);
 324      =1  BYTE GetPanelPixsPerClock(void);
 325      =1  // Not used yet *************************  BYTE GetPanelDEonly(void);
 326      =1  
 327      =1  void AddTVChannelEE( BYTE tvtype, BYTE chn);
 328      =1  BYTE GetTVChannelEE( BYTE tvtype, BYTE inx);
 329      =1  void ResetTVChannelEE( BYTE tvtype );
 330      =1  BYTE GetTVChannelCntEE(BYTE tvtype);
 331      =1  BYTE GetTVChnIdxEE(BYTE tvtype);
 332      =1  BYTE GetCurTVChannelEE(BYTE tvtype);
 333      =1  void SetTVChnIdxEE(BYTE tvtype, BYTE newd);
 334      =1  void SetCurTVChannelEE(BYTE tvtype, BYTE newd);
 335      =1  BYTE InsertTVChannelEE(BYTE tvtype, BYTE newd);
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 35  

 336      =1  BYTE RemoveTVChannelEE(BYTE tvtype, BYTE newd);
 337      =1  
 338      =1  void SetTVPrEE(void);
 339      =1  BYTE GetTVPrEE(void);
 340      =1  void SetTVFreqEE(BYTE, WORD);
 341      =1  WORD GetTVFreqEE(BYTE);
 342      =1  void SetFineTuneEE(BYTE, BYTE);
 343      =1  BYTE GetFineTuneEE(BYTE);
 344      =1  BYTE GetTVPrSystem(BYTE);
 345      =1  void SetTVPrSystem(BYTE, BYTE);
 346      =1  BYTE GetTVInputSelEE(void);
 347      =1  void SetTVInputSelEE(BYTE);
 348      =1  */
 349      =1  /*
 350      =1  #define GetVInputStdDetectModeEE()        ReadEEP(EEP_AUTODETECTTYTE)
 351      =1  #define SaveVInputStdDetectModeEE(A)      WriteEEP(EEP_AUTODETECTTYTE, A)
 352      =1  
 353      =1  #define GetAutoRecogntionEE()         ReadEEP(EEP_AUTORECOGNITION)
 354      =1  #define SaveAutoRecogntionEE(A)         WriteEEP(EEP_AUTORECOGNITION, A)
 355      =1  
 356      =1  #define SetVideoModeEE( ctid )          WriteEEP( EEP_VIDEOMODE, ctid )
 357      =1  #define GetVideoModeEE()            ReadEEP( EEP_VIDEOMODE )
 358      =1  
 359      =1  #define GetPanelContrastEE()          ReadEEP(0x10)
 360      =1  
 361      =1  #if defined( SUPPORT_PC ) || defined( SUPPORT_DTV )
 362      =1  //#define GetPanelHueEE()             ReadEEP(0x28)
 363      =1  //#define GetPanelSharpnessEE()         ReadEEP(0x29)
 364      =1  #define GetPanelBrightnessEE()          ReadEEP(0x11)
 365      =1  //#define GetPanelSaturationEE()          ReadEEP(0x2a)
 366      =1  
 367      =1  //#define SavePanelHueEE(A)           WriteEEP(0x28, A)
 368      =1  //#define SavePanelSharpnessEE(A)         WriteEEP(0x29, A)
 369      =1  #define SavePanelContrastEE(A)          WriteEEP(0x10, A)
 370      =1  #define SavePanelBrightnessEE(A)        WriteEEP(0x11, A)
 371      =1  //#define SavePanelSaturationEE(A)        WriteEEP(0x2a, A)
 372      =1  #endif
 373      =1  */
 374      =1  /*
 375      =1  #define GetDigitalVideoContrastEE()       ReadEEP(0x2b)
 376      =1  #define GetDigitalVideoBrightnessEE()     ReadEEP(0x2c)
 377      =1  #define GetDigitalVideoHueEE()          ReadEEP(0x2d)
 378      =1  #define GetDigitalVideoSaturationEE(off)    ReadEEP(0x2e+off)
 379      =1  
 380      =1  #define SaveDigitalVideoContrastEE(A)     WriteEEP(0x2b, A)
 381      =1  #define SaveDigitalVideoBrightnessEE(A)     WriteEEP(0x2c, A)
 382      =1  #define SaveDigitalVideoHueEE(A)        WriteEEP(0x2d, A)
 383      =1  #define SaveDigitalVideoSaturationEE(off,A)   WriteEEP(0x2e+off, A)
 384      =1  */
 385      =1  
 386      =1  #endif  // __ETC_EEP__
  20          //#include "pc_eep.h"
  21          //#include "Audio.h"
  22          //#include "Measure.h"
  23          //#include "OSDBasic.h"
  24          //#include "OSDMenu.h"
  25          //#include "DispInfo.h"
  26          //#include "Monitor.h"
  27          //#include "variables.h"
  28          #include <math.h>
   1      =1  /*--------------------------------------------------------------------------
   2      =1  MATH.H
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 36  

   3      =1  
   4      =1  Prototypes for mathematic functions.
   5      =1  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =1  Copyright (c) 2008-2016 ARM Germany GmbH
   7      =1  All rights reserved.
   8      =1  --------------------------------------------------------------------------*/
   9      =1  
  10      =1  #ifndef __MATH_H__
  11      =1  #define __MATH_H__
  12      =1  
  13      =1  #if defined __CX2__ && (__CX2__ >= 558 || __CX2__ == 556 && __CX2_MINOR__ >= 207)
           =1 #ifndef HUGE_VAL
           =1 #define HUGE_VAL __inf__
           =1 #endif // HUGE_VAL
           =1 
           =1 #ifndef NAN
           =1 #define NAN __nan__
           =1 #endif // NAN
           =1 
           =1 #pragma SAVE
           =1 #pragma FUNCTIONS(STATIC)
           =1 /* intrinsic functions are reentrant, but need static attribute */
           =1 extern int    abs  (int   val);
           =1 #pragma RESTORE
           =1 #endif
  28      =1  
  29      =1  #pragma SAVE
  30      =1  #pragma REGPARMS
  31      =1  #if !defined (__CX2__)
  32      =1  extern char  cabs  (char  val);
  33      =1  extern int    abs  (int   val);
  34      =1  extern long  labs  (long  val);
  35      =1  #endif
  36      =1  
  37      =1  extern float fabs  (float val);
  38      =1  extern float sqrt  (float val);
  39      =1  extern float exp   (float val);
  40      =1  extern float log   (float val);
  41      =1  extern float log10 (float val);
  42      =1  extern float sin   (float val);
  43      =1  extern float cos   (float val);
  44      =1  extern float tan   (float val);
  45      =1  extern float asin  (float val);
  46      =1  extern float acos  (float val);
  47      =1  extern float atan  (float val);
  48      =1  extern float sinh  (float val);
  49      =1  extern float cosh  (float val);
  50      =1  extern float tanh  (float val);
  51      =1  extern float atan2 (float y, float x);
  52      =1  
  53      =1  extern float ceil  (float val);
  54      =1  extern float floor (float val);
  55      =1  extern float modf  (float val, float *n);
  56      =1  extern float fmod  (float x, float y);
  57      =1  extern float pow   (float x, float y);
  58      =1  
  59      =1  #if defined (__CX2__)
           =1 extern float frexp (float val, int *exp);
           =1 extern float ldexp (float val, int exp);
           =1 #endif
  63      =1  
  64      =1  #pragma RESTORE
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 37  

  65      =1  
  66      =1  #endif
  29          #include "main.h"
   1      =1  #ifndef __MAIN__
           =1 #define __MAIN__
           =1 
           =1 #define ON          1
           =1 #define OFF         0
           =1 #define Hs_debug
           =1 //#define DVR
           =1 #define Format_SDCard
           =1 #define BJTSwitch
           =1 
           =1 
           =1 
           =1 #define Panel_Enable()          P4=P4|0x08 //andy 980908
           =1 #define Panel_Disable()     P4=P4&0xf7
           =1 
           =1 #if 0
           =1 #define SetBacklight()      P4=P4|0x04
           =1 #define clrBacklight()      P4=P4&0xfb
           =1 #else
           =1 #define SetBacklight()      P4=P4&0xfb
           =1 #define clrBacklight()       P4=P4|0x04
           =1 #endif
           =1 /*
           =1 #define COLUMN1_PIN   P2_3
           =1 #define COLUMN2_PIN   P2_4
           =1 #define COLUMN3_PIN   P2_5
           =1 */
           =1 
           =1 //InputSelection
           =1 /*
           =1 struct struct_IdName {
           =1   BYTE  Id;
           =1   BYTE  Name[16];
           =1 };
           =1 /*
           =1 
           =1 #define CH_TW2835              1
           =1 #define CH_CAMD                2
           =1 #define CH_AV                  3
           =1 #define PC             7
           =1 #define ChineseDefaultMenu   8
           =1 
           =1 #define SVIDEO        2
           =1 #define COMPONENT     3
           =1 //#define ANALOGDTV     4
           =1 #define DTV         4
           =1 #define TV          5
           =1 #define SCART       6
           =1 
           =1 #define DIGITALVGA      8
           =1 
           =1 #define AIRTV       0 //9
           =1 #define CABLETV       1 //0xa
           =1 
           =1 
           =1 #define TVTUNER       0xd   //10
           =1 #define MUTE        1 
           =1 #define MENU        2 
           =1 #define TVVOL       4 
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 38  

           =1 #define CC          8 
           =1 #define INPUTINFO     0x10
           =1 #define PCINFO        0x20
           =1 #define GAUGEINFO           0x40
           =1 //#define RATINGINFO      0x40
           =1 #define TVCHN       0x80
           =1 //#define MUTE        0x40
           =1 
           =1 #define YPBPR_480i      0
           =1 #define YPBPR_576i      1
           =1 #define YPBPR_480p      2
           =1 #define YPBPR_576p      3
           =1 #define YPBPR_1080i     4
           =1 #define YPBPR_720p      5
           =1 #define YPBPR_720p50    6
           =1 */
           =1 
           =1 #define _STOP_PWM     0x00
           =1 #define _RUN_PWM    0xFF
           =1 #define _BL_PWM     0x14
           =1 #define _CHG_CURR   0x15
           =1 
           =1 //ADC
           =1 #define P16_BTH   6  //P1.6
           =1 #define P17_BAT   7  //P1.7
           =1 
           =1 
           =1 
           =1 //--------------------------- P0 Define -----------------------------
           =1 //#define SEL_MIX     P0_6  // 
           =1 //--------------------------- P1 Define -----------------------------
           =1 //#define SEL_DVI     P3_5  //LJY062001   
           =1 
           =1 #define TW88HWReset     P3_4  //LJY001010 //LJY000721
           =1 #define PowerUp             P3_7
           =1 #define LBEN P1_6
           =1 //======================= CDS Control ================================= 
           =1 //#define CDS_CTRL           P1_5
           =1 /*
           =1 extern BYTE SelectModeType;
           =1 extern BYTE InputSelection;
           =1 extern BYTE SEQTime;
           =1 extern BYTE Priority;
           =1 extern BYTE PowerFlag;
           =1 //extern bit AutoDayNight;
           =1 extern bit SDCardCoverDetect;
           =1 */
           =1 BYTE keyIn(void);
           =1 void TimerForRemocon(void);
           =1 void TimerForTick(void);
           =1 void DisableRemoconInt(void);
           =1 BYTE SetSupport_remocon(BYTE newd);
           =1 
           =1 void delay(BYTE cnt);
           =1 
           =1 BYTE RS_ready(void);
           =1 #ifdef Hs_debug
           =1 BYTE RS_rx(void);
           =1 #endif
           =1 void RS_tx(BYTE tx_buf);
           =1 
           =1 BYTE RS2_rx(void);
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 39  

           =1 void RS2_tx(BYTE tx_buf);
           =1 
           =1 //void NewLine(void);
           =1 //void PutsP(PDATA_P BYTE *ptr);
           =1 #ifdef Hs_debug
           =1 //void MonWriteI2C(BYTE addr, BYTE index, BYTE val);
           =1 //BYTE MonReadI2C(BYTE addr, BYTE index);
           =1 #endif
           =1 BYTE Asc1Bin(BYTE asc);
           =1 BYTE Asc2Bin(PDATA_P BYTE *s);
           =1 
           =1 //void I2CDeviceInitialize( CODE_P BYTE *RegSet);
           =1 
           =1 //void RestartSystemClock(WORD clock_hm);
           =1 //WORD GetTime_ms(void);
           =1 #if 0
           =1 BYTE GetTime_H(void);
           =1 BYTE GetTime_M(void);
           =1 #endif
           =1 //void ChangeTime_H( char add );
           =1 //void ChangeTime_M( char add );
           =1 //WORD GetWakeupTime(void);
           =1 //void SetWakeupTime(WORD wtime);
           =1 
           =1 
           =1 //WORD GetOffTime(void);
           =1 //void SetOffTime(WORD wtime);
           =1 //BYTE GetSleepTimer(void);
           =1 //void SetSleepTimer(BYTE stime);
           =1 /*
           =1 WORD DiffTime_ms( WORD stime, WORD etime );
           =1 //void SetLastBlockedTime(void);
           =1 void SetLastCCTime(void);       //ljy010904...CC_FIX_CLEAR_ON_TIME
           =1 
           =1 void SetOSDLastKeyInTime(void);
           =1 WORD GetOSDLastKeyInTime(void);
           =1 WORD GetIVF(void);
           =1 DWORD GetIHF(void);
           =1 BYTE ReadVInputSTD(void);
           =1 void SetVInputStd(BYTE newd);
           =1 BYTE GetVInputStd(void);
           =1 BYTE GetInputSelection(void);
           =1 #ifdef ADD_ANALOGPANEL
           =1 BYTE IsAnalogOn(void);
           =1 #endif
           =1 void InitVideoData(BYTE src);
           =1 void ChangeVInputStdDetectMode(BYTE val);
           =1 BYTE GetVInputStdInx(void);
           =1 
           =1 void MonWriteI2Cn_(BYTE addr, BYTE *val, BYTE cnt) ;
           =1 */
           =1 ///void Usage(void);
           =1 #ifdef Hs_debug
           =1   void Prompt(void);
           =1 #endif
           =1 /*
           =1 void DebugKeyIn(BYTE ikey);
           =1 void DVIPowerDown(bit flag);
           =1 void PowerDown_XTAL(bit flag);
           =1 */
           =1 //void ChangeInput(BYTE newsel);
           =1 
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 40  

           =1 
           =1 void WaitPowerOn(void);
           =1 //void PowerOff(void);
           =1 //BYTE GetNextInputSelection(void);
           =1 
           =1 //BYTE WantToStopTVScan(void);
           =1 
           =1 //BYTE IsTW8801(void);
           =1 //BYTE IsTW8803(void);
           =1 //BYTE ConvertVideoVSAT(BYTE reg);
           =1 
           =1 //BYTE IsNoInput(void);
           =1 void LoadEEPROM (void);
           =1 void Hs_InitVars(void);
           =1 /*
           =1 void AdjustAutoDayNight(BYTE val);
           =1 void ACCPowerControl(void);
           =1 void AdjustBacklight(BYTE val);//val=0~110
           =1 */
           =1 BYTE mcuLib_ProtocolAppend(BYTE *pucBuf, BYTE* piLen, BYTE ucByte);
           =1 BYTE mcuLib_ProtocolSendCmdWithParamNum(BYTE ucType, BYTE* pucParam, BYTE ucSize);
           =1 void MCU_SendCmdToDVR(BYTE ucType);
           =1 void SetAD5110Step(BYTE newv) ;
           =1 
           =1 
           =1 
           =1 extern BYTE ScanPowerkey(void);
           =1 extern void MCUTimerInitialTimerEvent(void);
           =1 extern void MCUTimerActiveTimerEvent(WORD usTime, BYTE ucEventID);
           =1 extern void SysTimerHandler(void);
           =1 extern void SysJudgeHandler(void);
           =1 extern void SysModeHandler(void);
           =1 extern void SysPowerHandler(void);
           =1 
           =1 extern void MCUTimerDelayXms(WORD usNum);
           =1 
           =1 
           =1 struct RegisterInfo
           =1 {
           =1    int  Min;
           =1    int  Max;
           =1    int  Default;
           =1 };
           =1 struct LongRegisterInfo
           =1 {
           =1    WORD Min;
           =1    WORD Max;
           =1    WORD Default;
           =1 };
           =1 
           =1 
           =1 
           =1 
           =1 #endif  // __MAIN__
  30          
  31          //#include "HS_DisplayOSD.h"
  32          //#include "HS_IOdef.h"
  33          
  34          //#define ClearRemoTimer()  TR2 = 0
  35          
  36          
  37          
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 41  

  38          extern WORD g_usTimerCounter ;  
  39          
  40          extern StructPowerInfoType idata g_stPowerInfo;
  41          
  42          extern      BYTE  DebugLevel;
  43          /*
  44          #ifdef REMO_RC5
  45          extern  BYTE RemoDataReady;
  46          #endif
  47          extern  BYTE RemoSystemCode, RemoDataCode;
  48          extern  BYTE InputSelection;
  49          extern      BYTE  VInputStdDetectMode;
  50          extern  BYTE  VInputStd;
  51          
  52          extern  BYTE OSD_Ready_Flag,Ready_Flag,PowerFlag;
  53          
  54          extern  BYTE  PcMode;
  55          //extern      bit AutoDetect;
  56          extern      bit NoInitAccess;
  57          extern  BYTE  DVR_RecordStatus;
  58          
  59          extern BYTE FWUPDATE_FLAG;
  60          
  61          */
  62            extern bit g_bNotifyTimer0Int;
  63          
  64          //===================== Timer =================================================
  65              DATA BYTE keytic=0;
  66              DATA BYTE Key=0;
  67              bit KeyReady=0, RepeatKey = 0;
  68          
  69              DATA BYTE tm001;
  70              DATA  WORD  stopWatch;
  71              DATA  WORD  tm01=0;
  72              DATA  BYTE  tic01=0,tic02=0;  //, tic_pc;
  73              DATA  WORD  tic_pc=0;
  74              DATA  DWORD tic_PWR_SAVING=0;
  75              DATA  DWORD tic_Init_time=0;
  76             volatile bit PWR_SAVING_ACT_FLAG=0;
  77              extern BYTE Power_Saving_Flag;
  78              extern bit PWR_OFF_KEY_LOCK;
  79              DATA DWORD  SystemClock;      //00:00
  80            //#ifdef Format_SDCard  
  81              BYTE FormatSDCard=1;
  82            //#endif
  83          //    xdata DWORD LastBlockedTime;    //00:00
  84          //static  DATA WORD WakeupTime;
  85          //static  DATA BYTE WakeupPR;
  86          
  87          //     WORD OffTime;   
  88          //     BYTE SleepTimer;
  89          //     WORD SleepTime;
  90          #if 0//def CHIP_MANUAL_TEST //==============================================================
              extern  BYTE ManualFrequency;
              extern  bit   OnChipTest;
              #endif      //==============================================================
  94          
  95          #ifdef SERIAL //=======================================================================
  96          
  97          
  98          
  99          
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 42  

 100          static  DATA BYTE RS_buf[BUF_MAX];
 101                    DATA BYTE     RS_buf2[BUF_MAX];
 102              DATA BYTE DVR_buf[DVR_BUF_MAX];
 103          
 104              
 105              DATA BYTE   RS_in, RS_out=0;
 106              DATA BYTE   RS2_in;
 107              bit         RS_Xbusy=0;     // bit RS_Xbusy=0;
 108              bit     RS2_Xbusy=0;    // bit RS_Xbusy=0;
 109              
 110          
 111          #endif  // SERIAL ======================================================================
 112          //================== Remocon ==================================================
 113          #if 0///def REMO_RC5
              
              static  bit         RemoPhase1, RemoPhase2;
                IDATA BYTE  RemoDataReady=0;
                IDATA BYTE  RemoSystemCode, RemoDataCode;
              
              //#elif defined REMO_NEC
              
              static  bit         RemoPhase=0;
              static  IDATA BYTE  RemoStep=0;
              static  IDATA BYTE  RemoHcnt, RemoLcnt;
                  IDATA BYTE   RemoData[4];
                    IDATA BYTE  RemoDataReady=0;
              static  IDATA BYTE  RemoNum, RemoBit;
              
                    IDATA BYTE  RemoDataCode=0xff;
              #endif  //================== Remocon ======================
 130          
 131          BYTE  keyticSec=0;
 132          BYTE  FormatWait=0;
 133          BYTE  PowerDownWait=0;
 134          BYTE  updn_reg[4]={0,0,0,0};
 135          
 136          bit ChangeKey;
 137          BYTE Time5ms;
 138          BYTE FLASH_FLAG;
 139          WORD LED_FLASH_COUNT,Power_Msg_Count;
 140          short EncorderCount=0;
 141          // extern bit   FormatStart;
 142          //extern bit   PowerDownStart;
 143          extern BYTE   KeyBuffer;
 144          //extern BYTE year1,year2,month,day,hour,minute,second;
 145          /*
 146          
 147          extern BYTE lock_keycnt;
 148          extern BYTE DVR_SDCardAvailable;
 149          #ifndef QUAD
 150          extern BYTE displayhold_flag;
 151          #endif
 152          extern bit Power_On_Display_Msg_Flag;
 153          */
 154          //====================HS 2835Command================ Andy AWT 980928
 155          /*
 156          code unsigned char *CommTable[] = { 
 157              {"hscom 1 1 ch0:1%1bx ch1:0%1bx ch2:0%1bx ch3:0%1bx\n\r"},        // INDEX_ID=0x00 CAM A
 158              {"hscom 1 1 ch1:1%1bx ch0:0%1bx ch2:0%1bx ch3:0%1bx\n\r"},        // INDEX_ID=0x01 CAM B
 159              {"hscom 1 1 ch2:1%1bx ch0:0%1bx ch1:0%1bx ch3:0%1bx\n\r"},        // INDEX_ID=0x02 CAM C
 160              {"hscom 1 1 ch3:1%1bx ch0:0%1bx ch1:0%1bx ch2:0%1bx\n\r"},        // INDEX_ID=0x03 CAM R
 161              {"hscom 2 2 ch0:1%1bx ch1:0%1bx ch2:0%1bx ch3:0%1bx\n\r"},        // INDEX_ID=0x04 CAM A+B
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 43  

 162              {"hscom 2 2 ch2:0%1bx ch3:1%1bx ch0:0%1bx ch1:0%1bx\n\r"},        // INDEX_ID=0x05 CAM C+R
 163              {"hscom 2 2 ch0:0%1bx ch3:1%1bx ch1:0%1bx ch2:0%1bx\n\r"},        // INDEX_ID=0x06 CAM A+R
 164              {"hscom 2 2 ch3:1%1bx ch1:0%1bx ch0:0%1bx ch2:0%1bx\n\r"},        // INDEX_ID=0x07 CAM R+B
 165              {"hscom 3 1 ch3:1%1bx ch0:0%1bx ch1:0%1bx ch2:0%1bx\n\r"},        // INDEX_ID=0x08 CAM R+A+B T1
 166              {"hscom 3 3 ch0:0%1bx ch1:0%1bx ch3:1%1bx ch2:0%1bx\n\r"},        // INDEX_ID=0x09 CAM A+B+R T3
 167              {"hscom 3 4 ch0:0%1bx ch1:0%1bx ch3:1%1bx ch2:0%1bx\n\r"},        // INDEX_ID=0x0A CAM A+B+R T4
 168              {"hscom 4 1 ch0:0%1bx ch1:0%1bx ch2:0%1bx ch3:1%1bx\n\r"},        // INDEX_ID=0x0B CAM A+B+C+R
 169              {"hscom 2 2 ch0:1%1bx ch2:0%1bx ch1:0%1bx ch3:0%1bx\n\r"},        // INDEX_ID=0x0C CAM A+C
 170              {"hscom 2 2 ch2:1%1bx ch1:0%1bx ch0:0%1bx ch3:0%1bx\n\r"},        // INDEX_ID=0x0D CAM C+B  
 171              {"hscom 3 3 ch3:1%1bx ch0:0%1bx ch1:0%1bx ch2:0%1bx\n\r"},         // INDEX_ID=0x0E CAM R+AB //Ryan
 172          
 173            //Andy A1.4 2009 1 12 
 174              {"hscom 2 2 ch3:1%1bx ch2:0%1bx ch1:0%1bx ch0:0%1bx\n\r"},        // INDEX_ID=0x0F CAM R+C
 175              {"hscom 3 1 ch3:1%1bx ch0:0%1bx ch2:0%1bx ch1:0%1bx\n\r"},        // INDEX_ID=0x10 CAM R+A+C T1
 176              {"hscom 3 1 ch3:1%1bx ch1:0%1bx ch2:0%1bx ch0:0%1bx\n\r"},        // INDEX_ID=0x11 CAM R+B+C T1
 177              {"hscom 3 3 ch3:1%1bx ch0:0%1bx ch2:0%1bx ch1:0%1bx\n\r"},        // INDEX_ID=0x12 CAM R+AC T3
 178              {"hscom 3 3 ch3:1%1bx ch1:0%1bx ch2:0%1bx ch0:0%1bx\n\r"},         // INDEX_ID=0x13 CAM R+BC T3
 179            //Andy A1.4 2009 1 13 
 180              {"hscom 3 3 ch0:1%1bx ch1:0%1bx ch2:0%1bx ch3:0%1bx\n\r"},        // INDEX_ID=0x14 CAM A+B+C T3
 181              {"hscom 3 3 ch0:0%1bx ch2:0%1bx ch3:1%1bx ch1:0%1bx\n\r"},        // INDEX_ID=0x15 CAM A+C+R T3
 182            //Andy A1.4 2009 1 13 
 183              {"hscom 2 2 ch1:1%1bx ch0:0%1bx ch2:0%1bx ch3:0%1bx\n\r"},        // INDEX_ID=0x16 CAM B+A
 184              {"hscom 2 2 ch1:1%1bx ch2:0%1bx ch3:0%1bx ch0:0%1bx\n\r"},        // INDEX_ID=0x17 CAM B+C
 185              {"hscom 2 2 ch1:0%1bx ch3:1%1bx ch2:0%1bx ch0:0%1bx\n\r"},        // INDEX_ID=0x18 CAM B+R
 186              {"hscom 3 3 ch1:1%1bx ch0:0%1bx ch2:0%1bx ch3:0%1bx\n\r"},        // INDEX_ID=0x19 CAM B+A+C T3
 187              {"hscom 3 3 ch1:0%1bx ch0:0%1bx ch3:1%1bx ch2:0%1bx\n\r"},        // INDEX_ID=0x1A CAM B+A+R T3
 188              {"hscom 3 3 ch1:0%1bx ch2:0%1bx ch3:1%1bx ch0:0%1bx\n\r"},        // INDEX_ID=0x1B CAM B+C+R T3
 189            //Andy A1.4 2009 1 13 //C trigger    
 190              {"hscom 2 2 ch2:1%1bx ch0:0%1bx ch1:0%1bx ch3:0%1bx\n\r"},        // INDEX_ID=0x1C CAM C+A
 191              {"hscom 2 2 ch2:1%1bx ch1:0%1bx ch3:0%1bx ch0:0%1bx\n\r"},        // INDEX_ID=0x1D CAM C+B
 192              {"hscom 2 2 ch2:0%1bx ch3:1%1bx ch1:0%1bx ch0:0%1bx\n\r"},        // INDEX_ID=0x1E CAM C+R
 193              {"hscom 3 3 ch2:1%1bx ch0:0%1bx ch1:0%1bx ch3:0%1bx\n\r"},        // INDEX_ID=0x1F CAM C+A+B T3
 194              {"hscom 3 3 ch2:0%1bx ch0:0%1bx ch3:1%1bx ch1:0%1bx\n\r"},        // INDEX_ID=0x20 CAM C+A+R T3
 195              {"hscom 3 3 ch2:0%1bx ch1:0%1bx ch3:1%1bx ch0:0%1bx\n\r"},        // INDEX_ID=0x21 CAM C+B+R T3
 196          };
 197          //=========================End===================
 198          
 199          */
 200          
 201          
 202          /*
 203          CODE BYTE PanelInfoStr[]={
 204          #if (defined UXGA)            // 1600 x 1200
 205            "---> Panel: UXGA-1600*1200"
 206          #elif (defined SXGA)              // 1280 x 1024
 207            "---> Panel: SXGA-1280*1024"
 208          #elif (defined  XGA)              // 1024 x 768
 209            "---> Panel: XGA-1024*768"
 210          #elif (defined SVGA)            //  800 x 600
 211            "---> Panel: SVGA-800*600"
 212          #elif (defined VGA)             //  640 x 480
 213            "---> Panel: VGA-640*480"
 214          #elif (defined WXGA)            // 1280 x 768 (15:9) // 1366 x 768 (16:9)
 215            "---> Panel: WXGA-1280*768(15:9) or 1366*768(16:9)"
 216          #elif (defined WSVGA)           // 1024 x 600 *** only video mode
 217            "---> Panel: WSVGA-1024*600"
 218          #elif (defined WVGA)            //  800 x 480
 219            #ifdef AU_10INCH
 220            "---> Panel: WVGA-800*480 -- TTL AU 10inch"
 221            #elif (defined SAMSUNG_10INCH)
 222            "---> Panel: WVGA-800*480 -- TTL SAMSUNG 10inch"
 223            #elif (defined SAMSUNG_TICONLESS_10INCH)
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 44  

 224            "---> Panel: WVGA-800*480 -- TICONLESS SAMSUNG 10inch"
 225            #elif (defined SHARP_TICONLESS_7INCH)
 226            "---> Panel: WVGA-800*480 -- TICONLESS SHARP 7inch"
 227            #elif (defined AU_TICONLESS_7INCH)
 228            "---> Panel: WVGA-800*480 -- TICONLESS AU 7inch"
 229            #elif (defined HSD070IDW1_7INCH)
 230            "---> Panel: WVGA-800*480 -- TICONLESS HS 7inch"
 231            #elif (defined AU_TICONLESS_10INCH)
 232            "---> Panel: WVGA-800*480 -- TICONLESS AU 10inch"
 233            #elif defined HITACHI_T01
 234            "---> Panel: WVGA-800*480 -- TICONLESS Hitachi TX18D24VM2BAA"
 235            #elif defined HITACHI_TX23D12
 236            "---> Panel: WVGA-800*480 -- TICONLESS Hitachi TX23D12"
 237            #elif defined HITACHI_TX18D24
 238            "---> Panel: WVGA-800*480 -- TICONLESS Hitachi TX18D24"
 239            #else
 240            "---> Panel: WVGA-800*480"
 241            #endif
 242          #elif (defined HVGA)            //  480 x 320
 243            "---> Panel: HVGA-480*320"
 244          #elif (defined QVGA)            //  320 x 240 *** only video mode
 245            "---> Panel: QVGA-320*240"
 246          #elif (defined WQVGA)           //  480 x 234 *** only video mode
 247              #ifdef ANALOG_7INCH
 248            "---> Panel: WQVGA-480*234 -- ANALOG TICONLESS AU 7inch"
 249            #elif (defined SHARP_LQ043T3DX02)
 250            "---> Panel: WQVGA-480*234 -- TTL SHARP LED 4.3inch panel"
 251            #else
 252            "---> Panel: WQVGA-480*234 "
 253            #endif
 254          #endif
 255          };
 256          */
 257          #if 0//def ADD_ANALOGPANEL    // Added Analog panel(AU7") from default set panel(expect WQVGA) with DIP #1 s
             -witch.(DIP#1=L:ANALOG, H:DEFAULT)
              CODE BYTE AddedAnalogPanelStr[]={
                  #ifdef ADD_ANALOG_7INCH
                "---> Added Analog Panel(AU 7inch) with DIP SW1=Enabled"
                  #elif defined ADD_TMD_LTA05B352A
                "---> Added Analog Panel(TMD 4inch) with DIP SW1=Enabled"
                  #endif
              };
              #endif
 266          
 267          
 268          
 269          #if 0   //william-981029
              //=============================================================================
              //                            CheckSpecialMode                                                   
              //=============================================================================
              void CheckSpecialMode(void)
              {
                BYTE i;
              
                i = GetKey(0);
              
                switch( i ) {
                case MENUKEY:
                  Puts("\r\n---- Menu Key is pressed -> Enter Special Mode( To Composite )");
                  SaveInputSelectionEE(CH_TW2835);
                  DebugLevel = 0;
              ///   PcDetectFlag = 0;
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 45  

                  break;
                }
              }
              #endif
 289          //=============================================================================
 290          //    Main Initialize Routine
 291          //=============================================================================
 292          void main_init (void)
 293          {
 294   1      
 295   1      
 296   1        //extern CODE BYTE *OutOfRangeStr[] ;
 297   1      
 298   1        //BYTE  ikey;
 299   1        WORD  rev;
 300   1      
 301   1      //  WriteTW88(0xff, 0x10);  // Disable I2C auto increase mode
 302   1      //  WriteTW88(0xe0, 0x10);  // Disable I2C auto increase mode
 303   1      
 304   1        //PowerLED(ON);
 305   1      
 306   1        //EnableRemoconInt();
 307   1      #if 0   //981103
                ikey = ResetMSP();
                if( ikey ) 
                {
                  #ifdef DEBUG
                  dPrintf("\r\nError on resetting MSP:0x%02x", (WORD)ikey);
                  #endif
                }
              #endif
 316   1        rev = GetFWRevEE();
 317   1        Printf("\r\nPrev.FW:%04x", rev);
 318   1      
 319   1        if( GetFWRevEE()!=FWVER )   // exist EEPROM
 320   1        {         
 321   2          Printf("\r\nCurr.FW:%04x", (WORD)FWVER);
 322   2          SaveFWRevEE(FWVER);
 323   2          Printf("\r\nCurr.FW:%04x", (WORD)GetFWRevEE());
 324   2        }
 325   1        
 326   1      
 327   1        //---------- if FW version is not matched, initialize EEPROM data -----------
 328   1      
 329   1        if( GetFWRevEE()==FWVER )
 330   1        {         // exist EEPROM
 331   2          if( rev != FWVER ) 
 332   2          {         //
 333   3            //SaveDebugLevelEE(DebugLevel);
 334   3            //Printf("\r\nNew DebugLevel:%02x", (WORD)DebugLevel);//andy awt084 980928
 335   3      
 336   3            //SaveInputSelectionEE(CH_TW2835);
 337   3            ClearBasicEE();
 338   3      
 339   3            //#ifdef SUPPORT_PC
 340   3            //ResetPanelAttributeValue();
 341   3            //SaveDefaultPCDataAllEE();
 342   3            //#endif
 343   3          }
 344   2          else 
 345   2          {
 346   3            DebugLevel = GetDebugLevelEE();
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 46  

 347   3            Printf("\r\nSaved DebugLevel:%02x", (WORD)DebugLevel);//andy awt084 980928
 348   3          }
 349   2      
 350   2        }
 351   1        else 
 352   1        {
 353   2          Printf("\r\nCannot access EEPROM!!!!");
 354   2          Printf("\r\nNo initialize");
 355   2          DebugLevel = 0xff;
 356   2          //SetVInputStd( NTSC );
 357   2          //InitVideoData(VInputStd);
 358   2          //DisplayLogo();
 359   2          //LCDPowerON(0);
 360   2          return;
 361   2        }
 362   1      
 363   1        //#ifdef SUPPORT_GAMMA
 364   1        //DownLoadGamma();
 365   1        //#endif
 366   1      
 367   1      #if 0   //awt ml073q william-20120308
                VInputStdDetectMode = GetVInputStdDetectModeEE();
                if( VInputStdDetectMode != AUTO )
                  SetVInputStd( VInputStdDetectMode );
                else
                  SetVInputStd( NTSC );
                SetPossibleAutoDetectStdEE();
              
                //InputSelectionInx  = 0;
                InputSelection  = UNKNOWN;    //GetInputSelectionEE();
                InitVideoData(VInputStd);
              #endif
 379   1        //ChangeInput( GetInputSelectionEE() );
 380   1      
 381   1        //Change_OSDColorLookup();
 382   1      
 383   1      
 384   1        //DownloadUDFont();
 385   1      
 386   1      
 387   1        delay(100);
 388   1        
 389   1        //AutoDetect = 0;
 390   1        //WriteALC106(0x04,0xC000);
 391   1        //ReadALC106(0x04);
 392   1        //WriteALC106(0x02,0x9E9E);
 393   1        
 394   1      //#ifdef Hs_debug 
 395   1      //  Prompt();
 396   1      //#endif
 397   1      
 398   1        //panel mirror  //william-20120921
 399   1        //WriteTW88( 0xff, 0x01); 
 400   1        //WriteTW88( 0x82, 0x01); 
 401   1        //WriteTW88( 0x82, 0x0c); 
 402   1        //WriteTW88( 0xff, 0x00); 
 403   1        
 404   1        //////////////////////////////////////////////////////////////////////////////////
 405   1      
 406   1        //WriteTW88( 0xd0, 0xff); // clear status
 407   1        //WriteTW88( 0xd1, 0xff); // clear status
 408   1        SET_POWER_STATUS(_POWER_STATUS_OFF);
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 47  

 409   1        SET_TARGET_POWER_STATUS(_POWER_STATUS_NORMAL);
 410   1      
 411   1      }
 412          
 413          
 414          
 415          
 416          //=============================================================================
 417          //                            Initialize WINBOND CPU                                                   
 418          //=============================================================================
 419          void InitCPU(void)
 420          {
 421   1      
 422   1      //  CHPENR = 0x87;    // Enable AUX RAM in Winbond(W78E516B)
 423   1      //  CHPENR = 0x59;    //
 424   1      //  CHPCON = 0x10;    //
 425   1      //  CHPENR = 0x00;    // Write Disable
 426   1      
 427   1        /*----- Initialize interrupt -------------*/
 428   1      
 429   1      //  TH1 = 0xfD;//38400    //    SMOD = 0      SMOD =1 //andy AWT 980924         
 430   1        TH1 = 0xf4; //9600    //    SMOD = 0      SMOD =1 //andy AWT 980924         
 431   1                  // 0ffh :57600 bps        
 432   1                  // 0fdh : 9600 bps  
 433   1                  //0fdh :19200 bps       
 434   1                  // 0fah : 4800 bps                
 435   1                  // 0f4h : 2400 bps                
 436   1                  // 0e8h : 1200 bps                
 437   1      
 438   1        SCON = 0x50;    // 0100 0000 mode 1 - 8 bit UART        
 439   1                  // Enable serial reception            
 440   1          TMOD = 0x22;    // 0010 0010 timer 0 - 8 bit auto reload    
 441   1                  // timer 1 - baud rate generator        
 442   1          TCON = 0x55;    // 0101 0001 timer 0,1 run            
 443   1                  // int 0,  edge triggered           
 444   1                  // int 1,  edge triggered           
 445   1                  // TF1 TR1 TF0 TR0  EI1 IT1 EI0 IT0       
 446   1        TH0 = TL0 = 64;   // 64=4608 Hz at 11.0592MHz
 447   1      
 448   1        PCON = 0x80;    // 0000 0000 SMOD(double baud rate bit) = 1   
 449   1        IP   = 0x02;    // 0000 0000 interrupt priority         
 450   1                  // -  - PT2 PS PT1 PX1 PT0 PX0               
 451   1      
 452   1        #ifdef SERIAL
 453   1        IE   = 0x92;    // 1001 0010 interrupt enable:Serial,TM0    
 454   1                    // EA - ET2 ES ET1 EX1 ET0 EX0          
 455   1      
 456   1        TI   = 1;     // LJY000724 // For Starting Serial TX 
 457   1        ES   = 1;     // LJY000724
 458   1        #else
                IE   = 0x82;
                #endif // SERIAL
 461   1      
 462   1        //------------ Timer 2 for Remocon --------------------------------
 463   1        T2CON  = 0x00;        // Timer2 Clear
 464   1        TR2    = 0;
 465   1        ET2    = 1;
 466   1        //-----------------------------------------------------------------
 467   1      
 468   1        //Uart2
 469   1        //P0M0=0x7F;
 470   1        //P1M0=0x04;
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 48  

 471   1             S2CON=0x50;                                 //Set UART Mode 1
 472   1             S2BRT=0xf4;                                 //Set 2UART overflow rate
 473   1            //AUXR2=0x08;                                 //SMOD = 1,TX12 = 0 (/12)
 474   1            //AUXR2|=0x10;                                //S2TR = 1
 475   1        AUXR2 |= 0x18;
 476   1      
 477   1        // Enable serial interrupt
 478   1        AUXIE |= 0x10;
 479   1      
 480   1        RS2_Xbusy=0;
 481   1        //PCA counter..
 482   1        CL=0; 
 483   1        CH=0;
 484   1        //AUXR2|=0x80;  //Fosc/12 for timer-0
 485   1        CMOD=0x00; // //PCA clock is Sysclk / 12   7.2KHz
 486   1        CCON|=  0x40;       //PCA Run
 487   1        //set pwm port 1.4 & 1.5
 488   1          //PCAPWM3 = 0x80;
 489   1      
 490   1        //P1M0=0x80;          //set input p1.6 
 491   1        //P1M0=0xC0;///add ADC AIN P1.6 & P1.7  (input mode)
 492   1          //P2M0=0x01;
 493   1        //P2M1=0x01;
 494   1        //P3M0=0x00;
 495   1        //P3M1=0x20;
 496   1        P3M0=0x20;
 497   1        P3M1=0x00;
 498   1      
 499   1        
 500   1      }
 501          
 502          
 503          void SET_PWM(BYTE index, BYTE val)
 504          {
 505   1      switch(index)
 506   1      {
 507   2      case _BL_PWM:  //P1_4
 508   2            //CCAP2L=0x80;  
 509   2            //CCAP2H =0x80; 
 510   2            //CCAPM2=0x42;   
 511   2            CCAP3L=0x80;  
 512   2            CCAP3H =255-val;  
 513   2            CCAPM3=0x42;   
 514   2             break; 
 515   2       case _CHG_CURR:  //P1_5
 516   2             //CCAP3L=0x80;  
 517   2             //CCAP3H =0x80;   
 518   2             //CCAPM3=0x42; 
 519   2             CCAP4L=0x80;  
 520   2             CCAP4H =255-val;  
 521   2             CCAPM4=0x42; 
 522   2             break;
 523   2       case _STOP_PWM:
 524   2            CCON  |=  0x40;       //RUN  PCA Counter
 525   2            break;
 526   2       case _RUN_PWM:
 527   2            CCON  &=  ~(0xBF);        //STOP PCA Counter
 528   2                break;
 529   2        
 530   2      default: 
 531   2            break;
 532   2      }
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 49  

 533   1      
 534   1      
 535   1      }
 536          
 537          
 538          #define _ReadKey()     ((~P4>>3)& 0x01)  //PSW P4.3
 539          
 540          
 541          ////////////////////////////////
 542          
 543          //INTERRUPT(1, timer0_int)
 544          void timer0_int(void) interrupt 1 using 1     // interrupt number1, bank register 2
 545          {
 546   1      BYTE TempKey;
 547   1      
 548   1        tm001++;
 549   1      
 550   1          // Timer Counter 
 551   1            tic02++;
 552   1      
 553   1        if(tic02>=10)   
 554   1        {
 555   2        g_usTimerCounter += 1;     ///per 103us  interrupt
 556   2        tic02=0;
 557   2        g_bNotifyTimer0Int=_TRUE;
 558   2        } 
 559   1        
 560   1        //Kane @HS 2007 0814 Ver1.31>>>>
 561   1        /*
 562   1        if(Power_Saving_Flag)
 563   1        {
 564   1          if(tic_PWR_SAVING)
 565   1            tic_PWR_SAVING--;
 566   1          #if 0
 567   1          if(tic_PWR_SAVING==0)
 568   1          {
 569   1            if(PWR_SAVING_ACT_FLAG==1)
 570   1            {
 571   1            P1_6=0;
 572   1            AdjustBacklight(0x80);
 573   1      
 574   1            #if 0
 575   1            Wait_ms(100);
 576   1            #endif
 577   1            
 578   1            clrBacklight();
 579   1            PWR_OFF_KEY_LOCK=1;
 580   1            PWR_SAVING_ACT_FLAG=0;
 581   1            }
 582   1          }
 583   1          #endif
 584   1        }
 585   1        */
 586   1        if(tic_Init_time)
 587   1          tic_Init_time--;
 588   1        if(Power_Msg_Count)
 589   1          Power_Msg_Count--;
 590   1        //if(Power_On_Display_Msg_Flag==1)
 591   1        //{
 592   1        //  if(Power_Msg_Count==0)
 593   1        //    Power_On_Display_Msg_Flag=0;
 594   1        //}
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 50  

 595   1      
 596   1      /*  
 597   1        if(LED_FLASH_COUNT)
 598   1          LED_FLASH_COUNT--;
 599   1        
 600   1        if(LED_FLASH_COUNT==0)
 601   1        {
 602   1          LED_FLASH_COUNT=1000;   
 603   1          ////_Anderson_add_20140225_xx
 604   1        
 605   1              if (FWUPDATE_FLAG)
 606   1                {
 607   1            if(TL057I_GREEN_LED==1)
 608   1            TL057I_GREEN_LED=0;
 609   1            else
 610   1            TL057I_GREEN_LED=1;
 611   1            }
 612   1             
 613   1      
 614   1      
 615   1          
 616   1          if(!OSD_Ready_Flag)
 617   1          {
 618   1            if(LED_BLINK_flag)
 619   1            {
 620   1            if(TL057I_GREEN_LED==1)
 621   1            TL057I_GREEN_LED=0;
 622   1            else
 623   1            TL057I_GREEN_LED=1;
 624   1            }
 625   1          }
 626   1          else
 627   1          {
 628   1            if(Ready_Flag)
 629   1            {
 630   1            if(PowerFlag)
 631   1              TL057I_GREEN_LED=0;
 632   1            else
 633   1              TL057I_GREEN_LED=1;
 634   1            
 635   1            Ready_Flag=0;
 636   1            }
 637   1          }
 638   1          
 639   1        }
 640   1      */
 641   1        
 642   1        if(Time5ms)
 643   1          Time5ms--;
 644   1        if(Time5ms==0)
 645   1        {
 646   2        //  TempKey=(( (P2&0xC0) >> 6) & 0x03);
 647   2          TempKey=(( (P3&0x0C) >> 2) & 0x03); //ENA&ENB, P3.2, P3.3 
 648   2          if(updn_reg[3] !=TempKey )// (( (P2&0x60) >> 5) & 0x03))    //Abel for HS SW key ......951102           
             -                            
 649   2          {                                                                                          
 650   3            updn_reg[0] = updn_reg[1];                                                              
 651   3            updn_reg[1] = updn_reg[2];                                                              
 652   3            updn_reg[2] = updn_reg[3];                                                              
 653   3            updn_reg[3] =TempKey;// ( (P2&0x60) >> 5) & 0x03; 
 654   3            ChangeKey=1;    
 655   3          //else      //william-v1.42-961130
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 51  

 656   3          //ChangeKey=0;  //william-v1.42-961130
 657   3          Time5ms=48;
 658   3      
 659   3            if((updn_reg[0] == 0) && (updn_reg[1] == 1) && (updn_reg[2] == 3)&& (updn_reg[3] == 2))  //UP Key     
 660   3                   EncorderCount++;            
 661   3          if((updn_reg[0] == 1) && (updn_reg[1] == 3) && (updn_reg[2] == 2)&& (updn_reg[3] == 0))  //UP Key     
 662   3                   EncorderCount++;          
 663   3               if((updn_reg[0] == 3) && (updn_reg[1] == 2) && (updn_reg[2] == 0)&& (updn_reg[3] == 1))  //UP Key 
             -   
 664   3                  EncorderCount++;
 665   3          if((updn_reg[0] == 2) && (updn_reg[1] == 0) && (updn_reg[2] == 1)&& (updn_reg[3] == 3))  //UP Key     
 666   3                   EncorderCount++;             
 667   3           
 668   3                if((updn_reg[0] == 0) && (updn_reg[1] == 2)&& (updn_reg[2] == 3)&& (updn_reg[3] == 1))  //DN Key 
             -    
 669   3                   EncorderCount--;      
 670   3           if((updn_reg[0] == 2) && (updn_reg[1] == 3)&& (updn_reg[2] == 1)&& (updn_reg[3] == 0))  //DN Key     
 671   3                   EncorderCount--;       
 672   3                if((updn_reg[0] == 3) && (updn_reg[1] == 1)&& (updn_reg[2] == 0)&& (updn_reg[3] == 2))  //DN Key 
             -   
 673   3                   EncorderCount--;
 674   3                if((updn_reg[0] == 1) && (updn_reg[1] == 0)&& (updn_reg[2] == 2)&& (updn_reg[3] == 3))  //DN Key 
             -   
 675   3                   EncorderCount--; 
 676   3          
 677   3          
 678   3          }
 679   2        }
 680   1          //Kane @HS 2007 0814 Ver1.31<<<<
 681   1        
 682   1        //---------- 0.01 sec timer ------------
 683   1        
 684   1        #ifdef CLOCK_11M
                if( tm001 > 48 ) {      // LJY001220 0.01sec
                #elif defined CLOCK_22M
 687   1        if( tm001 > 48*2 ) {    // LJY001220 0.01sec
 688   2        #endif
 689   2      
 690   2          stopWatch++;
 691   2          tm001 = 0;
 692   2          tic01++;
 693   2          
 694   2          if( tic01==100 ) 
 695   2          {       // 1 sec
 696   3      //      if(SEQTime<255) SEQTime++;
 697   3        //    SystemClock++;
 698   3            tic01 = 0;
 699   3          //date  
 700   3      #if 0///ndef QUAD
                  if(displayhold_flag>1)
                    displayhold_flag--;
              #endif    
 704   3          
 705   3      //    second++;
 706   3          
 707   3      //    if(lock_keycnt>0)
 708   3      //      lock_keycnt--;
 709   3          
 710   3      //    if(FormatStart==1)
 711   3      //      FormatWait++;   
 712   3        //  if(PowerDownStart==1)
 713   3          //  PowerDownWait++;      
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 52  

 714   3          /*
 715   3          if(second==60)
 716   3            {
 717   3            second=0;
 718   3            minute++;
 719   3      
 720   3            }
 721   3          
 722   3          if(minute==60)
 723   3            {   
 724   3            minute=0;
 725   3            hour++;
 726   3            }
 727   3          
 728   3          if(hour==24)
 729   3            {
 730   3            hour=0;
 731   3            day++;
 732   3            }     
 733   3          */
 734   3      
 735   3          if(Key)
 736   3            keyticSec++;
 737   3          else
 738   3            keyticSec=0;
 739   3      //#ifdef Format_SDCard
 740   3      //     if(((DVR_RecordStatus&NORMAL_Record)!=NORMAL_Record) && DVR_SDCardAvailable!=0xff && FormatSDCard!=0)
 741   3        //    FormatSDCard++;
 742   3      //#endif  
 743   3      
 744   3      
 745   3          }
 746   2          if( tic_pc!=0xffff ) 
 747   2            tic_pc++;
 748   2      
 749   2      #if 1
 750   2        /////////////////////////////////////////// 
 751   2        if( _ReadKey() )
 752   2          {
 753   3          if( keytic==3 ) 
 754   3            {
 755   4            //Key = _ReadKey();
 756   4            RepeatKey = 0;
 757   4            KeyReady = 1;
 758   4          }
 759   3          else if( keytic==100 ) {
 760   4            //Key = _ReadKey();
 761   4            RepeatKey = 1;
 762   4            KeyReady = 1;
 763   4            keytic = 80;
 764   4          }
 765   3          keytic++;
 766   3        }
 767   2        else 
 768   2          {
 769   3          keytic = 0;
 770   3          Key=0;
 771   3          }
 772   2        /////////////////////////////////////////// 
 773   2      #endif  
 774   2        }
 775   1      }
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 53  

 776          //------------------------------------------------------------------
 777          // void InitVars(void) - variable initialize
 778          //------------------------------------------------------------------
 779          void  InitVars(void)
 780          {
 781   1      BYTE j;
 782   1      for(j=0;j<29;j++)
 783   1          DVR_buf[j] = 0 ;  
 784   1      
 785   1      
 786   1      #if 0
                SystemClock=0;      //00:00
                //LastBlockedTime=0xffffffff;   //00:00 //ljy010904...CC_FIX_CLEAR_ON_TIME..oops! previous vchip clear err
             -or 
                //OffTime=0xffff;
                //SleepTimer=0;
                //SleepTime=0xffff;
              
                //SEL_DVI=  1;    // disable Digital VGA
                // ResetKey();
              
                DebugLevel    = 0;
              #ifdef REMO_RC5
                RemoDataReady = 0;
              #endif
                //P0_7 = 1;
                delay(100);
                PowerDown_XTAL(0);
                
                TW88HWReset = 1;  delay(1);
                #endif
 806   1      }
 807          
 808          #if 0
              //------------------------------------------------------------------
              // void InitTechwell(void) - Techwell Decoder initialize
              //------------------------------------------------------------------
              void  InitTechwell( void )
              {
              
                #ifdef NO_INITIALIZE
                if( P0_3==0 ) {// No Initialize
                  NoInitAccess =1;
                  Printf("\r\n No-initialize Test going on with DIP SW4 ..: %d\n", (WORD)P0_3);
                  return;
                }
                #endif
                #ifdef CHIP_MANUAL_TEST
                if( P0_0==0 ) OnChipTest =1;
                ManualFrequency = 2; //1;
                #endif
              
                
              
                Puts("\r\n\nDetect ");
                
                switch( ReadTW88(0) ) {
                  case 0x21:  Puts("TW8816");   break;
                  case 0x22:  Puts("TW8816B");    break;
                  case 0x49:  Puts("TW8817");   break;
                  default:  Printf("Nothing --0x%02x\r\n", (WORD)ReadDecoder(0)); 
                    while(1) {
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 54  

                      #ifdef SERIAL
                      if( RS_ready() ) break;
                      #endif
              
                      Printf("Check again --0x%02x\r\n", (WORD)ReadDecoder(0));
                      delay(99);
                      if( ReadTW88(0)==0 ) continue;
                      if( ReadTW88(0)==0xff ) continue;
                      break;
                    }
              
                    delay(99);
                    delay(99);
                    Printf("Last Check --0x%02x\r\n", (WORD)ReadDecoder(0));
                  break;
                }
              
                  Printf("%s \n", PanelInfoStr);
                //CheckSpecialMode();   //william-981029
              
                SetVideoSharpnessReg(8);  //Modified from 1 to 8. David. 20180712.
              
              }
              #endif
 861          //=============================================================================
 862          //                            Power LED ON / OFF                                                   
 863          //=============================================================================
 864          void PowerLED(BYTE flag)
 865          {
 866   1      //#define GREEN_LED P3_5
 867   1      //#define RED_LED   P3_3    P4^1
 868   1      #if 0
                if( flag==ON ) {
                  //GREEN_LED = 0;    // ON GREEN
                  P4=P4&0xFE;   //GREEN_LED = 0;    // ON GREEN
                  P4=P4|0x02;   //RED_LED = 1;    // OFF RED
                  dPuts("\r\n(PowerLED)-ON");
                  }
                else if(flag==OFF)   
                  {
                  //GREEN_LED = 1;    // OFF FREEN
                  P4=P4|0x01;   //GREEN_LED = 1;    // OFF GREEN
                  P4=P4&0xFD;   //RED_LED = 0;    // ON RED
                  dPuts("\r\n(PowerLED)-OFF");
                  }
                else if(flag==2)
                  {
                  //GREEN_LED = 1;    // OFF FREEN
                  P4=P4|0x01;   //GREEN_LED = 1;    // ON GREEN
                  P4=P4|0x02;   //RED_LED = 1;    // OFF RED
                  dPuts("\r\n(PowerLED)-OFF");
                  }
              #endif
 890   1      switch(flag)
 891   1         { 
 892   2         case _SYSTEM_TIMER_EVENT_GRN_ON:
 893   2         if((P4&0x01))
 894   2         P4=P4&0xFE;     //GREEN_LED = 0;      // ON GREEN
 895   2        break;
 896   2         case _SYSTEM_TIMER_EVENT_GRN_OFF:
 897   2         if((P4&0x01)==0)   
 898   2        P4=P4|0x01;   //GREEN_LED = 1;    // OFF GREEN
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 55  

 899   2        break;
 900   2         case _SYSTEM_TIMER_EVENT_RED_ON:
 901   2         if((P4&0x02))    
 902   2        P4=P4&0xFD;   //RED_LED = 0;    // ON RED     
 903   2        break;
 904   2         case _SYSTEM_TIMER_EVENT_RED_OFF:
 905   2         if((P4&0x02)==0)   
 906   2          P4=P4|0x02;   //RED_LED = 1;    // OFF RED
 907   2          break;
 908   2         case _SYSTEM_TIMER_EVENT_GRN_RED_ON:
 909   2           if((P4&0x01))
 910   2           P4=P4&0xFE;     //GREEN_LED = 0;      // ON GREEN
 911   2           if((P4&0x02))  
 912   2          P4=P4&0xFC;   //RED_LED = 0;    // ON RED 
 913   2          break;
 914   2         case _SYSTEM_TIMER_EVENT_GRN_BLINK:
 915   2               if((P4&0x01))
 916   2            {
 917   3           P4=P4&0xFE;     //GREEN_LED = 0;      // ON GREEN      
 918   3            }
 919   2          else
 920   2          {
 921   3          P4=P4|0x01;   //GREEN_LED = 1;    // OFF GREEN
 922   3          }
 923   2           MCUTimerActiveTimerEvent(SEC(1), _SYSTEM_TIMER_EVENT_GRN_BLINK);
 924   2          break;
 925   2         case _SYSTEM_TIMER_EVENT_RED_BLINK:
 926   2             if((P4&0x02))
 927   2            {
 928   3           P4=P4&0xFD;    //RED_LED = 0;    // ON RED       
 929   3            }
 930   2          else
 931   2          {
 932   3          P4=P4|0x02;   //RED_LED = 1;    // OFF RED
 933   3          }
 934   2           MCUTimerActiveTimerEvent(SEC(1), _SYSTEM_TIMER_EVENT_RED_BLINK);
 935   2          break;  
 936   2        case _SYSTEM_TIMER_EVENT_GRN_RED_BLINK:
 937   2             if((P4&0x01))
 938   2            {
 939   3           P4=P4&0xFC;     //GREEN_LED = 0;      // ON RED& GREEN  
 940   3            }
 941   2          else
 942   2          {
 943   3          P4=P4|0x03;   //GREEN_LED = 1;    // OFF GREEN&RED
 944   3          }
 945   2           MCUTimerActiveTimerEvent(SEC(1), _SYSTEM_TIMER_EVENT_GRN_RED_BLINK);
 946   2         break;  
 947   2         case _SYSTEM_TIMER_EVENT_GRN_ON_RED_BLINK:
 948   2             if((P4&0x02))
 949   2            {
 950   3           P4=P4&0xFC;     //GREEN_LED = 0;      // ON RED
 951   3            }
 952   2          else
 953   2          {
 954   3          P4=P4|0x02;   //GREEN_LED = 1;    // OFF RED
 955   3          }
 956   2           MCUTimerActiveTimerEvent(SEC(1), _SYSTEM_TIMER_EVENT_GRN_ON_RED_BLINK);
 957   2         break;   
 958   2         default:
 959   2                  break;
 960   2       }  
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 56  

 961   1      }
 962          
 963          
 964          //------------------------ common routines with interrupts --------------------
 965          
 966          /*****************************************************************************/
 967          /*      Ext Int 1 Interrupt                                                  */
 968          /*****************************************************************************/
 969          //INTERRUPT(2, ext1_int)
 970          void  ext1_int(void) interrupt 2 using 1
 971          {
 972   1        EX1 = 0;
 973   1      }
 974          
 975          //****************************************************************************/
 976          //      Timer 0 Interrupt                                                  
 977          //      If TL0 overflow,
 978          //       .Invoke this interrupt
 979          //       .TL0 <- TH0
 980          //      TL0 is incremented every machine cycle
 981          //      Every machine cycle is 12*Tosc(11.0592MHz)
 982          //
 983          //      Every machine cycle = 1.085us
 984          //      Interrupt interval = 208us ( 1.085*(256-64(TH0)) )
 985          //      When tm001==48, it's 0.01sec.  48*208us
 986          //              
 987          //****************************************************************************/
 988          
 989          
 990          //=============================================================================
 991          //      Remocon
 992          //=============================================================================
 993          
 994          #if 0//def REMO_RC5
              
              void InitForRemo(void)
              {
                WORD temp;
              
                #if defined CLOCK_11M
              
                #ifdef TECHWELL_REMOCON // DONGYANG
                temp = 0x10000 - 193; // 209.62us = 1.085*193
                #else
                temp = 0x10000 - 204; // 221.34us = 1.085*204
                #endif
                
                #elif defined CLOCK_22M
              
                #ifdef TECHWELL_REMOCON // DONGYANG
                temp = 0x10000 - 193*2; // 209.62us = 1.085/2*193*2
                #else
                temp = 0x10000 - 204*2; // 221.34us = 1.085/2*204*2
                #endif
              
                #elif defined CLOCK_27M   // intenal_mcu
              
                #ifdef TECHWELL_REMOCON // DONGYANG
                temp = 0x10000 - 20;  // 209.62us = 1/27 * 283 * 20 = 209.63uS
                T2HIGH = 1;     // 283 = 256 + 27
                T2LOW = 27;     // 
                #else
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 57  

                temp = 0x10000 - 36;  // 221.34us = 1/27 * 166 * 36 = 221.33uS
                T2HIGH = 0;     // 
                T2LOW = 166;      // 
                #endif
              
                #endif
              
                RCAP2H = TH2 = temp>>8;
                RCAP2L = TL2 = (BYTE)(temp & 0xff);
                TR2    = 1;
              
                tm01 = 4;
                RemoPhase1 = 1;
                RemoSystemCode= RemoDataCode=0;
              }
              
              //#elif defined REMO_NEC
              
              void InitForRemo(void)
              {
                WORD temp;
              
                #if defined CLOCK_11M
                temp = 0x10000 - 173; // 187.71us = 1.085*173
                #elif defined CLOCK_22M
                temp = 0x10000 - 173*2;
                #elif defined CLOCK_27M 
                T2HIGH = 0;     // 
                T2LOW = 252;      // 
                temp = 0x10000 - 20;  // 186.667uS = 1 /27 * 252 * 20
                #endif
              
                RCAP2H = TH2 = temp>>8;
                RCAP2L = TL2 = (BYTE)(temp & 0xff);
              
                TR2 = 1;
              
                tm01 = 0;
                RemoStep  = 0;
                RemoPhase = 0;
                RemoHcnt  = 0;
                RemoLcnt  = 0;
              }
              
              #endif
1068          
1069          #if 0///def REMO_RC5
              
              ///****************************************************************************
              ///*      Ext Int 0 Interrupt                                                
              ///****************************************************************************
              //_interrupt(0) void remocon_int (void)
              //INTERRUPT(0, remocon_int)
              void  remocon_int(void) interrupt 0 using 1
              {
                EX0 = 0;  // Enable Remocon (Enable Ext int0)
                InitForRemo();
              }
              #endif
1082          //*****************************************************************************
1083          //      Serial Interrupt                                                   
1084          //*****************************************************************************
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 58  

1085          #ifdef SERIAL
1086          
1087          //INTERRUPT(4, serial_int)
1088          void serial_int(void) interrupt 4 using 1   // register bank 1
1089          {
1090   1        
1091   1        //day++;
1092   1        //year2=RI;
1093   1        //year1=TI;
1094   1        if( RI ) {          //--- Receive interrupt ----
1095   2          #if 0///def Hs_debug
                    RS_buf[RS_in]=SBUF;
                    RS_in++;
                    if( RS_in>=BUF_MAX) RS_in = 0;
                  #else
1100   2          
1101   2            #ifdef USE_HI3521_UART2
                    #else
1103   2            DVR_buf[RS_in]= SBUF;//andy awt 980928
1104   2                RS_in++;
1105   2            if( RS_in>=DVR_BUF_MAX) RS_in = 0;
1106   2            #endif  
1107   2          
1108   2          #endif
1109   2          RI = 0;
1110   2          //month++;
1111   2        }
1112   1      
1113   1        if( TI ) {          //--- Transmit interrupt ----
1114   2          TI = 0;
1115   2          RS_Xbusy=0;
1116   2        }
1117   1      }
1118          
1119          #if 1
1120          //INTERRUPT(12, serial2_int)
1121          void serial2_int(void) interrupt 12 using 1   
1122          {
1123   1        //--- Receive interrupt ----
1124   1        //day++;
1125   1        //year2=S2CON&0x0f;
1126   1        if ((S2CON & 0x01) == 0x01)
1127   1          {         
1128   2          // Clear reception flag
1129   2          S2CON = S2CON&0xfe;
1130   2          #ifdef USE_HI3521_UART2
                  DVR_buf[RS2_in] = S2BUF;
                  #endif
1133   2          //month++;
1134   2            RS2_in++;
1135   2          if( RS2_in>=/*BUF_MAX*/DVR_BUF_MAX) RS2_in = 0;
1136   2        }
1137   1        
1138   1        if ((S2CON & 0x02) == 0x02)
1139   1        {
1140   2          S2CON = S2CON&0xfd;
1141   2          RS2_Xbusy = 0;
1142   2        }
1143   1      }
1144          
1145          #endif
1146          
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 59  

1147          //=============================================================================
1148          //    Serial RX Check                            
1149          //=============================================================================
1150          BYTE RS_ready(void)
1151          {
1152   1        if( RS_in == RS_out ) return 0;
1153   1        else return 1;
1154   1      }
1155          //#ifdef Hs_debug
1156          //=============================================================================
1157          //    Serial RX                              
1158          //=============================================================================
1159          BYTE RS_rx(void)
1160          {
1161   1        BYTE  ret;
1162   1          
1163   1        ES = 0;
1164   1      //  ret = RS_buf[RS_out];
1165   1        ret = DVR_buf[RS_out];
1166   1        RS_out++;
1167   1      //  if(RS_out >= BUF_MAX) 
1168   1          if(RS_out >= DVR_BUF_MAX) 
1169   1          RS_out = 0;
1170   1        ES = 1;
1171   1      
1172   1        return ret;
1173   1      }
1174          //#endif
1175          //=============================================================================
1176          //    Serial TX                              
1177          //=============================================================================
1178          void RS_tx(BYTE tx_buf)
1179          {
1180   1        while(RS_Xbusy);
1181   1        SBUF = tx_buf;
1182   1        RS_Xbusy=1;
1183   1      }
1184          
1185          //=============================================================================
1186          //    Serial2 TX                               
1187          //=============================================================================
1188          /*
1189          void RS2_tx(BYTE tx_buf)
1190          {
1191          #if 0
1192            BYTE temp;  
1193          
1194            temp = S2CON;
1195            S2BUF = tx_buf;
1196            while(S2CON==temp);
1197            S2CON = temp;
1198          #endif
1199            while(RS2_Xbusy); 
1200              S2BUF=tx_buf;
1201              RS2_Xbusy=1;
1202          }
1203          */
1204          
1205          #endif  // SERIAL
1206          
1207          
1208          
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 60  

1209          //****************************************************************************/
1210          //      Timer 2 Interrupt                                                  
1211          //      If TH2 and TL2 are overflowed,
1212          //       .Invoke this interrupt
1213          //       .TH2 <- RCAP2H
1214          //       .TL2 <- RCAP2L
1215          //      TL2 is incremented every machine cycle
1216          //      Every machine cycle is 12*Tosc(11.0592MHz)
1217          //
1218          //      Every machine cycle = 1.085us
1219          //      Interrupt interval  
1220          //        1) REMO_RC5 
1221          //          221.34us  ( 1.085*204 )   // (256-52) (0x10000-0xff34)
1222          //
1223          //          data length: 14bit (2sync bits, 1 control bit, 11 data bits) 24,889ms
1224          //
1225          //                +----+
1226          //          1 is coded:      |    |
1227          //                   +----+   
1228          //                  T    T
1229          //
1230          //                   +----+
1231          //          0 is coded: |    |
1232          //                      +----+    
1233          //                  T    T          T = 889us
1234          //
1235          //          *) DongYang
1236          //            209.62  ( 1.085*193 ) // (256-63) (0x10000-0xff3f)
1237          //-----------------------------------------------------------------------------
1238          //        2) REMO_NEC
1239          //          187.714us ( 1.085*173 )     // (256-83) (0x10000-0xff53)
1240          //              
1241          //****************************************************************************/
1242          //INTERRUPT(5, timer2_int)
1243          void timer2_int(void) interrupt 5 using 1     // using register block 3
1244          {
1245   1        TF2 = 0;          // clear overflow
1246   1      
1247   1        tm01++;
1248   1      
1249   1      
1250   1        #if 0///def REMO_RC5
                {
                  BYTE  i;
              
                  i = tm01 & 0x07;
                  if( i>=1 && i<=2 )
                    RemoPhase1 = P3_2;
                  else if( i>=5 && i<=6 )
                    RemoPhase2 = P3_2;
                  else
                    ;
                  if( i==0 ) {  //every 8 tm01
                    if( RemoPhase1==RemoPhase2 ) {  // error
                      ClearRemoTimer();     
                      EnableRemoconInt();
                      return;
                    }
                    if( tm01<=(8*8) ) {       // start control system
                      RemoSystemCode <<=1;
                      if( RemoPhase1==1 && RemoPhase2==0 )
                        RemoSystemCode |=1;
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 61  

                    }
                    else {              // data
                      RemoDataCode <<=1;
                      if( RemoPhase1==1 && RemoPhase2==0 )
                        RemoDataCode |=1;
                    }
                  }
                  if( tm01 > (8*14) ) {
                    RemoDataReady++;  //LJY051502 RemoDataReady = 1;        // new key
                    ClearRemoTimer();       
                    //RemoOver = 0;
                  }
                }
              
                //#elif defined REMO_NEC
                
                {
                  if( RemoDataReady ) return;
              
                  switch( RemoStep ) {
              
                  case 0:
                    if( P3_2==0 ) {
                      RemoLcnt++;
                      if( RemoLcnt==0xff ) goto RemoError;
                    }
                    else {
                      RemoHcnt = 0;
                      RemoStep++;
                    }
                    break;
              
                  case 1:
                    if( P3_2==1 ) {
                      RemoHcnt++;
                      if( RemoHcnt==0xff ) goto RemoError;
                    }
                    else {
                      if( RemoLcnt>=15*3 && RemoLcnt<=17*3 ) {
                        
                        if( RemoHcnt>=3*3 && RemoHcnt<=5*3 ) {
                          RemoStep = 3;
                          RemoDataReady = 2;
                          break;
                        }
                        else if( RemoHcnt>=7*3 && RemoHcnt<=9*3 ) {
                          RemoStep++;
                          RemoPhase = 0;
                          RemoLcnt = 0;
                          RemoNum  = 0;
                          RemoBit  = 0;
                          break;
                        }
                      }
                      else goto RemoError;
                    }
                    break;
              
                  case 2:
                    if( RemoPhase==0 ) {
                      if( P3_2==0 )         // Phase=0  Input=0
                        RemoLcnt++;
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 62  

                      else {              // Phase=0  Input=1
                        RemoPhase = 1;
                        RemoHcnt = 0;
                      }
                    }
                    else {                
                      if( P3_2==1 )         // Phase=1  Input=1
                        RemoHcnt++;
                      else {              // Phase=1  Input=0
                        RemoPhase = 0;
                        if( RemoLcnt>=1 && RemoLcnt<=5 ) {
                          if( RemoHcnt<=2*3 )       // bit 0
                            RemoData[RemoNum] <<= 1;
                          else if( RemoHcnt<=4*3 ) {    // bit 1
                            RemoData[RemoNum] <<= 1;
                            RemoData[RemoNum]++;
                          }
                          else goto RemoError;
              
                          if( ++RemoBit>=8 ) {
                            RemoBit = 0;
                            if( ++RemoNum>=4 ) {
                              RemoDataReady = 1;
                              RemoStep++;
                            }
                          }
                          RemoLcnt = 0;
              
                        }
                        else goto RemoError;
                      }
                    }
                    break;
              
                  case 3:
                    break;
                  
                  }
                  return;
              
              RemoError:
                  ClearRemoTimer();       //TimerFor208us();
                  EnableRemoconInt();
                }
              
                #endif  // REMO_NEC
1379   1      }
1380          
1381          
1382          void delay(BYTE cnt)
1383          {
1384   1        WORD ttic01;
1385   1      
1386   1        ttic01 =  ( tic01 + cnt ) % 100;
1387   1        do {
1388   2          ;
1389   2        } while( tic01 != ttic01 );
1390   1      }
1391          
1392          
1393          //=============================================================================
1394          //    Time
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 63  

1395          //=============================================================================
1396          #define _24H_SECS     86400L      // 24*60*60
1397          /*
1398          WORD GetTime_ms(void)
1399          {
1400            WORD tms;
1401          
1402            tms = tic01;
1403            tms += ( SystemClock % 60 ) * 100;
1404            return tms; // in ms
1405          }
1406          */
1407          //BYTE GetTime_H(void)
1408          //{
1409          //  return ( SystemClock / 60 / 60 ) % 24 ;
1410          //}
1411          
1412          //BYTE GetTime_M(void)
1413          //{
1414          //  return ( SystemClock / 60  ) % 60 ;
1415          //}
1416          #if 0
              BYTE GetSleepTimer(void)
              {
                WORD val;
              
                val = SleepTimer;
                if( val ) { // already set, display rest of time
                  val = ( SleepTime >> 8 ) * 60 + ( SleepTime & 0xff );
                  val -= ( GetTime_H() * 60 + GetTime_M() );
                }
                return (BYTE)val;
              }
              
              void SetSleepTimer(BYTE stime)
              {
                SleepTimer = stime;
                if( SleepTimer==0 )
                  SleepTime = 0xffff;
                else {
                  SleepTime = GetTime_H() + ( GetTime_M() + SleepTimer ) / 60;
                  SleepTime = ( SleepTime << 8 ) | ( ( GetTime_M() + SleepTimer ) % 60 );
                }
              
                #ifdef DEBUG_TIME
                dPrintf("\r\n++(SetSleepTimer) SleepTime:0x%x__", (WORD)SleepTime);
                #endif
              }
              
              BYTE OKSleepTime(void)
              {
                if( GetTime_H() == ( SleepTime >>8 ) && 
                  GetTime_M() == ( SleepTime & 0xff ) ) {
                  SleepTimer=0;
                  SleepTime = 0xffff;
                  return 1;
                }
                return 0;
              }
              #endif
1455          /*
1456          WORD DiffTime_ms( WORD stime, WORD etime )
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 64  

1457          {
1458            //#ifdef DEBUG
1459            //dPrintf("\r\n(DiffTime) stime:%d, etime:%d", (WORD)stime, (WORD)etime );
1460            //#endif
1461            if( etime < stime ) {     // resetted
1462              return etime + (6000 - stime);
1463            }
1464            else {
1465              return etime - stime;
1466            }
1467          }
1468          */
1469          #if 0
              void Wait_ms(WORD Tms)
              {
                #define CPU_CLK_KHZ   22118
                #define CPU_SPEED 1
                #define CountStick     (1000000U/((CPU_CLK_KHZ*CPU_SPEED)/12))/20     //winbond
                #define MegawinCountStick    ((1000000U/((CPU_CLK_KHZ*CPU_SPEED)/12))/20)*8 //Megawin
                  WORD count;
                  while(Tms)
                   {
                   for(count=0; count</*CountStick*/MegawinCountStick; count++);//total 20 clock for this loop
                      Tms--;
                   }
              }
              #endif
1484          #if 0
              BYTE TW2835Command(char _commid, char _attr0, char _attr1, char _attr2, char _attr3)
              {        
                 BYTE AttrBuf[4];
                 BYTE i,j;
                 WORD WaitCnt;
                 //Kane @HS 2007 0807 Ver1.3 for camera always on
                 _attr0|=0x10;
                 _attr1|=0x10;
                 _attr2|=0x10;
                 _attr3|=0x10;
                 //Kane @HS 2007 0807 Ver1.3 for camera always on
               //  Printf("TW2835Command\r\n",0);   //william-v1.44a-970923
                  
              switch(_commid)
              {
                      //A B C R
                  case 0:
                      case 11:
                          AttrBuf[0]=_attr0;
                          AttrBuf[1]=_attr1;
                          AttrBuf[2]=_attr2;
                          AttrBuf[3]=_attr3;
                          break;
                      //B A C R     
                      case 22:
                  case 25:  
                  case 1:
                          AttrBuf[0]=_attr1;
                          AttrBuf[1]=_attr0;
                          AttrBuf[2]=_attr2;
                          AttrBuf[3]=_attr3;
                          break;
                      //C A B R     
                      case 28:
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 65  

                  case 31:  
                  case 2:
                          AttrBuf[0]=_attr2;
                          AttrBuf[1]=_attr0;
                          AttrBuf[2]=_attr1;
                          AttrBuf[3]=_attr3;
                          break;
                      //R A B C     
                      case 3:
                      case 8:
                    case 14:    
                          AttrBuf[0]=_attr3;
                          AttrBuf[1]=_attr0;
                          AttrBuf[2]=_attr1;
                          AttrBuf[3]=_attr2;
                          break;
                      //A B C R     
                      case 20:
                  case 4:
                          AttrBuf[0]=_attr0;
                          AttrBuf[1]=_attr1;
                          AttrBuf[2]=_attr2;
                          AttrBuf[3]=_attr3;
                          break;
                      //C R A B      
                      case 5:
                          AttrBuf[0]=_attr2;
                          AttrBuf[1]=_attr3;
                          AttrBuf[2]=_attr0;
                          AttrBuf[3]=_attr1;
                          break;
                      //A R B C     
                      case 6:
                          AttrBuf[0]=_attr0;
                          AttrBuf[1]=_attr3;
                          AttrBuf[2]=_attr1;
                          AttrBuf[3]=_attr2;
                          break;
                     //R B A C      
                      case 7:
                          AttrBuf[0]=_attr3;
                          AttrBuf[1]=_attr1;
                          AttrBuf[2]=_attr0;
                          AttrBuf[3]=_attr2;
                          break;     
              
              // 2007.4.10 Justin add for A+C &  C+B Mode
                      //A C B R 
                      case 12:
                          AttrBuf[0]=_attr0;
                          AttrBuf[1]=_attr2;
                          AttrBuf[2]=_attr1;
                          AttrBuf[3]=_attr3;
                          break;        
              
              
                      //C B A R
                      case 13:
                          AttrBuf[0]=_attr2;
                          AttrBuf[1]=_attr1;
                          AttrBuf[2]=_attr0;
                          AttrBuf[3]=_attr3;
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 66  

                          break;              
              
              // 2007.4.10 Justin add for A+C &  C+B Mode
              
              
              // 2007.4.16  Justin
                      //A B R C
                  case 9:
                    case 10:
                          AttrBuf[0]=_attr0;
                          AttrBuf[1]=_attr1;
                          AttrBuf[2]=_attr3;
                          AttrBuf[3]=_attr2;
                          break;
              // 2007.4.16  Justin
                      //Andy A1.4 20090113
                      //-----------------------------
                      //R C A B
                  case 15:
                    AttrBuf[0]=_attr3;
                          AttrBuf[1]=_attr2;
                          AttrBuf[2]=_attr1;
                          AttrBuf[3]=_attr0;
                    break;
                      //R A C B
                  case 16:
                  case 18:           
                    AttrBuf[0]=_attr3;
                          AttrBuf[1]=_attr0;
                          AttrBuf[2]=_attr2;
                          AttrBuf[3]=_attr1;
                    break;
                      //R B C A
                  case 17:
                  case 19:
                    AttrBuf[0]=_attr3;
                          AttrBuf[1]=_attr1;
                          AttrBuf[2]=_attr2;
                          AttrBuf[3]=_attr0;
                    break;
                      //A C R B
                  case 21:
                      AttrBuf[0]=_attr0;
                          AttrBuf[1]=_attr2;
                          AttrBuf[2]=_attr3;
                          AttrBuf[3]=_attr1;
                    break;
                  //B C R A
                  case 23:
                    case 27:
                          AttrBuf[0]=_attr1;
                          AttrBuf[1]=_attr2;
                          AttrBuf[2]=_attr3;
                          AttrBuf[3]=_attr0;
                    break;
                      //B R A C
                  case 24:
                    AttrBuf[0]=_attr1;
                          AttrBuf[1]=_attr3;
                          AttrBuf[2]=_attr0;
                          AttrBuf[3]=_attr2;
                    break;
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 67  

                      //B A R C
                  case 26:
                    AttrBuf[0]=_attr1;
                          AttrBuf[1]=_attr0;
                          AttrBuf[2]=_attr3;
                          AttrBuf[3]=_attr2;
                    break;
                      //C B R A
                  case 29:
                  case 33:
                    AttrBuf[0]=_attr2;
                          AttrBuf[1]=_attr1;
                          AttrBuf[2]=_attr3;
                          AttrBuf[3]=_attr0;
                    break;
                  //C R A B
                  case 30:
                    AttrBuf[0]=_attr2;
                          AttrBuf[1]=_attr3;
                          AttrBuf[2]=_attr0;
                          AttrBuf[3]=_attr1;
                    break;
                      //C A R B
                  case 32:      
                    AttrBuf[0]=_attr2;
                          AttrBuf[1]=_attr0;
                          AttrBuf[2]=_attr3;
                          AttrBuf[3]=_attr1;
                    break;
                 }
                  for(i=0;i<BUF_MAX;i++) {RS_buf2[i]='\0';RS_buf[i]='\0';} // cls RX buffer
                  for(j=0;j<3;j++)
                    {       
                      Printf(CommTable[_commid], AttrBuf[0], AttrBuf[1], AttrBuf[2], AttrBuf[3]); 
                      WaitCnt=GetTime_ms();
                    while(abs(WaitCnt-GetTime_ms())<40);
                    {
                              for(i=0;i<BUF_MAX;i++) 
                          {  
                            if(RS_buf2[i]=='A' )
                            {
                          if( RS_buf2[(i+1)%8]=='C' &&  RS_buf2[(i+2)%8]=='K'  ) 
                           return TRUE;
                            }   
                              }
                  }
                    Wait_ms(200);         
                }
                return FALSE;
                 
              }
              
              
              #endif
1697          
1698          
1699          
1700          
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 68  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION Com0066 (BEGIN)
0000         L?0103:
0000         L?0104:
0000 900000      R     MOV     DPTR,#EncorderCount
0003         L?0105:
0003 74FF              MOV     A,#0FFH
0005 F5F0              MOV     B,A
0007 020000      E     LJMP    ?C?IILDX
000A         L?0106:
000A         L?0107:
000A 900000      R     MOV     DPTR,#EncorderCount
000D         L?0108:
000D 75F001            MOV     B,#01H
0010 020000      E     LJMP    ?C?IILDX
0013         L?0109:
0013 7BFF              MOV     R3,#0FFH
0015 900000      E     MOV     DPTR,#?_Printf?BYTE+03H
0018 F0                MOVX    @DPTR,A
0019 A3                INC     DPTR
001A 22                RET     
001B         L?0110:
001B         L?0111:
001B 900000      R     MOV     DPTR,#updn_reg
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 7E00              MOV     R6,#00H
0022 22                RET     
0023         L?0112:
0023         L?0113:
0023 C3                CLR     C
0024 941E              SUBB    A,#01EH
0026 7480              MOV     A,#080H
0028 9480              SUBB    A,#080H
002A 22                RET     
             ; FUNCTION Com0066 (END)

             ; FUNCTION main_init (BEGIN)
                                           ; SOURCE LINE # 292
                                           ; SOURCE LINE # 293
                                           ; SOURCE LINE # 316
0000 120000      E     LCALL   GetFWRevEE
0003 900000      R     MOV     DPTR,#rev
0006 EE                MOV     A,R6
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 EF                MOV     A,R7
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 317
000B 7A00        R     MOV     R2,#HIGH ?SC_0
000D 7900        R     MOV     R1,#LOW ?SC_0
000F EE                MOV     A,R6
0010 120000      R     LCALL   L?0109
0013 EF                MOV     A,R7
0014 F0                MOVX    @DPTR,A
0015 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 319
0018 120000      E     LCALL   GetFWRevEE
001B EF                MOV     A,R7
001C 6401              XRL     A,#01H
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 69  

001E 4E                ORL     A,R6
001F 6028              JZ      ?C0001
                                           ; SOURCE LINE # 320
                                           ; SOURCE LINE # 321
0021 7A00        R     MOV     R2,#HIGH ?SC_15
0023 7900        R     MOV     R1,#LOW ?SC_15
0025 E4                CLR     A
0026 120000      R     LCALL   L?0109
0029 04                INC     A
002A F0                MOVX    @DPTR,A
002B 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 322
002E 7F01              MOV     R7,#01H
0030 7E00              MOV     R6,#00H
0032 120000      E     LCALL   _SaveFWRevEE
                                           ; SOURCE LINE # 323
0035 120000      E     LCALL   GetFWRevEE
0038 900000      E     MOV     DPTR,#?_Printf?BYTE+03H
003B EE                MOV     A,R6
003C F0                MOVX    @DPTR,A
003D A3                INC     DPTR
003E EF                MOV     A,R7
003F F0                MOVX    @DPTR,A
0040 7BFF              MOV     R3,#0FFH
0042 7A00        R     MOV     R2,#HIGH ?SC_15
0044 7900        R     MOV     R1,#LOW ?SC_15
0046 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 324
0049         ?C0001:
                                           ; SOURCE LINE # 329
0049 120000      E     LCALL   GetFWRevEE
004C EF                MOV     A,R7
004D 6401              XRL     A,#01H
004F 4E                ORL     A,R6
0050 702C              JNZ     ?C0002
                                           ; SOURCE LINE # 330
                                           ; SOURCE LINE # 331
0052 900000      R     MOV     DPTR,#rev
0055 E0                MOVX    A,@DPTR
0056 7004              JNZ     ?C0092
0058 A3                INC     DPTR
0059 E0                MOVX    A,@DPTR
005A 6401              XRL     A,#01H
005C         ?C0092:
005C 6005              JZ      ?C0003
                                           ; SOURCE LINE # 332
                                           ; SOURCE LINE # 337
005E 120000      E     LCALL   ClearBasicEE
                                           ; SOURCE LINE # 343
0061 8034              SJMP    ?C0005
0063         ?C0003:
                                           ; SOURCE LINE # 345
                                           ; SOURCE LINE # 346
0063 120000      E     LCALL   GetDebugLevelEE
0066 900000      E     MOV     DPTR,#DebugLevel
0069 EF                MOV     A,R7
006A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 347
006B 7BFF              MOV     R3,#0FFH
006D 7A00        R     MOV     R2,#HIGH ?SC_30
006F 7900        R     MOV     R1,#LOW ?SC_30
0071 900000      E     MOV     DPTR,#?_Printf?BYTE+03H
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 70  

0074 E4                CLR     A
0075 F0                MOVX    @DPTR,A
0076 A3                INC     DPTR
0077 EF                MOV     A,R7
0078 F0                MOVX    @DPTR,A
0079 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 348
                                           ; SOURCE LINE # 350
007C 8019              SJMP    ?C0005
007E         ?C0002:
                                           ; SOURCE LINE # 352
                                           ; SOURCE LINE # 353
007E 7BFF              MOV     R3,#0FFH
0080 7A00        R     MOV     R2,#HIGH ?SC_54
0082 7900        R     MOV     R1,#LOW ?SC_54
0084 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 354
0087 7BFF              MOV     R3,#0FFH
0089 7A00        R     MOV     R2,#HIGH ?SC_81
008B 7900        R     MOV     R1,#LOW ?SC_81
008D 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 355
0090 900000      E     MOV     DPTR,#DebugLevel
0093 74FF              MOV     A,#0FFH
0095 F0                MOVX    @DPTR,A
0096 22                RET     
                                           ; SOURCE LINE # 361
0097         ?C0005:
                                           ; SOURCE LINE # 387
0097 7F64              MOV     R7,#064H
0099 120000      R     LCALL   _delay
                                           ; SOURCE LINE # 408
009C 7800        E     MOV     R0,#LOW g_stPowerInfo
009E E6                MOV     A,@R0
009F 540F              ANL     A,#0FH
00A1 4410              ORL     A,#010H
00A3 F6                MOV     @R0,A
                                           ; SOURCE LINE # 409
00A4 54F0              ANL     A,#0F0H
00A6 4402              ORL     A,#02H
00A8 F6                MOV     @R0,A
                                           ; SOURCE LINE # 411
00A9         ?C0006:
00A9 22                RET     
             ; FUNCTION main_init (END)

             ; FUNCTION InitCPU (BEGIN)
                                           ; SOURCE LINE # 419
                                           ; SOURCE LINE # 420
                                           ; SOURCE LINE # 430
0000 758DF4            MOV     TH1,#0F4H
                                           ; SOURCE LINE # 438
0003 759850            MOV     SCON,#050H
                                           ; SOURCE LINE # 440
0006 758922            MOV     TMOD,#022H
                                           ; SOURCE LINE # 442
0009 758855            MOV     TCON,#055H
                                           ; SOURCE LINE # 446
000C 758A40            MOV     TL0,#040H
000F 758C40            MOV     TH0,#040H
                                           ; SOURCE LINE # 448
0012 758780            MOV     PCON,#080H
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 71  

                                           ; SOURCE LINE # 449
0015 75B802            MOV     IP,#02H
                                           ; SOURCE LINE # 453
0018 75A892            MOV     IE,#092H
                                           ; SOURCE LINE # 456
001B D299              SETB    TI
                                           ; SOURCE LINE # 457
001D D2AC              SETB    ES
                                           ; SOURCE LINE # 463
001F E4                CLR     A
0020 F5C8              MOV     T2CON,A
                                           ; SOURCE LINE # 464
0022 C2CA              CLR     TR2
                                           ; SOURCE LINE # 465
0024 D2AD              SETB    ET2
                                           ; SOURCE LINE # 471
0026 75AA50            MOV     S2CON,#050H
                                           ; SOURCE LINE # 472
0029 75BAF4            MOV     S2BRT,#0F4H
                                           ; SOURCE LINE # 475
002C 43A618            ORL     AUXR2,#018H
                                           ; SOURCE LINE # 478
002F 43AD10            ORL     AUXIE,#010H
                                           ; SOURCE LINE # 480
0032 C200        R     CLR     RS2_Xbusy
                                           ; SOURCE LINE # 482
0034 F5E9              MOV     CL,A
                                           ; SOURCE LINE # 483
0036 F5F9              MOV     CH,A
                                           ; SOURCE LINE # 485
0038 F5D9              MOV     CMOD,A
                                           ; SOURCE LINE # 486
003A 43D840            ORL     CCON,#040H
                                           ; SOURCE LINE # 496
003D 75B120            MOV     P3M0,#020H
                                           ; SOURCE LINE # 497
0040 F5B2              MOV     P3M1,A
                                           ; SOURCE LINE # 500
0042 22                RET     
             ; FUNCTION InitCPU (END)

             ; FUNCTION _SET_PWM (BEGIN)
                                           ; SOURCE LINE # 503
;---- Variable 'val' assigned to Register 'R5' ----
;---- Variable 'index' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 504
                                           ; SOURCE LINE # 505
0000 EF                MOV     A,R7
0001 6026              JZ      ?C0011
0003 24EB              ADD     A,#0EBH
0005 6015              JZ      ?C0010
0007 2416              ADD     A,#016H
0009 6022              JZ      ?C0012
000B 24EB              ADD     A,#0EBH
000D 7021              JNZ     ?C0014
                                           ; SOURCE LINE # 506
                                           ; SOURCE LINE # 507
000F         ?C0009:
                                           ; SOURCE LINE # 511
000F 75ED80            MOV     CCAP3L,#080H
                                           ; SOURCE LINE # 512
0012 C3                CLR     C
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 72  

0013 74FF              MOV     A,#0FFH
0015 9D                SUBB    A,R5
0016 F5FD              MOV     CCAP3H,A
                                           ; SOURCE LINE # 513
0018 75DD42            MOV     CCAPM3,#042H
                                           ; SOURCE LINE # 514
001B 22                RET     
                                           ; SOURCE LINE # 515
001C         ?C0010:
                                           ; SOURCE LINE # 519
001C 75EE80            MOV     CCAP4L,#080H
                                           ; SOURCE LINE # 520
001F C3                CLR     C
0020 74FF              MOV     A,#0FFH
0022 9D                SUBB    A,R5
0023 F5FE              MOV     CCAP4H,A
                                           ; SOURCE LINE # 521
0025 75DE42            MOV     CCAPM4,#042H
                                           ; SOURCE LINE # 522
0028 22                RET     
                                           ; SOURCE LINE # 523
0029         ?C0011:
                                           ; SOURCE LINE # 524
0029 43D840            ORL     CCON,#040H
                                           ; SOURCE LINE # 525
002C 22                RET     
                                           ; SOURCE LINE # 526
002D         ?C0012:
                                           ; SOURCE LINE # 527
002D 53D840            ANL     CCON,#040H
                                           ; SOURCE LINE # 528
                                           ; SOURCE LINE # 530
                                           ; SOURCE LINE # 531
                                           ; SOURCE LINE # 532
                                           ; SOURCE LINE # 535
0030         ?C0014:
0030 22                RET     
             ; FUNCTION _SET_PWM (END)

             ; FUNCTION timer0_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C0D0              PUSH    PSW
000A 75D008            MOV     PSW,#08H
                                           ; SOURCE LINE # 544
                                           ; SOURCE LINE # 548
000D 0500        R     INC     tm001
                                           ; SOURCE LINE # 551
000F 0500        R     INC     tic02
                                           ; SOURCE LINE # 553
0011 C3                CLR     C
0012 E500        R     MOV     A,tic02
0014 940A              SUBB    A,#0AH
0016 7480              MOV     A,#080H
0018 9480              SUBB    A,#080H
001A 400C              JC      ?C0015
                                           ; SOURCE LINE # 554
                                           ; SOURCE LINE # 555
001C 900000      E     MOV     DPTR,#g_usTimerCounter
001F E4                CLR     A
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 73  

0020 120000      R     LCALL   L?0108
                                           ; SOURCE LINE # 556
0023 750000      R     MOV     tic02,#00H
                                           ; SOURCE LINE # 557
0026 D200        E     SETB    g_bNotifyTimer0Int
                                           ; SOURCE LINE # 558
0028         ?C0015:
                                           ; SOURCE LINE # 586
0028 AF00        R     MOV     R7,tic_Init_time+03H
002A AE00        R     MOV     R6,tic_Init_time+02H
002C AD00        R     MOV     R5,tic_Init_time+01H
002E AC00        R     MOV     R4,tic_Init_time
0030 EC                MOV     A,R4
0031 4D                ORL     A,R5
0032 4E                ORL     A,R6
0033 4F                ORL     A,R7
0034 6017              JZ      ?C0016
                                           ; SOURCE LINE # 587
0036 EF                MOV     A,R7
0037 24FF              ADD     A,#0FFH
0039 FF                MOV     R7,A
003A EE                MOV     A,R6
003B 34FF              ADDC    A,#0FFH
003D FE                MOV     R6,A
003E ED                MOV     A,R5
003F 34FF              ADDC    A,#0FFH
0041 FD                MOV     R5,A
0042 EC                MOV     A,R4
0043 34FF              ADDC    A,#0FFH
0045 8F00        R     MOV     tic_Init_time+03H,R7
0047 8E00        R     MOV     tic_Init_time+02H,R6
0049 8D00        R     MOV     tic_Init_time+01H,R5
004B F500        R     MOV     tic_Init_time,A
004D         ?C0016:
                                           ; SOURCE LINE # 588
004D 900000      R     MOV     DPTR,#Power_Msg_Count
0050 E0                MOVX    A,@DPTR
0051 7002              JNZ     ?C0093
0053 A3                INC     DPTR
0054 E0                MOVX    A,@DPTR
0055         ?C0093:
0055 6006              JZ      ?C0017
                                           ; SOURCE LINE # 589
0057 900000      R     MOV     DPTR,#Power_Msg_Count
005A 120000      R     LCALL   L?0105
005D         ?C0017:
                                           ; SOURCE LINE # 642
005D 900000      R     MOV     DPTR,#Time5ms
0060 E0                MOVX    A,@DPTR
0061 6002              JZ      ?C0018
                                           ; SOURCE LINE # 643
0063 14                DEC     A
0064 F0                MOVX    @DPTR,A
0065         ?C0018:
                                           ; SOURCE LINE # 644
0065 900000      R     MOV     DPTR,#Time5ms
0068 E0                MOVX    A,@DPTR
0069 6003              JZ      $ + 5H
006B 020000      R     LJMP    ?C0019
                                           ; SOURCE LINE # 645
                                           ; SOURCE LINE # 647
006E E5B0              MOV     A,P3
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 74  

0070 540C              ANL     A,#0CH
0072 13                RRC     A
0073 13                RRC     A
0074 5403              ANL     A,#03H
0076 FF                MOV     R7,A
;---- Variable 'TempKey' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 648
0077 900000      R     MOV     DPTR,#updn_reg+03H
007A E0                MOVX    A,@DPTR
007B 6F                XRL     A,R7
007C 7003              JNZ     $ + 5H
007E 020000      R     LJMP    ?C0019
                                           ; SOURCE LINE # 649
                                           ; SOURCE LINE # 650
0081 900000      R     MOV     DPTR,#updn_reg+01H
0084 E0                MOVX    A,@DPTR
0085 900000      R     MOV     DPTR,#updn_reg
0088 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 651
0089 900000      R     MOV     DPTR,#updn_reg+02H
008C E0                MOVX    A,@DPTR
008D 900000      R     MOV     DPTR,#updn_reg+01H
0090 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 652
0091 900000      R     MOV     DPTR,#updn_reg+03H
0094 E0                MOVX    A,@DPTR
0095 900000      R     MOV     DPTR,#updn_reg+02H
0098 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 653
0099 A3                INC     DPTR
009A EF                MOV     A,R7
009B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 654
009C D200        R     SETB    ChangeKey
                                           ; SOURCE LINE # 657
009E 900000      R     MOV     DPTR,#Time5ms
00A1 7430              MOV     A,#030H
00A3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 659
00A4 120000      R     LCALL   L?0110
00A7 7015              JNZ     ?C0021
00A9 A3                INC     DPTR
00AA E0                MOVX    A,@DPTR
00AB 6401              XRL     A,#01H
00AD 700F              JNZ     ?C0021
00AF A3                INC     DPTR
00B0 E0                MOVX    A,@DPTR
00B1 6403              XRL     A,#03H
00B3 7009              JNZ     ?C0021
00B5 A3                INC     DPTR
00B6 E0                MOVX    A,@DPTR
00B7 6402              XRL     A,#02H
00B9 7003              JNZ     ?C0021
                                           ; SOURCE LINE # 660
00BB 120000      R     LCALL   L?0106
00BE         ?C0021:
                                           ; SOURCE LINE # 661
00BE EF                MOV     A,R7
00BF 6401              XRL     A,#01H
00C1 4E                ORL     A,R6
00C2 7015              JNZ     ?C0022
00C4 900000      R     MOV     DPTR,#updn_reg+01H
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 75  

00C7 E0                MOVX    A,@DPTR
00C8 6403              XRL     A,#03H
00CA 700D              JNZ     ?C0022
00CC A3                INC     DPTR
00CD E0                MOVX    A,@DPTR
00CE 6402              XRL     A,#02H
00D0 7007              JNZ     ?C0022
00D2 A3                INC     DPTR
00D3 E0                MOVX    A,@DPTR
00D4 7003              JNZ     ?C0022
                                           ; SOURCE LINE # 662
00D6 120000      R     LCALL   L?0106
00D9         ?C0022:
                                           ; SOURCE LINE # 663
00D9 900000      R     MOV     DPTR,#updn_reg
00DC E0                MOVX    A,@DPTR
00DD 6403              XRL     A,#03H
00DF 7013              JNZ     ?C0023
00E1 A3                INC     DPTR
00E2 E0                MOVX    A,@DPTR
00E3 6402              XRL     A,#02H
00E5 700D              JNZ     ?C0023
00E7 A3                INC     DPTR
00E8 E0                MOVX    A,@DPTR
00E9 7009              JNZ     ?C0023
00EB A3                INC     DPTR
00EC E0                MOVX    A,@DPTR
00ED 6401              XRL     A,#01H
00EF 7003              JNZ     ?C0023
                                           ; SOURCE LINE # 664
00F1 120000      R     LCALL   L?0107
00F4         ?C0023:
                                           ; SOURCE LINE # 665
00F4 120000      R     LCALL   L?0110
00F7 6402              XRL     A,#02H
00F9 7013              JNZ     ?C0024
00FB A3                INC     DPTR
00FC E0                MOVX    A,@DPTR
00FD 700F              JNZ     ?C0024
00FF A3                INC     DPTR
0100 E0                MOVX    A,@DPTR
0101 6401              XRL     A,#01H
0103 7009              JNZ     ?C0024
0105 A3                INC     DPTR
0106 E0                MOVX    A,@DPTR
0107 6403              XRL     A,#03H
0109 7003              JNZ     ?C0024
                                           ; SOURCE LINE # 666
010B 120000      R     LCALL   L?0107
010E         ?C0024:
                                           ; SOURCE LINE # 668
010E EF                MOV     A,R7
010F 4E                ORL     A,R6
0110 7017              JNZ     ?C0025
0112 900000      R     MOV     DPTR,#updn_reg+01H
0115 E0                MOVX    A,@DPTR
0116 6402              XRL     A,#02H
0118 700F              JNZ     ?C0025
011A A3                INC     DPTR
011B E0                MOVX    A,@DPTR
011C 6403              XRL     A,#03H
011E 7009              JNZ     ?C0025
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 76  

0120 A3                INC     DPTR
0121 E0                MOVX    A,@DPTR
0122 6401              XRL     A,#01H
0124 7003              JNZ     ?C0025
                                           ; SOURCE LINE # 669
0126 120000      R     LCALL   L?0103
0129         ?C0025:
                                           ; SOURCE LINE # 670
0129 900000      R     MOV     DPTR,#updn_reg
012C E0                MOVX    A,@DPTR
012D 6402              XRL     A,#02H
012F 7013              JNZ     ?C0026
0131 A3                INC     DPTR
0132 E0                MOVX    A,@DPTR
0133 6403              XRL     A,#03H
0135 700D              JNZ     ?C0026
0137 A3                INC     DPTR
0138 E0                MOVX    A,@DPTR
0139 6401              XRL     A,#01H
013B 7007              JNZ     ?C0026
013D A3                INC     DPTR
013E E0                MOVX    A,@DPTR
013F 7003              JNZ     ?C0026
                                           ; SOURCE LINE # 671
0141 120000      R     LCALL   L?0103
0144         ?C0026:
                                           ; SOURCE LINE # 672
0144 120000      R     LCALL   L?0111
0147 6403              XRL     A,#03H
0149 7013              JNZ     ?C0027
014B A3                INC     DPTR
014C E0                MOVX    A,@DPTR
014D 6401              XRL     A,#01H
014F 700D              JNZ     ?C0027
0151 A3                INC     DPTR
0152 E0                MOVX    A,@DPTR
0153 7009              JNZ     ?C0027
0155 A3                INC     DPTR
0156 E0                MOVX    A,@DPTR
0157 6402              XRL     A,#02H
0159 7003              JNZ     ?C0027
                                           ; SOURCE LINE # 673
015B 120000      R     LCALL   L?0104
015E         ?C0027:
                                           ; SOURCE LINE # 674
015E EF                MOV     A,R7
015F 6401              XRL     A,#01H
0161 4E                ORL     A,R6
0162 7015              JNZ     ?C0019
0164 900000      R     MOV     DPTR,#updn_reg+01H
0167 E0                MOVX    A,@DPTR
0168 700F              JNZ     ?C0019
016A A3                INC     DPTR
016B E0                MOVX    A,@DPTR
016C 6402              XRL     A,#02H
016E 7009              JNZ     ?C0019
0170 A3                INC     DPTR
0171 E0                MOVX    A,@DPTR
0172 6403              XRL     A,#03H
0174 7003              JNZ     ?C0019
                                           ; SOURCE LINE # 675
0176 120000      R     LCALL   L?0104
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 77  

                                           ; SOURCE LINE # 678
                                           ; SOURCE LINE # 679
0179         ?C0019:
                                           ; SOURCE LINE # 687
0179 D3                SETB    C
017A E500        R     MOV     A,tm001
017C 9460              SUBB    A,#060H
017E 7480              MOV     A,#080H
0180 9480              SUBB    A,#080H
0182 4067              JC      ?C0039
                                           ; SOURCE LINE # 690
0184 0500        R     INC     stopWatch+01H
0186 E500        R     MOV     A,stopWatch+01H
0188 7002              JNZ     ?C0094
018A 0500        R     INC     stopWatch
018C         ?C0094:
                                           ; SOURCE LINE # 691
018C 750000      R     MOV     tm001,#00H
                                           ; SOURCE LINE # 692
018F 0500        R     INC     tic01
                                           ; SOURCE LINE # 694
0191 E500        R     MOV     A,tic01
0193 6464              XRL     A,#064H
0195 7010              JNZ     ?C0030
                                           ; SOURCE LINE # 695
                                           ; SOURCE LINE # 698
0197 F500        R     MOV     tic01,A
                                           ; SOURCE LINE # 735
0199 E500        R     MOV     A,Key
019B 900000      R     MOV     DPTR,#keyticSec
019E 6005              JZ      ?C0031
                                           ; SOURCE LINE # 736
01A0 E0                MOVX    A,@DPTR
01A1 04                INC     A
01A2 F0                MOVX    @DPTR,A
01A3 8002              SJMP    ?C0030
01A5         ?C0031:
                                           ; SOURCE LINE # 738
01A5 E4                CLR     A
01A6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 745
01A7         ?C0030:
                                           ; SOURCE LINE # 746
01A7 E500        R     MOV     A,tic_pc+01H
01A9 F4                CPL     A
01AA 7003              JNZ     ?C0095
01AC E500        R     MOV     A,tic_pc
01AE F4                CPL     A
01AF         ?C0095:
01AF 6008              JZ      ?C0033
                                           ; SOURCE LINE # 747
01B1 0500        R     INC     tic_pc+01H
01B3 E500        R     MOV     A,tic_pc+01H
01B5 7002              JNZ     ?C0096
01B7 0500        R     INC     tic_pc
01B9         ?C0096:
01B9         ?C0033:
                                           ; SOURCE LINE # 751
01B9 E5E8              MOV     A,P4
01BB F4                CPL     A
01BC FF                MOV     R7,A
01BD 13                RRC     A
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 78  

01BE 13                RRC     A
01BF 13                RRC     A
01C0 541F              ANL     A,#01FH
01C2 30E020            JNB     ACC.0,?C0034
                                           ; SOURCE LINE # 752
                                           ; SOURCE LINE # 753
01C5 AF00        R     MOV     R7,keytic
01C7 7E00              MOV     R6,#00H
01C9 EF                MOV     A,R7
01CA 6403              XRL     A,#03H
01CC 7006              JNZ     ?C0035
                                           ; SOURCE LINE # 754
                                           ; SOURCE LINE # 756
01CE C200        R     CLR     RepeatKey
                                           ; SOURCE LINE # 757
01D0 D200        R     SETB    KeyReady
                                           ; SOURCE LINE # 758
01D2 800D              SJMP    ?C0036
01D4         ?C0035:
                                           ; SOURCE LINE # 759
01D4 EF                MOV     A,R7
01D5 6464              XRL     A,#064H
01D7 4E                ORL     A,R6
01D8 7007              JNZ     ?C0036
                                           ; SOURCE LINE # 761
01DA D200        R     SETB    RepeatKey
                                           ; SOURCE LINE # 762
01DC D200        R     SETB    KeyReady
                                           ; SOURCE LINE # 763
01DE 750050      R     MOV     keytic,#050H
                                           ; SOURCE LINE # 764
01E1         ?C0036:
                                           ; SOURCE LINE # 765
01E1 0500        R     INC     keytic
                                           ; SOURCE LINE # 766
01E3 8006              SJMP    ?C0039
01E5         ?C0034:
                                           ; SOURCE LINE # 768
                                           ; SOURCE LINE # 769
01E5 750000      R     MOV     keytic,#00H
                                           ; SOURCE LINE # 770
01E8 750000      R     MOV     Key,#00H
                                           ; SOURCE LINE # 771
                                           ; SOURCE LINE # 774
                                           ; SOURCE LINE # 775
01EB         ?C0039:
01EB D0D0              POP     PSW
01ED D082              POP     DPL
01EF D083              POP     DPH
01F1 D0F0              POP     B
01F3 D0E0              POP     ACC
01F5 32                RETI    
             ; FUNCTION timer0_int (END)

             ; FUNCTION InitVars (BEGIN)
                                           ; SOURCE LINE # 779
                                           ; SOURCE LINE # 780
                                           ; SOURCE LINE # 782
;---- Variable 'j' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
0002         ?C0040:
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 79  

0002 EF                MOV     A,R7
0003 C3                CLR     C
0004 941D              SUBB    A,#01DH
0006 7480              MOV     A,#080H
0008 9480              SUBB    A,#080H
000A 5009              JNC     ?C0043
                                           ; SOURCE LINE # 783
000C 7400        R     MOV     A,#LOW DVR_buf
000E 2F                ADD     A,R7
000F F8                MOV     R0,A
0010 E4                CLR     A
0011 F6                MOV     @R0,A
0012 0F                INC     R7
0013 80ED              SJMP    ?C0040
                                           ; SOURCE LINE # 806
0015         ?C0043:
0015 22                RET     
             ; FUNCTION InitVars (END)

             ; FUNCTION _PowerLED (BEGIN)
                                           ; SOURCE LINE # 864
;---- Variable 'flag' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 865
                                           ; SOURCE LINE # 890
0000 EF                MOV     A,R7
0001 120000      E     LCALL   ?C?CCASE
0004 0000        R     DW      ?C0045
0006 25                DB      025H
0007 0000        R     DW      ?C0047
0009 26                DB      026H
000A 0000        R     DW      ?C0049
000C 27                DB      027H
000D 0000        R     DW      ?C0051
000F 28                DB      028H
0010 0000        R     DW      ?C0056
0012 29                DB      029H
0013 0000        R     DW      ?C0059
0015 2A                DB      02AH
0016 0000        R     DW      ?C0062
0018 2B                DB      02BH
0019 0000        R     DW      ?C0053
001B 2C                DB      02CH
001C 0000        R     DW      ?C0065
001E 2D                DB      02DH
001F 0000              DW      00H
0021 0000        R     DW      ?C0069
                                           ; SOURCE LINE # 891
                                           ; SOURCE LINE # 892
0023         ?C0045:
                                           ; SOURCE LINE # 893
0023 E5E8              MOV     A,P4
0025 30E07B            JNB     ACC.0,?C0069
                                           ; SOURCE LINE # 894
0028 53E8FE            ANL     P4,#0FEH
                                           ; SOURCE LINE # 895
002B 22                RET     
                                           ; SOURCE LINE # 896
002C         ?C0047:
                                           ; SOURCE LINE # 897
002C E5E8              MOV     A,P4
002E 5401              ANL     A,#01H
0030 7071              JNZ     ?C0069
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 80  

                                           ; SOURCE LINE # 898
0032 43E801            ORL     P4,#01H
                                           ; SOURCE LINE # 899
0035 22                RET     
                                           ; SOURCE LINE # 900
0036         ?C0049:
                                           ; SOURCE LINE # 901
0036 E5E8              MOV     A,P4
0038 30E168            JNB     ACC.1,?C0069
                                           ; SOURCE LINE # 902
003B 53E8FD            ANL     P4,#0FDH
                                           ; SOURCE LINE # 903
003E 22                RET     
                                           ; SOURCE LINE # 904
003F         ?C0051:
                                           ; SOURCE LINE # 905
003F E5E8              MOV     A,P4
0041 5402              ANL     A,#02H
0043 705E              JNZ     ?C0069
                                           ; SOURCE LINE # 906
0045 43E802            ORL     P4,#02H
                                           ; SOURCE LINE # 907
0048 22                RET     
                                           ; SOURCE LINE # 908
0049         ?C0053:
                                           ; SOURCE LINE # 909
0049 E5E8              MOV     A,P4
004B 30E003            JNB     ACC.0,?C0054
                                           ; SOURCE LINE # 910
004E 53E8FE            ANL     P4,#0FEH
0051         ?C0054:
                                           ; SOURCE LINE # 911
0051 E5E8              MOV     A,P4
0053 30E14D            JNB     ACC.1,?C0069
                                           ; SOURCE LINE # 912
0056 53E8FC            ANL     P4,#0FCH
                                           ; SOURCE LINE # 913
0059 22                RET     
                                           ; SOURCE LINE # 914
005A         ?C0056:
                                           ; SOURCE LINE # 915
005A E5E8              MOV     A,P4
005C 30E005            JNB     ACC.0,?C0057
                                           ; SOURCE LINE # 916
                                           ; SOURCE LINE # 917
005F 53E8FE            ANL     P4,#0FEH
                                           ; SOURCE LINE # 918
0062 8003              SJMP    ?C0058
0064         ?C0057:
                                           ; SOURCE LINE # 920
                                           ; SOURCE LINE # 921
0064 43E801            ORL     P4,#01H
                                           ; SOURCE LINE # 922
0067         ?C0058:
                                           ; SOURCE LINE # 923
0067 7D29              MOV     R5,#029H
                                           ; SOURCE LINE # 924
0069 8031              SJMP    ?C0101
                                           ; SOURCE LINE # 925
006B         ?C0059:
                                           ; SOURCE LINE # 926
006B E5E8              MOV     A,P4
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 81  

006D 30E105            JNB     ACC.1,?C0060
                                           ; SOURCE LINE # 927
                                           ; SOURCE LINE # 928
0070 53E8FD            ANL     P4,#0FDH
                                           ; SOURCE LINE # 929
0073 8003              SJMP    ?C0061
0075         ?C0060:
                                           ; SOURCE LINE # 931
                                           ; SOURCE LINE # 932
0075 43E802            ORL     P4,#02H
                                           ; SOURCE LINE # 933
0078         ?C0061:
                                           ; SOURCE LINE # 934
0078 7D2A              MOV     R5,#02AH
007A         ?C0099:
                                           ; SOURCE LINE # 935
007A 8020              SJMP    ?C0101
                                           ; SOURCE LINE # 936
007C         ?C0062:
                                           ; SOURCE LINE # 937
007C E5E8              MOV     A,P4
007E 30E005            JNB     ACC.0,?C0063
                                           ; SOURCE LINE # 938
                                           ; SOURCE LINE # 939
0081 53E8FC            ANL     P4,#0FCH
                                           ; SOURCE LINE # 940
0084 8003              SJMP    ?C0064
0086         ?C0063:
                                           ; SOURCE LINE # 942
                                           ; SOURCE LINE # 943
0086 43E803            ORL     P4,#03H
                                           ; SOURCE LINE # 944
0089         ?C0064:
                                           ; SOURCE LINE # 945
0089 7D2B              MOV     R5,#02BH
008B         ?C0100:
                                           ; SOURCE LINE # 946
008B 800F              SJMP    ?C0101
                                           ; SOURCE LINE # 947
008D         ?C0065:
                                           ; SOURCE LINE # 948
008D E5E8              MOV     A,P4
008F 30E105            JNB     ACC.1,?C0066
                                           ; SOURCE LINE # 949
                                           ; SOURCE LINE # 950
0092 53E8FC            ANL     P4,#0FCH
                                           ; SOURCE LINE # 951
0095 8003              SJMP    ?C0067
0097         ?C0066:
                                           ; SOURCE LINE # 953
                                           ; SOURCE LINE # 954
0097 43E802            ORL     P4,#02H
                                           ; SOURCE LINE # 955
009A         ?C0067:
                                           ; SOURCE LINE # 956
009A 7D2D              MOV     R5,#02DH
009C         ?C0101:
009C 7FE8              MOV     R7,#0E8H
009E 7E03              MOV     R6,#03H
00A0 120000      E     LCALL   _MCUTimerActiveTimerEvent
                                           ; SOURCE LINE # 957
                                           ; SOURCE LINE # 958
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 82  

                                           ; SOURCE LINE # 959
                                           ; SOURCE LINE # 960
                                           ; SOURCE LINE # 961
00A3         ?C0069:
00A3 22                RET     
             ; FUNCTION _PowerLED (END)

             ; FUNCTION ext1_int (BEGIN)
                                           ; SOURCE LINE # 970
                                           ; SOURCE LINE # 972
0000 C2AA              CLR     EX1
                                           ; SOURCE LINE # 973
0002 32                RETI    
             ; FUNCTION ext1_int (END)

             ; FUNCTION serial_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0D0              PUSH    PSW
0004 75D008            MOV     PSW,#08H
                                           ; SOURCE LINE # 1088
                                           ; SOURCE LINE # 1094
0007 309815            JNB     RI,?C0071
                                           ; SOURCE LINE # 1103
000A 7400        R     MOV     A,#LOW DVR_buf
000C 2500        R     ADD     A,RS_in
000E F8                MOV     R0,A
000F A699              MOV     @R0,SBUF
                                           ; SOURCE LINE # 1104
0011 0500        R     INC     RS_in
                                           ; SOURCE LINE # 1105
0013 E500        R     MOV     A,RS_in
0015 120000      R     LCALL   L?0112
0018 4003              JC      ?C0072
001A 750000      R     MOV     RS_in,#00H
001D         ?C0072:
                                           ; SOURCE LINE # 1109
001D C298              CLR     RI
                                           ; SOURCE LINE # 1111
001F         ?C0071:
                                           ; SOURCE LINE # 1113
001F 309904            JNB     TI,?C0074
                                           ; SOURCE LINE # 1114
0022 C299              CLR     TI
                                           ; SOURCE LINE # 1115
0024 C200        R     CLR     RS_Xbusy
                                           ; SOURCE LINE # 1116
                                           ; SOURCE LINE # 1117
0026         ?C0074:
0026 D0D0              POP     PSW
0028 D0E0              POP     ACC
002A 32                RETI    
             ; FUNCTION serial_int (END)

             ; FUNCTION serial2_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0D0              PUSH    PSW
                                           ; SOURCE LINE # 1121
                                           ; SOURCE LINE # 1126
0004 E5AA              MOV     A,S2CON
0006 5401              ANL     A,#01H
0008 6401              XRL     A,#01H
000A 700F              JNZ     ?C0075
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 83  

                                           ; SOURCE LINE # 1127
                                           ; SOURCE LINE # 1129
000C 53AAFE            ANL     S2CON,#0FEH
                                           ; SOURCE LINE # 1134
000F 0500        R     INC     RS2_in
                                           ; SOURCE LINE # 1135
0011 E500        R     MOV     A,RS2_in
0013 120000      R     LCALL   L?0112
0016 4003              JC      ?C0075
0018 750000      R     MOV     RS2_in,#00H
                                           ; SOURCE LINE # 1136
001B         ?C0075:
                                           ; SOURCE LINE # 1138
001B E5AA              MOV     A,S2CON
001D 5402              ANL     A,#02H
001F 6402              XRL     A,#02H
0021 7005              JNZ     ?C0078
                                           ; SOURCE LINE # 1139
                                           ; SOURCE LINE # 1140
0023 53AAFD            ANL     S2CON,#0FDH
                                           ; SOURCE LINE # 1141
0026 C200        R     CLR     RS2_Xbusy
                                           ; SOURCE LINE # 1142
                                           ; SOURCE LINE # 1143
0028         ?C0078:
0028 D0D0              POP     PSW
002A D0E0              POP     ACC
002C 32                RETI    
             ; FUNCTION serial2_int (END)

             ; FUNCTION RS_ready (BEGIN)
                                           ; SOURCE LINE # 1150
                                           ; SOURCE LINE # 1151
                                           ; SOURCE LINE # 1152
0000 E500        R     MOV     A,RS_in
0002 B50003      R     CJNE    A,RS_out,?C0079
0005 7F00              MOV     R7,#00H
0007 22                RET     
0008         ?C0079:
                                           ; SOURCE LINE # 1153
0008 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 1154
000A         ?C0080:
000A 22                RET     
             ; FUNCTION RS_ready (END)

             ; FUNCTION RS_rx (BEGIN)
                                           ; SOURCE LINE # 1159
                                           ; SOURCE LINE # 1160
                                           ; SOURCE LINE # 1163
0000 C2AC              CLR     ES
                                           ; SOURCE LINE # 1165
0002 7400        R     MOV     A,#LOW DVR_buf
0004 2500        R     ADD     A,RS_out
0006 F8                MOV     R0,A
0007 E6                MOV     A,@R0
0008 FF                MOV     R7,A
;---- Variable 'ret' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1166
0009 0500        R     INC     RS_out
                                           ; SOURCE LINE # 1168
000B E500        R     MOV     A,RS_out
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 84  

000D 120000      R     LCALL   L?0113
0010 4003              JC      ?C0082
                                           ; SOURCE LINE # 1169
0012 E4                CLR     A
0013 F500        R     MOV     RS_out,A
0015         ?C0082:
                                           ; SOURCE LINE # 1170
0015 D2AC              SETB    ES
                                           ; SOURCE LINE # 1172
                                           ; SOURCE LINE # 1173
0017 22                RET     
             ; FUNCTION RS_rx (END)

             ; FUNCTION _RS_tx (BEGIN)
                                           ; SOURCE LINE # 1178
;---- Variable 'tx_buf' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1179
0000         ?C0084:
                                           ; SOURCE LINE # 1180
0000 2000FD      R     JB      RS_Xbusy,?C0084
                                           ; SOURCE LINE # 1181
0003 8F99              MOV     SBUF,R7
                                           ; SOURCE LINE # 1182
0005 D200        R     SETB    RS_Xbusy
                                           ; SOURCE LINE # 1183
0007 22                RET     
             ; FUNCTION _RS_tx (END)

             ; FUNCTION timer2_int (BEGIN)
0000 C0E0              PUSH    ACC
                                           ; SOURCE LINE # 1243
                                           ; SOURCE LINE # 1245
0002 C2CF              CLR     TF2
                                           ; SOURCE LINE # 1247
0004 0500        R     INC     tm01+01H
0006 E500        R     MOV     A,tm01+01H
0008 7002              JNZ     ?C0097
000A 0500        R     INC     tm01
000C         ?C0097:
                                           ; SOURCE LINE # 1379
000C D0E0              POP     ACC
000E 32                RETI    
             ; FUNCTION timer2_int (END)

             ; FUNCTION _delay (BEGIN)
                                           ; SOURCE LINE # 1382
;---- Variable 'cnt' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1383
                                           ; SOURCE LINE # 1386
0000 E500        R     MOV     A,tic01
0002 2F                ADD     A,R7
0003 FF                MOV     R7,A
0004 E4                CLR     A
0005 33                RLC     A
0006 FE                MOV     R6,A
0007 7C00              MOV     R4,#00H
0009 7D64              MOV     R5,#064H
000B 120000      E     LCALL   ?C?UIDIV
;---- Variable 'ttic01' assigned to Register 'R4/R5' ----
                                           ; SOURCE LINE # 1387
                                           ; SOURCE LINE # 1389
000E         ?C0088:
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 85  

000E E500        R     MOV     A,tic01
0010 B505FB            CJNE    A,AR5,?C0088
0013 E4                CLR     A
0014 B504F7            CJNE    A,AR4,?C0088
                                           ; SOURCE LINE # 1390
0017 22                RET     
             ; FUNCTION _delay (END)

C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 86  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_SCALER_TIMER_EVENT_DP_LINK_STATUS_IRQ  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_GO_TO_POWER_SAVING .  E_CONST  -----  U_CHAR   -----  1
InitCPU. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_SCALER_TIMER_EVENT_AUDIO_LOAD_STABLE_  E_CONST  -----  U_CHAR   -----  1
P3M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B1H  1
EnumBatteryStatus. . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_START. . . . . . .  E_CONST  -----  U_CHAR   -----  1
timer0_int . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  TempKey. . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   000FH  1
FormatSDCard . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0000H  1
P3M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B2H  1
EnumModeAction . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
DWORD. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
P3 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B0H  1
timer2_int . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
P4 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
_POWER_ACTION_NORMAL_TO_NOSUPPORT_PS .  E_CONST  -----  U_CHAR   -----  1
FormatWait . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0001H  1
_SYSTEM_TIMER_EVENT_JUDGE_BTH_STATE. .  E_CONST  -----  U_CHAR   -----  1
Power_Msg_Count. . . . . . . . . . . .  PUBLIC   XDATA  U_INT    0002H  2
_BATT_STATUS_CAPACITY_HIGH . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_DISABLE. . . . .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_STOP_CHARGE . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_RED_OFF. . . . . .  E_CONST  -----  U_CHAR   -----  1
g_bNotifyTimer0Int . . . . . . . . . .  EXTERN   DATA   BIT      -----  1
_SYSTEM_TIMER_EVENT_SOURCE_CLEAR_DETEC  E_CONST  -----  U_CHAR   -----  1
CH . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F9H  1
_BATT_STATUS_ABNORMAL_MODE . . . . . .  E_CONST  -----  U_CHAR   -----  1
EnumPowerAction. . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_SHOW_NO_CABLE. .  E_CONST  -----  U_CHAR   -----  1
DVR_buf. . . . . . . . . . . . . . . .  PUBLIC   DATA   ARRAY    0000H  30
keytic . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   001EH  1
_MODE_STATUS_NOSIGNAL. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_STATUS_NOSUPPORT . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_RESET_TO_DISPLAY_SETTING.  E_CONST  -----  U_CHAR   -----  1
IE . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
CL . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E9H  1
RS2_in . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   001FH  1
RepeatKey. . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0000H  1
LED_FLASH_COUNT. . . . . . . . . . . .  PUBLIC   XDATA  U_INT    0004H  2
_delay . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  cnt. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  ttic01 . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
_BATT_STATUS_CAPACITY_LEVEL1 . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_NO_RESET_MODE . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_KEY_SCAN_READY . . .  E_CONST  -----  U_CHAR   -----  1
GetDebugLevelEE. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_BATT_STATUS_CAPACITY_LEVEL2 . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_GRN_RED_ON . . . .  E_CONST  -----  U_CHAR   -----  1
CCAP3H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FDH  1
_BATT_STATUS_CAPACITY_LEVEL3 . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_RESET_TO_FACTORY_MODE . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_NOSUPPORT_PS_TO_OFF. . .  E_CONST  -----  U_CHAR   -----  1
CCAP4H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FEH  1
_BATT_STATUS_CAPACITY_LEVEL4 . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_GRN_OFF. . . . . .  E_CONST  -----  U_CHAR   -----  1
EnumMCUTimerEventID. . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 87  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


ES . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
CCAP3L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EDH  1
_BATT_STATUS_TEMP_NORMAL . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_NR_DETECTION_FINIS  E_CONST  -----  U_CHAR   -----  1
CCAP4L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EEH  1
CCAPM3 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DDH  1
IP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
_POWER_STATUS_AC_ON. . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CCAPM4 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DEH  1
g_usTimerCounter . . . . . . . . . . .  EXTERN   XDATA  U_INT    -----  2
RI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
TI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
_SCALER_TIMER_EVENT_END. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_SHOW_BURN_IN . . . .  E_CONST  -----  U_CHAR   -----  1
RS_ready . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
StructBatteryInfoType. . . . . . . . .  TYPEDEF  -----  STRUCT   -----  4
  b5BatteryStatus. . . . . . . . . . .  MEMBER   -----  FIELD    0000H  5.0
  b1NoBattery. . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.5
  b1AC_PLUG. . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.6
  b3BTHStatus. . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  3.0
  b1BatteryCapacityLow . . . . . . . .  MEMBER   -----  FIELD    0001H  1.3
  b1BatteryAbnormal. . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.4
  b2BatteryChargeStatus. . . . . . . .  MEMBER   -----  FIELD    0001H  2.5
  BatteryCapacity. . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
_USER_TIMER_EVENT_OSD_ENCODER_DEVIATIO  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_RED_BLINK. . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_DP_HOTPLUG_ASSERTED E_CONST  -----  U_CHAR   -----  1
_POWER_STATUS_NOSUPPORT_SAVING . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_JUDGE_PSW_STATE. .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_END. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_NONE . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
tic01. . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0020H  1
KeyReady . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0001H  1
_POWER_ACTION_AC_ON_TO_NORMAL. . . . .  E_CONST  -----  U_CHAR   -----  1
RS_Xbusy . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0002H  1
tic02. . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0021H  1
CMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D9H  1
CCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
_MODE_ACTION_RESET_TO_DISPLAY_SETTING_  E_CONST  -----  U_CHAR   -----  1
StructTimerEventTableType. . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  b1EventValid . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.0
  b7EventID. . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  7.1
  usTime . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0001H  2
_USER_TIMER_EVENT_PANEL_BACKLIGHT_ON .  E_CONST  -----  U_CHAR   -----  1
Time5ms. . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0006H  1
EnumModeStatus . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_CHECK. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
keyticSec. . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0007H  1
Key. . . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0022H  1
_MODE_ACTION_RESET_TO_SEARCH . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_GRN_BLINK. . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_RESET_TO_POWER_SAVING . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_DVR_REBOOT . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_MHL_D0_READY_TO_TR  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_MHL_D1_READY_TO_TR  E_CONST  -----  U_CHAR   -----  1
serial_int . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
ext1_int . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 88  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


SBUF . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
PCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0087H  1
EnumPowerStatus. . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_PANEL_USED_TIMER . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_AC_ON_TO_OFF . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_JUDGE_WDT_ECHO . .  E_CONST  -----  U_CHAR   -----  1
SCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
_BATT_STATUS_LOW_CHARGE. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
InitVars . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  j. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
TMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0089H  1
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
_SYSTEM_TIMER_EVENT_JUDGE_POWER_STATE.  E_CONST  -----  U_CHAR   -----  1
BYTE . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_MODE_ACTION_NONE. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_TMDS_HDMI_PACKET_D  E_CONST  -----  U_CHAR   -----  1
EnumSystemTimerEventID . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_LED_POWER_SAVING . .  E_CONST  -----  U_CHAR   -----  1
_MODE_STATUS_INITIAL . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_RESET_TO_POWER_OFF. . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_MHL_D0_ACTIVE_VBUS  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_JUDGE_DVR_COMM . .  E_CONST  -----  U_CHAR   -----  1
WORD . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
main_init. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  rev. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0000H  2
_SCALER_TIMER_EVENT_MHL_D1_ACTIVE_VBUS  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_TEMP_LOW. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_AC_MODE . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_PHASE_CNT_CHECK. .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_HLWIN_TYPE5_MOVE . .  E_CONST  -----  U_CHAR   -----  1
_SET_PWM . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  index. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  val. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
_USER_TIMER_EVENT_OSD_GET_MCU_VERSION.  E_CONST  -----  U_CHAR   -----  1
PowerDownWait. . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0008H  1
tm01 . . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0023H  2
stopWatch. . . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0025H  2
EncorderCount. . . . . . . . . . . . .  PUBLIC   XDATA  INT      0009H  2
RS_buf . . . . . . . . . . . . . . . .  STATIC   DATA   ARRAY    0027H  8
_POWER_ACTION_NORMAL_TO_PS . . . . . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_PS_TO_NORMAL . . . . . .  E_CONST  -----  U_CHAR   -----  1
StructModeInfoType . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  b5ModeState. . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  5.0
  b1DisplaySettingReady. . . . . . . .  MEMBER   -----  FIELD    0000H  1.5
  b1TimingConfirm. . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.6
  b1ModeStateChanged . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.7
  b4ModeResetFlag. . . . . . . . . . .  MEMBER   -----  FIELD    0001H  4.0
  b1NoWaitForActive. . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.4
  b1ActiveReady. . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.5
_USER_TIMER_EVENT_OSD_DISTANCE_RESET .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_PHASE_CALIBRATION.  E_CONST  -----  U_CHAR   -----  1
tic_PWR_SAVING . . . . . . . . . . . .  PUBLIC   DATA   U_LONG   002FH  4
_POWER_STATUS_NONE . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_END. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_STATUS_FACTORY . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_STATUS_DISPLAY_SETTING . . . . .  E_CONST  -----  U_CHAR   -----  1
tic_Init_time. . . . . . . . . . . . .  PUBLIC   DATA   U_LONG   0033H  4
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 89  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_SYSTEM_TIMER_EVENT_RED_ON . . . . . .  E_CONST  -----  U_CHAR   -----  1
Register . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
ET2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ADH  1
TF2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CFH  1
TH0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008CH  1
TH1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008DH  1
_SYSTEM_TIMER_EVENT_JUDGE_AC_MODE. . .  E_CONST  -----  U_CHAR   -----  1
EX1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AAH  1
StructPowerInfoType. . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  b4PowerAction. . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  4.0
  b4PowerStatus. . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  4.4
  b1GDIIsolationFlag . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.0
  b1TopIsolationFlag . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.1
  b1AnalogIsolationFlag. . . . . . . .  MEMBER   -----  FIELD    0001H  1.2
_USER_TIMER_EVENT_OSD_MCU_ENTRY_SLEEP_  E_CONST  -----  U_CHAR   -----  1
g_stPowerInfo. . . . . . . . . . . . .  EXTERN   IDATA  STRUCT   -----  2
TL0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008AH  1
_MODE_ACTION_RESET_TO_NOSIGNAL . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_RESET_TO_NOSUPPORT. . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_COUNT. . . . . . .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_START_CHARGE. . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_JUDGE_BATT_STATE .  E_CONST  -----  U_CHAR   -----  1
EnumUserTimerEventID . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_POWER_ACTION_PS_TO_OFF. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_COUNT. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_START. . . . . . .  E_CONST  -----  U_CHAR   -----  1
RS2_Xbusy. . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0003H  1
_MCUTimerActiveTimerEvent. . . . . . .  EXTERN   CODE   PROC     -----  -----
_SYSTEM_TIMER_EVENT_GRN_ON . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_JUDGE_TW8836_COMM.  E_CONST  -----  U_CHAR   -----  1
TR2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CAH  1
_SCALER_TIMER_EVENT_DP_HDCP_LONG_HOTPL  E_CONST  -----  U_CHAR   -----  1
updn_reg . . . . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    000BH  4
RegisterInfo . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  6
  Min. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  Max. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0002H  2
  Default. . . . . . . . . . . . . . .  MEMBER   -----  INT      0004H  2
_BATT_STATUS_CAPACITY_LOW. . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_DO_AUTO_COLOR. . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_START. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
PWR_SAVING_ACT_FLAG. . . . . . . . . .  PUBLIC   DATA   BIT      0004H  1
ClearBasicEE . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_POWER_ACTION_NOSUPPORT_PS_TO_PS . . .  E_CONST  -----  U_CHAR   -----  1
RS_in. . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0037H  1
_BATT_STATUS_NO_BATT . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_MHL_D0_RECONNECT_1K E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_DVR_SHUTDOWN . .  E_CONST  -----  U_CHAR   -----  1
RS_out . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0038H  1
_MODE_STATUS_NONE. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_MHL_D1_RECONNECT_1K E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_CAMERA_VOLTAGE_DECE_CONST  -----  U_CHAR   -----  1
_POWER_STATUS_SAVING . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_KEY_REPEAT_ENABLE. .  E_CONST  -----  U_CHAR   -----  1
_POWER_STATUS_NORMAL . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
serial2_int. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
DebugLevel . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
_BATT_STATUS_NONE. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 90  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_SYSTEM_TIMER_EVENT_GRN_ON_RED_BLINK .  E_CONST  -----  U_CHAR   -----  1
_PowerLED. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  flag . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
S2CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AAH  1
_MODE_STATUS_SEARCH. . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
T2CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
_POWER_STATUS_SAVING_BATTERY_MODE. . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_GRN_RED_BLINK. . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_PANEL_POWER_OFF. . .  E_CONST  -----  U_CHAR   -----  1
_POWER_STATUS_NORMAL_BATTERY_MODE. . .  E_CONST  -----  U_CHAR   -----  1
_MODE_STATUS_POWER_SAVING. . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_STANDBY_MODE . . . .  E_CONST  -----  U_CHAR   -----  1
_SaveFWRevEE . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
FLASH_FLAG . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   000FH  1
_USER_TIMER_EVENT_FACTORY_MODE . . . .  E_CONST  -----  U_CHAR   -----  1
LongRegisterInfo . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  6
  Min. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  Max. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
  Default. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0004H  2
_MODE_STATUS_ACTIVE. . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_TEMP_HIGH . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_DCC_HISTOGRAM_THD_  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_CAMERA_VOLTAGE_INCE_CONST  -----  U_CHAR   -----  1
S2BRT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BAH  1
_USER_TIMER_EVENT_OSD_SHOW_POWER_SAVING E_CONST  -----  U_CHAR   -----  1
RS_rx. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ret. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
_BATT_STATUS_FAST_CHARGE . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_DISPLAY_INFO . . . .  E_CONST  -----  U_CHAR   -----  1
_POWER_STATUS_NORMAL_NO_MATTERY_MODE .  E_CONST  -----  U_CHAR   -----  1
_RS_tx . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  tx_buf . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
_POWER_STATUS_OFF. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_SHOW_NO_SIGNAL .  E_CONST  -----  U_CHAR   -----  1
tm001. . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0039H  1
AUXR2. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A6H  1
ChangeKey. . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0005H  1
_SCALER_TIMER_EVENT_TMDS_VIDEO_DETECT.  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_LIGHT_SENSER_ON. . .  E_CONST  -----  U_CHAR   -----  1
tic_pc . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    003AH  2
RS_buf2. . . . . . . . . . . . . . . .  PUBLIC   DATA   ARRAY    003CH  8
_Printf. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_SCALER_TIMER_EVENT_D0_PORT_DIGITAL_SW  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_BURN_IN_ON . . . . .  E_CONST  -----  U_CHAR   -----  1
SystemClock. . . . . . . . . . . . . .  PUBLIC   DATA   U_LONG   0044H  4
_SCALER_TIMER_EVENT_D1_PORT_DIGITAL_SW  E_CONST  -----  U_CHAR   -----  1
GetFWRevEE . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_MODE_STATUS_POWER_OFF . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_MHL_D0_READY_TO_RE  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_COUNT. . . . . . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_NORMAL_TO_OFF. . . . . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_OFF_TO_NORMAL. . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_MHL_D1_READY_TO_RE  E_CONST  -----  U_CHAR   -----  1
AUXIE. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ADH  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1190    ----
C51 COMPILER V9.60.0.0   CPU                                                               03/02/2020 12:07:33 PAGE 91  

   CONSTANT SIZE    =     97    ----
   XDATA SIZE       =     16       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     72    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      6    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
