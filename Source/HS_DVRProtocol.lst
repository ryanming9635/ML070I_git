C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE HS_DVRPROTOCOL
OBJECT MODULE PLACED IN .\Output\HS_DVRProtocol.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE HS_DVRProtocol.c LARGE OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Include\) DEBUG 
                    -OBJECTEXTEND CODE LISTINCLUDE SYMBOLS PRINT(.\Source\HS_DVRProtocol.lst) TABS(2) OBJECT(.\Output\HS_DVRProtocol.obj)

line level    source

   1          //=====================================================================
   2          //  Work file: Hs_Protocol.c
   3          //
   4          //  This file is generating the HS protocol for DVR .
   5          //
   6          //                                
   7          //=====================================================================
   8          //******************************************************************************
   9          //  I N C L U D E    F I L E S
  10          //******************************************************************************
  11          #include "Config.h"
   1      =1  /*****************************************************************************/
   2      =1  /*                                                                                              */
   3      =1  /*  TELI ML070I   MCU                                             */
   4      =1  /*                                                                                              */
   5      =1  /*****************************************************************************/
   6      =1  
   7      =1  #ifndef __CONFIG_H__
   8      =1  #define __CONFIG_H__
   9      =1  
  10      =1  //#define INTERNAL_MCU -- defined by Project Compiler session
  11      =1  //#define   HS      
  12      =1  //#define   E_Wintek  
  13      =1  //#define   AWT 
  14      =1  //#define Holtz
  15      =1  
  16      =1  
  17      =1  
  18      =1  //#define QUAD
  19      =1  /*
  20      =1  #ifdef QUAD
  21      =1    #define AWT_ML072Q
  22      =1  #else
  23      =1    #define AWT_ML072S
  24      =1  #endif
  25      =1  */
  26      =1  //#define SUPPORT_SVIDEO                     //andy Awt 20090914
  27      =1  //#define SUPPORT_COMPONENT     // support component analog to decoder//andy Awt 20090914
  28      =1  
  29      =1  //#define SUPPORT_DTV           // support DTV input through component( to ADC ).//andy Awt 20090914
  30      =1  //#define SUPPORT_PC          // support PC function
  31      =1  //#define SUPPORT_DVI       // support DVI input
  32      =1  //#define SUPPORT_SDCARD
  33      =1  
  34      =1  //#define SUPPORT_RS485
  35      =1  //-----------------------------------------------------------------------------
  36      =1  //    Firmware Version
  37      =1  //-----------------------------------------------------------------------------
  38      =1  #define FWVER     0x0001      // Rev 0001
  39      =1  
  40      =1  #define MCU_FW_Major      0x00      
  41      =1  #define MCU_FW_Sub0     0x00      
  42      =1  #define MCU_FW_Sub1     0x01      
  43      =1  //-----------------------------------------------------------------------------
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 2   

  44      =1  //    Compiler
  45      =1  //-----------------------------------------------------------------------------
  46      =1  #define KEILC           // Keil C 5.0
  47      =1  //-----------------------------------------------------------------------------
  48      =1  //    MPU Clock
  49      =1  //-----------------------------------------------------------------------------
  50      =1  #ifndef INTERNAL_MCU
  51      =1  //#define CLOCK_11M         // 11.0592MHz
  52      =1  #define CLOCK_22M         // 22.1184MHz
  53      =1  #else                 // INTERNAL_MCU
           =1 #define CLOCK_27M         // 27MHz
           =1 #define REG_START_ADDRESS 0xc000    // register start 0xc000, for page0, 0xc100-page1 
           =1 #endif
  57      =1  //-----------------------------------------------------------------------------
  58      =1  //    TW88 Version
  59      =1  //-----------------------------------------------------------------------------
  60      =1  #define TW8816
  61      =1  //-----------------------------------------------------------------------------
  62      =1  //    Options for Backlight control
  63      =1  //-----------------------------------------------------------------------------
  64      =1  //#define BACKLIGHT_CCFL
  65      =1  //#define BACKLIGHT_LED
  66      =1  #define BACKLIGHT_PWM
  67      =1  
  68      =1  //-----------------------------------------------------------------------------
  69      =1  //    Panel Resolution
  70      =1  //-----------------------------------------------------------------------------
  71      =1  // ---- Select Default Panel
  72      =1  //
  73      =1  //#define UXGA            // 1600 x 1200
  74      =1  //#define SXGA              // 1280 x 1024
  75      =1  //#define XGA  // 1024 x 768
  76      =1  /*
  77      =1  #ifdef XGA
  78      =1    #define LVDS          
  79      =1    #define PWIDTH  1024
  80      =1    #define PHEIGHT 768
  81      =1  #endif
  82      =1  //#define SVGA            //  800 x 600
  83      =1  #define VGA             //  640 x 480
  84      =1  #ifdef VGA
  85      =1    #define PWIDTH  640
  86      =1    #define PHEIGHT 480
  87      =1    //#define HITACHI_640_B_160   //--> 640 x 160
  88      =1    #define AND_640_480
  89      =1  #endif
  90      =1  //#define WXGA            // 1280 x 768 (15:9) // 1366 x 768 (16:9)
  91      =1  #ifdef WXGA
  92      =1      //#define WX_SHARP_LQ106K1LA
  93      =1    #define PWIDTH  1280
  94      =1    #define PHEIGHT 768
  95      =1  #endif
  96      =1  //#define WSVGA           // 1024 x 600 *** only video mode
  97      =1  #ifdef WSVGA
  98      =1    #define PWIDTH  1024
  99      =1    #define PHEIGHT 600
 100      =1    #define UNIDEN_1024_600
 101      =1  #endif
 102      =1  */
 103      =1  //#define WVGA            //  800 x 480
 104      =1  //#ifdef WVGA
 105      =1    //#define PWIDTH  800
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 3   

 106      =1    //#define PHEIGHT 480//600
 107      =1    // If WVGA, you have to select panel.
 108      =1    //#define AU_10INCH
 109      =1    //#define WVGA_TPO
 110      =1    //#define SAMSUNG_10INCH
 111      =1    //#define SAMSUNG_TICONLESS_10INCH
 112      =1    //#define SHARP_TICONLESS_7INCH
 113      =1    //#define AU_TICONLESS_7INCH
 114      =1    //#define AU_G084SN05V8_8_4INCH 
 115      =1  //  #define HSD070IDW1_7INCH
 116      =1    //#define INNOLUX_AT080TN03
 117      =1    //#define AU_TICONLESS_7INCH_CCFL
 118      =1    //#define CMO     // CHIMEI panel
 119      =1    //#define AU_TICONLESS_10INCH
 120      =1    //#define HITACHI_T01
 121      =1    //#define HITACHI_TX23D12
 122      =1    //#define HITACHI_TX18D24
 123      =1    //#define HITACHI_TX18D16
 124      =1    //#define TMD_LTA070A320F
 125      =1    //#define TMD_LTA080B
 126      =1  //#endif  //WVGA
 127      =1  //#define HVGA            //  480 x 320
 128      =1  //#define QVGA            //  320 x 240 *** only video mode
 129      =1  /*
 130      =1  #ifdef QVGA
 131      =1    #define PWIDTH  320
 132      =1    #define PHEIGHT 240
 133      =1    //#define HITACHI_TX09D73
 134      =1    //#define AU_DELTARGB
 135      =1    //#define SHARP_LQ050Q5DR01
 136      =1    //#define SHARP_LQ035
 137      =1    //#define TMD
 138      =1  #endif
 139      =1  
 140      =1  //#define WQVGA           //  480 x 234 *** only video mode
 141      =1  #ifdef WQVGA
 142      =1    #define PWIDTH  480
 143      =1    #define PHEIGHT 240
 144      =1    // If WQVGA, you have to select panel 
 145      =1      #define ANALOG_7INCH
 146      =1    //#define PWIDTH  400
 147      =1    //#define PHEIGHT 240
 148      =1    //#define SHARP_LQ043T3DX02   //  400 x 237
 149      =1    //#define LG_ANALOG
 150      =1    //#define TMD_ANALOG        //TMD_LTA05B352A
 151      =1    //#define T_51945GD       // Optorex Panel
 152      =1  #endif  // WQVGA
 153      =1  */
 154      =1  //if LVDS pannel disable TICONLESS
 155      =1  
 156      =1  //-----------------------------------------------------------------------------
 157      =1  //---- Add Support One more panel with DIPSW#1
 158      =1  //---- Ex. Add Analog AU 7" Panel with Default Panel for evalution
 159      =1  //#define ADD_ANALOGPANEL   // Added Analog panel(AU7") from default set panel(expect WQVGA) with DIP #1 sw
             -itch.(DIP#1=L:ANALOG, H:DEFAULT)
 160      =1                // It can't support WQVGA and ADD_ANALOGPANEL same time!!
 161      =1    //#define ADD_ANALOG_7INCH
 162      =1    //#define ADD_TMD_LTA05B352A
 163      =1                    
 164      =1  //---- Support Wide panel function
 165      =1  /*
 166      =1  #if (defined WXGA) || (defined WSVGA) || (defined WVGA) || (defined WQVGA)
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 4   

 167      =1  #define WIDE_SCREEN         // Can support 4 display mode, i.e. Normal, Wide, Full, Zoom
 168      =1  #endif                // Tested panasonic WVGA panel.
 169      =1  */
 170      =1  //-----------------------------------------------------------------------------
 171      =1  //    Panel Vendor Specific
 172      =1  //-----------------------------------------------------------------------------
 173      =1  /*
 174      =1  //-----------------------------------------------------------------------------
 175      =1  //    TV Tuner
 176      =1  //-----------------------------------------------------------------------------
 177      =1  #define PHILIPS       0
 178      =1  #define ALPS        1   // ALPS, LG
 179      =1  #define TEMIC       2
 180      =1  #define TVAVA       3
 181      =1  #define LGTUNER       4
 182      =1  #define SAMSUNGMUTITUNER  5
 183      =1  
 184      =1  #define TVTunerDevice   4
 185      =1  //-----------------------------------------------------------------------------
 186      =1  //    IR Remote Controller Type
 187      =1  //-----------------------------------------------------------------------------
 188      =1  //#define REMO_RC5          // RC5 style
 189      =1  #define TECHWELL_REMOCON
 190      =1  //#define REMO_NEC          // NEC style
 191      =1  //#define PHILIPS_REMOCON // New remocon 
 192      =1  */
 193      =1  
 194      =1  //-----------------------------------------------------------------------------
 195      =1  //    I2C Device Access Address Mapping
 196      =1  //-----------------------------------------------------------------------------
 197      =1  #define EEPROMI2CAddress  0xa0  // EEPROM (24C16)
 198      =1  #define TW88I2CAddress    0x8a  // TW880x
 199      =1  
 200      =1  /*
 201      =1  #define MSPI2CAddress   0x80  // MSP
 202      =1  #define ALC106I2CAddress    0x4A  // MSP
 203      =1  */
 204      =1  #define  AD5110I2CAddress    0x5E//0x58
 205      =1  
 206      =1  //-----------------------------------------------------------------------------
 207      =1  //    AD5110 Command Operation Truth table
 208      =1  //-----------------------------------------------------------------------------
 209      =1  
 210      =1  #define AD5110_CMD_No_Operation           0
 211      =1  #define AD5110_CMD_Write_RDAC_To_EEPROM       1
 212      =1  #define AD5110_CMD_Write_Data_To_RDAC       2
 213      =1  #define AD5110_CMD_Shutdown             3
 214      =1  #define AD5110_CMD_Soft_Refresh_RDAC    4
 215      =1  #define AD5110_CMD_Read_RDAC        5
 216      =1  #define AD5110_CMD_Read_EEPROM              6
 217      =1  
 218      =1  
 219      =1  
 220      =1  //-----------------------------------------------------------------------------
 221      =1  //    Options for Possible Inputs
 222      =1  //-----------------------------------------------------------------------------
 223      =1  
 224      =1  
 225      =1  
 226      =1  
 227      =1  
 228      =1  //-----------------------------------------------------------------------------
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 5   

 229      =1  //    Options for Possible Standards
 230      =1  //    Default:NTSC
 231      =1  //-----------------------------------------------------------------------------
 232      =1  /*
 233      =1  #define SUPPORT_PAL     
 234      =1  #define SUPPORT_SECAM
 235      =1  #define SUPPORT_NTSC4   
 236      =1  #define SUPPORT_PALM  
 237      =1  #define SUPPORT_PALN    
 238      =1  #define SUPPORT_PAL60   
 239      =1  */
 240      =1  
 241      =1  //#define ID_CHECK_BY_FW        // in Video mode, check input system ID by firmware
 242      =1  
 243      =1  //-----------------------------------------------------------------------------
 244      =1  //    Options for Debugging/Release
 245      =1  //-----------------------------------------------------------------------------
 246      =1  //#define SUPPORT_PATTERN       // support LCD test pattern
 247      =1  
 248      =1  /*
 249      =1  #ifndef WQVGA
 250      =1    #ifndef QVGA
 251      =1    #define SUPPORT_OSDPOSITIONMOVE
 252      =1    #endif
 253      =1  #endif
 254      =1  */
 255      =1  #define SERIAL              // include serial communication routines
 256      =1  //#define USE_HI3521_UART2
 257      =1  
 258      =1  //#define SUPPORT_DEBUG       // Support to use Read & Write in debug OSD Window by remocon.
 259      =1  
 260      =1  //#define DEBUG           // include debug information
 261      =1  #if 0///def DEBUG
           =1   //#define DEBUG_MAIN
           =1   //#define DEBUG_TIME
           =1   //#define DEBUG_KEYREMO
           =1   //#define DEBUG_TW88
           =1   //#define DEBUG_DECODER
           =1   //#define DEBUG_I2C
           =1   //#define DEBUG_EEP
           =1   //#define DEBUG_OSD
           =1   //#define DEBUG_AUDIO
           =1   //#define DEBUG_SETPANEL
           =1   //#define DEBUG_DTV
           =1   #define DEBUG_PC
           =1   //#define DEBUG_PC_MEAS
           =1   #define DEBUG_PC_COLOR
           =1   //#define DEBUG_COMPONENT
           =1   //#define DEBUG_BANK
           =1   //#define DEBUG_PAUSE
           =1   //#define DEBUG_MCU
           =1 #endif
 281      =1  
 282      =1  //#define AUTOCALC_PC         // in PC mode, Enable Auto Calcuration
 283      =1  //#define SUPPORT_USERCOLORFROMTXT  // Use color setting of text file in Color mode=USER MODE which is as B
             -rightness(Reg10), Contast(Reg11),
 284      =1                    //    Sat_U(Reg13),Sat_V(Reg14),Sharpness(Reg12,Reg78)                  
 285      =1  //#define SUPPORT_GAMMA
 286      =1  
 287      =1  //#define CHIP_MANUAL_TEST      // DIPSW#1
 288      =1  
 289      =1  //#ifndef INTERNAL_MCU
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 6   

 290      =1  //#define NO_INITIALIZE       // After Power switch turn on with DIP SW4 Enable(Low), or pressed MENU button 
             -for internal MCU
 291      =1                                      //     micom works to access only I2C bus by serial command.
 292      =1  //#endif
 293      =1  
 294      =1  //#define SUPPORT_KRS_OSDDEMO   // For KRS Company Demo 
 295      =1  //#define SUPPORT_LINE_OSDDEMO
 296      =1  
 297      =1  //-----------------------------------------------------------------------------
 298      =1  //    Special Features
 299      =1  //-----------------------------------------------------------------------------
 300      =1  
 301      =1  //#ifndef INTERNAL_MCU
 302      =1  //#define SUPPORT_DELTA_RGB
 303      =1  //#endif
 304      =1  //#define SUPPORT_SELECTKEY     // choose the keymap of using select key or left,right key.
 305      =1  //-----------------------------------------------------------------------------
 306      =1  
 307      =1  //#define HS_NEWOSDMENU     //Weylis -@121008 for Hor. Style OSD
 308      =1  //#define HS_NEWOSDMENU_2     //Weylis -@121008 for Hor. Style OSD(2 line)
 309      =1  #endif  //__CONFIG_H__
  12          #include "typedefs.h"
   1      =1  #ifndef __TYPEDEFS__
   2      =1  #define __TYPEDEFS__
   3      =1  
   4      =1  
   5      =1  #define DATA    data
   6      =1  #define PDATA   pdata
   7      =1  #define IDATA   data
   8      =1  #define CODE    code
   9      =1  #define CODE_P
  10      =1  #define PDATA_P
  11      =1  #define IDATA_P
  12      =1  #define DATA_P
  13      =1  
  14      =1  #define INTERRUPT( num, name ) name() interrupt num
  15      =1  
  16      =1  #define _between(x, a, b) (a<=x && x<=b)
  17      =1  #define _swap(a, b)     { a^=b; b^=a; a^=b; }
  18      =1  
  19      =1  #define SEC(x)                                  (1000 * (x))
  20      =1  
  21      =1  typedef unsigned char Register;
  22      =1  typedef unsigned char BYTE;
  23      =1  typedef unsigned short  WORD;
  24      =1  typedef unsigned long DWORD;
  25      =1  
  26      =1  #define TRUE  1
  27      =1  #define FALSE 0
  28      =1  #define _TRUE 1
  29      =1  #define _FALSE  0
  30      =1  
  31      =1  //VInputStdDetectMode
  32      =1  #define AUTO  0
  33      =1  
  34      =1  //VInputStd
  35      =1  #define NTSC  1     
  36      =1  #define PAL   2
  37      =1  #define SECAM 3
  38      =1  #define NTSC4 4
  39      =1  #define PALM  5
  40      =1  #define PALN  6
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 7   

  41      =1  #define PAL60 7
  42      =1  
  43      =1  #define MAXINPUTSTD PAL60+1 // 
  44      =1  
  45      =1  #define UNKNOWN 0xfe
  46      =1  #define NOINPUT 0 //0xff
  47      =1  
  48      =1  
  49      =1  
  50      =1  
  51      =1  #define NIL     0xff
  52      =1  //****************************************************************************
  53      =1  // DEFINITIONS / MACROS
  54      =1  //****************************************************************************
  55      =1  
  56      =1  #define GET_MODE_STATE()                            (g_stModeInfo.b5ModeState)
  57      =1  #define SET_MODE_STATE(x)                         (g_stModeInfo.b5ModeState = x)
  58      =1  #define GET_MODE_STATE_CHANGE()                 (bit)(g_stModeInfo.b1ModeStateChanged)
  59      =1  #define SET_MODE_STATE_CHANGE()                 (g_stModeInfo.b1ModeStateChanged = _TRUE)
  60      =1  #define CLR_MODE_STATE_CHANGE()                 (g_stModeInfo.b1ModeStateChanged = _FALSE)
  61      =1  #define GET_MODE_RESET_TARGET()                   (g_stModeInfo.b4ModeResetFlag)
  62      =1  #define SET_MODE_RESET_TARGET(x)                (g_stModeInfo.b4ModeResetFlag = x)
  63      =1  #define GET_TARGET_POWER_STATUS()           (g_stPowerInfo.b4PowerAction)
  64      =1  #define SET_TARGET_POWER_STATUS(x)          (g_stPowerInfo.b4PowerAction = x)
  65      =1  
  66      =1  #define GET_BATTERY_STATE()       (g_stBatteryInfo.b5BatteryStatus)
  67      =1  #define SET_BATTERY_STATE(x)        (g_stBatteryInfo.b5BatteryStatus = x)
  68      =1  #define GET_NO_BATTERY()        (bit)(g_stBatteryInfo.b1NoBattery)
  69      =1  #define SET_NO_BATTERY()        (g_stBatteryInfo.b1NoBattery =_TRUE)
  70      =1  #define CLR_NO_BATTERY()        (g_stBatteryInfo.b1NoBattery = _FALSE)
  71      =1  
  72      =1  #define GET_AC_PLUG()       (bit)(g_stBatteryInfo.b1AC_PLUG)
  73      =1  #define SET_AC_PLUG()       (g_stBatteryInfo.b1AC_PLUG =_TRUE)
  74      =1  #define CLR_AC_PLUG()       (g_stBatteryInfo.b1AC_PLUG = _FALSE)
  75      =1        
  76      =1  
  77      =1  #define GET_BTH_STATE()         (g_stBatteryInfo.b3BTHStatus)
  78      =1  #define SET_BTH_STATE(x)          (g_stBatteryInfo.b3BTHStatus = x)
  79      =1  
  80      =1  #define GET_BATTERY_CAPACITY()        (g_stBatteryInfo.BatteryCapacity)
  81      =1  #define SET_BATTERY_CAPACITY(x)     (g_stBatteryInfo.BatteryCapacity = x)
  82      =1  #define GET_BATTERY_CAPACITY_FLAG()       (bit)(g_stBatteryInfo.b1BatteryCapacityLow)
  83      =1  #define SET_BATTERY_CAPACITY_FLAG()       (g_stBatteryInfo.b1BatteryCapacityLow =_TRUE)
  84      =1  #define CLR_BATTERY_CAPACITY_FLAG()     (g_stBatteryInfo.b1BatteryCapacityLow =_FALSE)
  85      =1  
  86      =1  #define GET_BATTERY_ABNORMAL()        (bit)(g_stBatteryInfo.b1BatteryAbnormal)
  87      =1  #define SET_BATTERY_ABNORMAL()        (g_stBatteryInfo.b1BatteryAbnormal=_TRUE)
  88      =1  #define CLR_BATTERY_ABNORMAL()        (g_stBatteryInfo.b1BatteryAbnormal=_FALSE)
  89      =1  
  90      =1  #define GET_BATTERY_CHARGE_STATE()        (g_stBatteryInfo.b2BatteryChargeStatus)
  91      =1  #define SET_BATTERY_CHARGE_STATE(x)     (g_stBatteryInfo.b2BatteryChargeStatus = x)
  92      =1  
  93      =1  //--------------------------------------------------
  94      =1  // Power status
  95      =1  //--------------------------------------------------
  96      =1  #define GET_POWER_STATUS()                 (g_stPowerInfo.b4PowerStatus)
  97      =1  #define SET_POWER_STATUS(x)                (g_stPowerInfo.b4PowerStatus = x)
  98      =1  
  99      =1  //--------------------------------------------------
 100      =1  // Enumerations of Timer Events
 101      =1  //--------------------------------------------------
 102      =1  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 8   

 103      =1  typedef struct
 104      =1  {
 105      =1      BYTE b1EventValid : 1;
 106      =1      BYTE b7EventID : 7;
 107      =1      WORD usTime;
 108      =1  } StructTimerEventTableType;
 109      =1  
 110      =1  typedef enum
 111      =1  {
 112      =1      _USER_TIMER_EVENT_START,
 113      =1      _USER_TIMER_EVENT_KEY_REPEAT_ENABLE = _USER_TIMER_EVENT_START,   
 114      =1      _USER_TIMER_EVENT_KEY_SCAN_READY,
 115      =1      _USER_TIMER_EVENT_OSD_CAMERA_VOLTAGE_INC,
 116      =1      _USER_TIMER_EVENT_OSD_CAMERA_VOLTAGE_DEC,
 117      =1      _USER_TIMER_EVENT_OSD_GET_MCU_VERSION,
 118      =1      _USER_TIMER_EVENT_OSD_MCU_ENTRY_SLEEP_MODE,
 119      =1      _USER_TIMER_EVENT_OSD_DISTANCE_RESET,
 120      =1      _USER_TIMER_EVENT_OSD_DVR_REBOOT,
 121      =1      _USER_TIMER_EVENT_OSD_DVR_SHUTDOWN,
 122      =1      _USER_TIMER_EVENT_OSD_ENCODER_DEVIATION_SETTING,
 123      =1      //
 124      =1       _USER_TIMER_EVENT_OSD_SHOW_NO_CABLE,
 125      =1      _USER_TIMER_EVENT_OSD_SHOW_NO_SIGNAL,
 126      =1      _USER_TIMER_EVENT_OSD_SHOW_POWER_SAVING,
 127      =1      _USER_TIMER_EVENT_GO_TO_POWER_SAVING,
 128      =1      _USER_TIMER_EVENT_OSD_DISABLE,
 129      =1      _USER_TIMER_EVENT_PANEL_BACKLIGHT_ON,
 130      =1      _USER_TIMER_EVENT_PANEL_POWER_OFF,
 131      =1      _USER_TIMER_EVENT_DO_AUTO_COLOR,
 132      =1      _USER_TIMER_EVENT_PANEL_USED_TIMER,
 133      =1      _USER_TIMER_EVENT_HLWIN_TYPE5_MOVE,    
 134      =1    _USER_TIMER_EVENT_LED_POWER_SAVING,
 135      =1    _USER_TIMER_EVENT_LIGHT_SENSER_ON,
 136      =1    _USER_TIMER_EVENT_SHOW_BURN_IN,//ryan@20151230
 137      =1    _USER_TIMER_EVENT_BURN_IN_ON,//ryan@20151230
 138      =1    _USER_TIMER_EVENT_CHECK,//ryan@20151231
 139      =1    _USER_TIMER_EVENT_DISPLAY_INFO,//ryan@20151231
 140      =1    _USER_TIMER_EVENT_STANDBY_MODE,
 141      =1    _USER_TIMER_EVENT_FACTORY_MODE,//ryan@20160113
 142      =1      _USER_TIMER_EVENT_END,
 143      =1      _USER_TIMER_EVENT_COUNT = _USER_TIMER_EVENT_END,
 144      =1  } EnumUserTimerEventID;
 145      =1  
 146      =1  typedef enum
 147      =1  {
 148      =1      _SYSTEM_TIMER_EVENT_START = _USER_TIMER_EVENT_COUNT,
 149      =1      _SYSTEM_TIMER_EVENT_SOURCE_CLEAR_DETECTING = _SYSTEM_TIMER_EVENT_START,
 150      =1      _SYSTEM_TIMER_EVENT_JUDGE_BATT_STATE,
 151      =1      _SYSTEM_TIMER_EVENT_JUDGE_POWER_STATE,
 152      =1      _SYSTEM_TIMER_EVENT_JUDGE_BTH_STATE,
 153      =1      _SYSTEM_TIMER_EVENT_JUDGE_PSW_STATE,    
 154      =1      _SYSTEM_TIMER_EVENT_JUDGE_AC_MODE,
 155      =1      _SYSTEM_TIMER_EVENT_JUDGE_DVR_COMM,
 156      =1      _SYSTEM_TIMER_EVENT_JUDGE_TW8836_COMM,
 157      =1      _SYSTEM_TIMER_EVENT_JUDGE_WDT_ECHO,
 158      =1       _SYSTEM_TIMER_EVENT_GRN_ON,    
 159      =1      _SYSTEM_TIMER_EVENT_GRN_OFF,    
 160      =1      _SYSTEM_TIMER_EVENT_RED_ON,      
 161      =1      _SYSTEM_TIMER_EVENT_RED_OFF,   
 162      =1      _SYSTEM_TIMER_EVENT_GRN_BLINK,    
 163      =1      _SYSTEM_TIMER_EVENT_RED_BLINK,   
 164      =1      _SYSTEM_TIMER_EVENT_GRN_RED_BLINK,    
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 9   

 165      =1      _SYSTEM_TIMER_EVENT_GRN_RED_ON,    
 166      =1      _SYSTEM_TIMER_EVENT_GRN_ON_RED_BLINK,    
 167      =1      _SYSTEM_TIMER_EVENT_END,
 168      =1      _SYSTEM_TIMER_EVENT_COUNT,
 169      =1  } EnumSystemTimerEventID;
 170      =1  
 171      =1  
 172      =1  typedef enum
 173      =1  {
 174      =1      _SCALER_TIMER_EVENT_START = _SYSTEM_TIMER_EVENT_COUNT,
 175      =1      _SCALER_TIMER_EVENT_TMDS_HDMI_PACKET_DETECT = _SCALER_TIMER_EVENT_START, 
 176      =1      _SCALER_TIMER_EVENT_TMDS_VIDEO_DETECT,  
 177      =1      _SCALER_TIMER_EVENT_AUDIO_LOAD_STABLE_I_CODE,
 178      =1      _SCALER_TIMER_EVENT_DP_HOTPLUG_ASSERTED,
 179      =1      _SCALER_TIMER_EVENT_DP_HDCP_LONG_HOTPLUG_EVENT,
 180      =1      _SCALER_TIMER_EVENT_DP_LINK_STATUS_IRQ,    
 181      =1      _SCALER_TIMER_EVENT_D0_PORT_DIGITAL_SWITCH,
 182      =1      _SCALER_TIMER_EVENT_D1_PORT_DIGITAL_SWITCH,  
 183      =1      _SCALER_TIMER_EVENT_NR_DETECTION_FINISHED,  
 184      =1      _SCALER_TIMER_EVENT_PHASE_CALIBRATION,    
 185      =1      _SCALER_TIMER_EVENT_PHASE_CNT_CHECK,
 186      =1      _SCALER_TIMER_EVENT_MHL_D0_READY_TO_TRANSMIT,
 187      =1      _SCALER_TIMER_EVENT_MHL_D0_READY_TO_RESEND,
 188      =1      _SCALER_TIMER_EVENT_MHL_D0_RECONNECT_1K,
 189      =1      _SCALER_TIMER_EVENT_MHL_D0_ACTIVE_VBUS,
 190      =1      _SCALER_TIMER_EVENT_MHL_D1_READY_TO_TRANSMIT,
 191      =1      _SCALER_TIMER_EVENT_MHL_D1_READY_TO_RESEND,
 192      =1      _SCALER_TIMER_EVENT_MHL_D1_RECONNECT_1K,
 193      =1      _SCALER_TIMER_EVENT_MHL_D1_ACTIVE_VBUS,
 194      =1      _SCALER_TIMER_EVENT_DCC_HISTOGRAM_THD_CHANGE,
 195      =1      _SCALER_TIMER_EVENT_END,
 196      =1      _SCALER_TIMER_EVENT_COUNT = _SCALER_TIMER_EVENT_END,
 197      =1  } EnumMCUTimerEventID;
 198      =1  
 199      =1  #define _SIMULTANEOUS_SCALER_EVENT_COUNT       0//     (5 + (_D0_INPUT_PORT_TYPE == _D0_MHL_PORT) + (_D1_I
             -NPUT_PORT_TYPE == _D1_MHL_PORT))
 200      =1  #define _SIMULTANEOUS_USER_EVENT_COUNT             5
 201      =1  #define _SIMULTANEOUS_SYSTEM_EVENT_COUNT            3
 202      =1  
 203      =1  
 204      =1  #define _TIMER_EVENT_COUNT    (_SIMULTANEOUS_USER_EVENT_COUNT + _SIMULTANEOUS_SYSTEM_EVENT_COUNT + _SIMULT
             -ANEOUS_SCALER_EVENT_COUNT)
 205      =1  
 206      =1  
 207      =1  //--------------------------------------------------
 208      =1  // Power action
 209      =1  //--------------------------------------------------
 210      =1  
 211      =1  typedef enum
 212      =1  {
 213      =1      _POWER_ACTION_OFF_TO_NORMAL = 0x00,          
 214      =1      _POWER_ACTION_AC_ON_TO_NORMAL,         
 215      =1      _POWER_ACTION_AC_ON_TO_OFF,  ////2          
 216      =1      _POWER_ACTION_PS_TO_NORMAL,           
 217      =1      _POWER_ACTION_PS_TO_OFF,              
 218      =1      _POWER_ACTION_NORMAL_TO_PS,   //5        
 219      =1      _POWER_ACTION_NORMAL_TO_OFF,          
 220      =1      _POWER_ACTION_NORMAL_TO_NOSUPPORT_PS, 
 221      =1      _POWER_ACTION_NOSUPPORT_PS_TO_PS,
 222      =1      _POWER_ACTION_NOSUPPORT_PS_TO_OFF, 
 223      =1      _POWER_ACTION_NONE = 0xFF,
 224      =1  } EnumPowerAction;
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 10  

 225      =1  
 226      =1  typedef enum
 227      =1  {
 228      =1      _MODE_ACTION_NO_RESET_MODE = 0x00,                
 229      =1      _MODE_ACTION_RESET_TO_SEARCH,
 230      =1      _MODE_ACTION_RESET_TO_DISPLAY_SETTING, 
 231      =1      _MODE_ACTION_RESET_TO_DISPLAY_SETTING_WITHOUT_FORCETOBG,
 232      =1      _MODE_ACTION_RESET_TO_NOSUPPORT,    
 233      =1      _MODE_ACTION_RESET_TO_NOSIGNAL,
 234      =1      _MODE_ACTION_RESET_TO_POWER_SAVING,    
 235      =1      _MODE_ACTION_RESET_TO_POWER_OFF,           
 236      =1      _MODE_ACTION_RESET_TO_FACTORY_MODE,   
 237      =1      _MODE_ACTION_NONE = 0xFF,
 238      =1  } EnumModeAction;
 239      =1  
 240      =1  
 241      =1  //--------------------------------------------------
 242      =1  // Power status
 243      =1  //--------------------------------------------------
 244      =1  
 245      =1  typedef enum
 246      =1  {
 247      =1      _MODE_STATUS_INITIAL = 0x00,            
 248      =1      _MODE_STATUS_SEARCH,             
 249      =1      _MODE_STATUS_DISPLAY_SETTING,    
 250      =1      _MODE_STATUS_ACTIVE,             
 251      =1      _MODE_STATUS_NOSUPPORT,          
 252      =1      _MODE_STATUS_NOSIGNAL,           
 253      =1      _MODE_STATUS_POWER_SAVING,       
 254      =1      _MODE_STATUS_POWER_OFF,          
 255      =1      _MODE_STATUS_FACTORY,     
 256      =1      _MODE_STATUS_NONE = 0xFF,
 257      =1  } EnumModeStatus;
 258      =1  
 259      =1  typedef enum
 260      =1  {
 261      =1      _POWER_STATUS_AC_ON = 0x00,
 262      =1      _POWER_STATUS_OFF,
 263      =1      _POWER_STATUS_NORMAL,
 264      =1      _POWER_STATUS_NORMAL_BATTERY_MODE,   
 265      =1      _POWER_STATUS_NORMAL_NO_MATTERY_MODE,
 266      =1      _POWER_STATUS_SAVING,
 267      =1      _POWER_STATUS_SAVING_BATTERY_MODE,   
 268      =1      _POWER_STATUS_NOSUPPORT_SAVING,
 269      =1      _POWER_STATUS_NONE = 0xFF,
 270      =1  } EnumPowerStatus;
 271      =1  
 272      =1  
 273      =1  //--------------------------------------------------
 274      =1  // Battery status
 275      =1  //--------------------------------------------------
 276      =1  
 277      =1  typedef enum
 278      =1  {
 279      =1    _BATT_STATUS_CAPACITY_LEVEL4=0x00,
 280      =1    _BATT_STATUS_CAPACITY_LEVEL3,
 281      =1    _BATT_STATUS_CAPACITY_LEVEL2,
 282      =1    _BATT_STATUS_CAPACITY_LEVEL1,
 283      =1    _BATT_STATUS_AC_MODE,
 284      =1    _BATT_STATUS_TEMP_HIGH, 
 285      =1    _BATT_STATUS_TEMP_NORMAL,
 286      =1    _BATT_STATUS_TEMP_LOW, 
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 11  

 287      =1    _BATT_STATUS_NO_BATT,
 288      =1    _BATT_STATUS_CAPACITY_LOW,
 289      =1    _BATT_STATUS_CAPACITY_HIGH,
 290      =1    _BATT_STATUS_ABNORMAL_MODE,
 291      =1    _BATT_STATUS_FAST_CHARGE,
 292      =1    _BATT_STATUS_LOW_CHARGE,
 293      =1    _BATT_STATUS_STOP_CHARGE,
 294      =1    _BATT_STATUS_START_CHARGE,
 295      =1        _BATT_STATUS_NONE = 0xFF,
 296      =1  } EnumBatteryStatus;
 297      =1  
 298      =1  //--------------------------------------------------
 299      =1  // Battery action
 300      =1  //--------------------------------------------------
 301      =1  /*
 302      =1  typedef enum
 303      =1  {
 304      =1      _POWER_ACTION_OFF_TO_NORMAL = 0x00,          
 305      =1      _POWER_ACTION_AC_ON_TO_NORMAL,         
 306      =1      _POWER_ACTION_AC_ON_TO_OFF,  ////2          
 307      =1      _POWER_ACTION_PS_TO_NORMAL,           
 308      =1      _POWER_ACTION_PS_TO_OFF,              
 309      =1      _POWER_ACTION_NORMAL_TO_PS,   //5        
 310      =1      _POWER_ACTION_NORMAL_TO_OFF,          
 311      =1      _POWER_ACTION_NORMAL_TO_NOSUPPORT_PS, 
 312      =1      _POWER_ACTION_NOSUPPORT_PS_TO_PS,
 313      =1      _POWER_ACTION_NOSUPPORT_PS_TO_OFF, 
 314      =1      _POWER_ACTION_NONE = 0xFF,
 315      =1  } EnumPowerAction;
 316      =1  */
 317      =1  /*
 318      =1  typedef enum
 319      =1  {
 320      =1      _MODE_ACTION_NO_RESET_MODE = 0x00,                
 321      =1      _MODE_ACTION_RESET_TO_SEARCH,
 322      =1      _MODE_ACTION_RESET_TO_DISPLAY_SETTING, 
 323      =1      _MODE_ACTION_RESET_TO_DISPLAY_SETTING_WITHOUT_FORCETOBG,
 324      =1      _MODE_ACTION_RESET_TO_NOSUPPORT,    
 325      =1      _MODE_ACTION_RESET_TO_NOSIGNAL,
 326      =1      _MODE_ACTION_RESET_TO_POWER_SAVING,    
 327      =1      _MODE_ACTION_RESET_TO_POWER_OFF,           
 328      =1      _MODE_ACTION_RESET_TO_FACTORY_MODE,   
 329      =1      _MODE_ACTION_NONE = 0xFF,
 330      =1  } EnumModeAction;
 331      =1  */
 332      =1  
 333      =1  typedef struct
 334      =1  {
 335      =1      BYTE b5BatteryStatus:5;
 336      =1      BYTE b1NoBattery:1;
 337      =1      BYTE b1AC_PLUG:1;
 338      =1      BYTE b3BTHStatus:3;
 339      =1      BYTE b1BatteryCapacityLow:1;
 340      =1      BYTE b1BatteryAbnormal:1;
 341      =1      BYTE b2BatteryChargeStatus:2;
 342      =1      WORD BatteryCapacity;
 343      =1  } StructBatteryInfoType;
 344      =1  
 345      =1  
 346      =1  typedef struct
 347      =1  {
 348      =1      BYTE b4PowerAction : 4;
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 12  

 349      =1      BYTE b4PowerStatus : 4;
 350      =1      BYTE b1GDIIsolationFlag : 1;
 351      =1      BYTE b1TopIsolationFlag : 1;
 352      =1      BYTE b1AnalogIsolationFlag : 1;
 353      =1  } StructPowerInfoType;
 354      =1  
 355      =1  
 356      =1  typedef struct
 357      =1  {
 358      =1      BYTE b5ModeState : 5;
 359      =1      BYTE b1DisplaySettingReady : 1;
 360      =1      BYTE b1TimingConfirm : 1;
 361      =1      BYTE b1ModeStateChanged : 1;
 362      =1      BYTE b4ModeResetFlag : 4;    
 363      =1      BYTE b1NoWaitForActive : 1;
 364      =1      BYTE b1ActiveReady : 1;
 365      =1  } StructModeInfoType;
 366      =1  
 367      =1  
 368      =1  
 369      =1  /*
 370      =1  
 371      =1  enum SourceModeTypeEnum
 372      =1  { 
 373      =1    AVMode,      // 0   0X00
 374      =1    //VGAMode,       // 1
 375      =1  #ifdef USE_CAMD 
 376      =1    CAM_D,         // 2
 377      =1  #endif
 378      =1    CAM_A,         // 3     0x01
 379      =1    CAM_B,         // 4     0x02
 380      =1    CAM_C,         // 5     0x03
 381      =1    CAM_R,         // 6     0x04
 382      =1    CAM_AB,        // 7     0x05
 383      =1    CAM_CR,        // 8     0x06
 384      =1    CAM_AR,        // 9     0x07
 385      =1    CAM_RB,        // 10    0x08
 386      =1    CAM_AC,        // 11    0x09
 387      =1    CAM_CB,        // 12    0x0a
 388      =1    CAM_RAB_T,     // 13    0x0b
 389      =1    CAM_RAB_H,     // 14    0x0c
 390      =1  
 391      =1    CAM_QUAD,      // 15    0x0d
 392      =1    CAM_ABR_T3,    // 16    0x0e
 393      =1    CAM_ABR_T4,    // 17    0x0f
 394      =1    CAM_RAC_T,      //0x10  
 395      =1    CAM_RBC_T,      //0x11
 396      =1    CAM_RAC_T2,     //0x12  
 397      =1    CAM_RBC_T2,     //0x13  
 398      =1    CAM_BA,       //0x14
 399      =1    CAM_BC,
 400      =1    CAM_BR,
 401      =1    CAM_CA,
 402      =1    CAM_ABC,
 403      =1    CAM_ABR,
 404      =1    CAM_ACR,
 405      =1    CAM_BAC,
 406      =1    CAM_BAR,
 407      =1    CAM_BCR,
 408      =1    CAM_CAB,
 409      =1    CAM_CAR,
 410      =1    CAM_CBR,  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 13  

 411      =1    SEQ,           // 18      0x10
 412      =1    CAM_NUM
 413      =1  };
 414      =1  */
 415      =1  //#define _TIMER_EVENT_COUNT      _SYSTEM_TIMER_EVENT_END////                    (_SIMULTANEOUS_USER_EVENT
             -_COUNT + _SIMULTANEOUS_SYSTEM_EVENT_COUNT + _SIMULTANEOUS_SCALER_EVENT_COUNT)
 416      =1  
 417      =1  //typedef unsigned char SourceModeType;
 418      =1  
 419      =1  #endif  /* __TYPEDEFS__ */
  13          #include "i2c.h"
   1      =1  #ifndef __I2C_H__
   2      =1  #define __I2C_H__
   3      =1  //AD5110 table
   4      =1  /*   
   5      =1  "RA=100K+5.1K, RB=10K+10K  "        //  
   6      =1  ¶¥¼Æ  D7D6D5D4D3D2D1D0  Vout        //
   7      =1  0 0 4.90                            //
   8      =1  1 1 4.92      
   9      =1  2 10  4.93      
  10      =1  3 11  4.95      
  11      =1  4 100 4.97      
  12      =1  5 101 4.99      
  13      =1  6 110 5.00      
  14      =1  7 111 5.02      
  15      =1  8 1000  5.03      
  16      =1  9 1001  5.05      
  17      =1  10  1010  5.07      
  18      =1  11  1011  5.09      
  19      =1  12  1100  5.11      
  20      =1  13  1101  5.12      
  21      =1  14  1110  5.14      
  22      =1  15  1111  5.16      
  23      =1  16  10000 5.18      
  24      =1  17  10001 5.20      
  25      =1  18  10010 5.21      
  26      =1  19  10011 5.23      
  27      =1  20  10100 5.25      
  28      =1  21  10101 5.27      
  29      =1  22  10110 5.29      
  30      =1  23  10111 5.31      
  31      =1  24  11000 5.33      
  32      =1  25  11001 5.35      
  33      =1  26  11010 5.37      
  34      =1  27  11011 5.39      
  35      =1  28  11100 5.41      
  36      =1  29  11101 5.43      
  37      =1  30  11110 5.45      
  38      =1  31  11111 5.47      
  39      =1  32  100000  5.48      
  40      =1  33  100001  5.51      
  41      =1  34  100010  5.54      
  42      =1  35  100011  5.56      
  43      =1  36  100100  5.58      
  44      =1  37  100101  5.60      
  45      =1  38  100110  5.63      
  46      =1  39  100111  5.65      
  47      =1  40  101000  5.67      
  48      =1  41  101001  5.69      
  49      =1  42  101010  5.72      
  50      =1  43  101011  5.74      
  51      =1  44  101100  5.76      
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 14  

  52      =1  45  101101  5.78      
  53      =1  46  101110  5.81      
  54      =1  47  101111  5.84      
  55      =1  48  110000  5.86      
  56      =1  49  110001  5.88      
  57      =1  50  110010  5.91      
  58      =1  51  110011  5.93      
  59      =1  52  110100  5.96      
  60      =1  53  110101  5.98      
  61      =1  54  110110  6.01      
  62      =1  55  110111  6.04      
  63      =1  56  111000  6.06      
  64      =1  57  111001  6.09      
  65      =1  58  111010  6.11      
  66      =1  59  111011  6.15      
  67      =1  60  111100  6.17      
  68      =1  61  111101  6.20      
  69      =1  62  111110  6.23      
  70      =1  63  111111  6.26      
  71      =1  64  1000000 6.28      
  72      =1  65  1000001 6.32      
  73      =1  66  1000010 6.35      
  74      =1  67  1000011 6.37      
  75      =1  68  1000100 6.40      
  76      =1  69  1000101 6.44      
  77      =1  70  1000110 6.47      
  78      =1  71  1000111 6.50      
  79      =1  72  1001000 6.53      
  80      =1  73  1001001 6.56      
  81      =1  74  1001010 6.59      
  82      =1  75  1001011 6.62      
  83      =1  76  1001100 6.66      
  84      =1  77  1001101 6.69      
  85      =1  78  1001110 6.72      
  86      =1  79  1001111 6.76      
  87      =1  80  1010000 6.79      
  88      =1  81  1010001 6.83      
  89      =1  82  1010010 6.86      
  90      =1  83  1010011 6.90      
  91      =1  84  1010100 6.93      
  92      =1  85  1010101 6.97      
  93      =1  86  1010110 7.01      
  94      =1  87  1010111 7.04      
  95      =1  88  1011000 7.08      
  96      =1  89  1011001 7.12      
  97      =1  90  1011010 7.16      
  98      =1  91  1011011 7.20      
  99      =1  92  1011100 7.24      
 100      =1  93  1011101 7.28      
 101      =1  94  1011110 7.32      
 102      =1  95  1011111 7.36      
 103      =1  96  1100000 7.40      
 104      =1  97  1100001 7.44      
 105      =1  98  1100010 7.48      
 106      =1  99  1100011 7.53      
 107      =1  100 1100100 7.57      
 108      =1  101 1100101 7.61      
 109      =1  102 1100110 7.66      
 110      =1  103 1100111 7.71      
 111      =1  104 1101000 7.75      
 112      =1  105 1101001 7.80      
 113      =1  106 1101010 7.84      
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 15  

 114      =1  107 1101011 7.89      
 115      =1  108 1101100 7.94      
 116      =1  109 1101101 7.99      
 117      =1  110 1101110 8.04      
 118      =1  111 1101111 8.09      
 119      =1  112 1110000 8.14      
 120      =1  113 1110001 8.19      
 121      =1  114 1110010 8.25      
 122      =1  115 1110011 8.30      
 123      =1  116 1110100 8.35      
 124      =1  117 1110101 8.41      
 125      =1  118 1110110 8.47      
 126      =1  119 1110111 8.52      
 127      =1  120 1111000 8.58      
 128      =1  121 1111001 8.64      
 129      =1  122 1111010 8.70      
 130      =1  123 1111011 8.76      
 131      =1  124 1111100 8.82      
 132      =1  125 1111101 8.88      
 133      =1  126 1111110 8.95      
 134      =1  127 1111111 9.01      
 135      =1  */
 136      =1  void I2CReadByte3(BYTE *);
 137      =1  void I2CRead8Byte(BYTE *);
 138      =1  #if 0
           =1 void I2CReadByteMSP(BYTE addr, BYTE index, BYTE *pd, BYTE cnt);
           =1 #endif
 141      =1  BYTE I2CWriteByte2(BYTE);
 142      =1  BYTE I2CWriteByte3(BYTE*);
 143      =1  BYTE I2CWrite8Byte(BYTE *);
 144      =1  
 145      =1  void I2CStart(void);
 146      =1  void I2CWriteData(BYTE value);
 147      =1  BYTE I2CReadData(void);
 148      =1  #if 0
           =1 BYTE I2CReadDataWithACK(void);
           =1 #endif
 151      =1  void I2CStop(void);
 152      =1  void I2Cdelay(void);
 153      =1  
 154      =1  
 155      =1  
 156      =1  #define WriteTW88(a,b)    WriteI2C(TW88I2CAddress, a, b)
 157      =1  #define ReadTW88(a)     ReadI2C(TW88I2CAddress, a)
 158      =1  /*
 159      =1  
 160      =1  
 161      =1  BYTE WriteTW88_Wait (BYTE, BYTE);
 162      =1  void WriteADC   (BYTE, BYTE);
 163      =1  BYTE ReadADC    (BYTE);
 164      =1  //BYTE ReadADC_TW88(BYTE index);
 165      =1  void WriteADC_TW88(BYTE index, BYTE dat);
 166      =1  */
 167      =1  void WriteEEP   (WORD, BYTE);
 168      =1  BYTE ReadEEP    (WORD);
 169      =1  //WORD ReadALC106(WORD index);
 170      =1  //void WriteALC106(WORD index, WORD  dat);
 171      =1  
 172      =1  WORD ReadI2CWORD(BYTE addr, BYTE index);
 173      =1  BYTE ReadI2C    (BYTE addr, BYTE index);
 174      =1  void WriteI2C   (BYTE addr, BYTE index, BYTE val);
 175      =1  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 16  

 176      =1  void WriteI2Cn_(BYTE addr, BYTE *val, BYTE cnt);
 177      =1  void WriteI2Cn (BYTE addr, BYTE index, BYTE *val, BYTE cnt);
 178      =1  void WriteI2CnD(BYTE addr, BYTE index, BYTE val, BYTE cnt);
 179      =1  
 180      =1  void ReadI2Cmn(BYTE addr, BYTE wcnt, BYTE rcnt, BYTE *rwdata);
 181      =1  void WriteAD5110(WORD index, WORD  dat);
 182      =1  WORD ReadAD5110(WORD index);
 183      =1  
 184      =1  
 185      =1  #define   WriteADC(a,b) WriteADC_TW88(a,b)
 186      =1  #define   ReadADC(a)    ReadADC_TW88(a)
 187      =1  
 188      =1  #endif  /* __I2C_H__ */
  14          #include "main.h"
   1      =1  #ifndef __MAIN__
   2      =1  #define __MAIN__
   3      =1  
   4      =1  #define ON          1
   5      =1  #define OFF         0
   6      =1  #define Hs_debug
   7      =1  //#define DVR
   8      =1  #define Format_SDCard
   9      =1  #define BJTSwitch
  10      =1  
  11      =1  
  12      =1  
  13      =1  #define Panel_Enable()          P4=P4|0x08 //andy 980908
  14      =1  #define Panel_Disable()     P4=P4&0xf7
  15      =1  
  16      =1  #if 0
           =1 #define SetBacklight()      P4=P4|0x04
           =1 #define clrBacklight()      P4=P4&0xfb
           =1 #else
  20      =1  #define SetBacklight()      P4=P4&0xfb
  21      =1  #define clrBacklight()       P4=P4|0x04
  22      =1  #endif
  23      =1  /*
  24      =1  #define COLUMN1_PIN   P2_3
  25      =1  #define COLUMN2_PIN   P2_4
  26      =1  #define COLUMN3_PIN   P2_5
  27      =1  */
  28      =1  
  29      =1  //InputSelection
  30      =1  /*
  31      =1  struct struct_IdName {
  32      =1    BYTE  Id;
  33      =1    BYTE  Name[16];
  34      =1  };
  35      =1  /*
  36      =1  
  37      =1  #define CH_TW2835              1
  38      =1  #define CH_CAMD                2
  39      =1  #define CH_AV                  3
  40      =1  #define PC             7
  41      =1  #define ChineseDefaultMenu   8
  42      =1  
  43      =1  #define SVIDEO        2
  44      =1  #define COMPONENT     3
  45      =1  //#define ANALOGDTV     4
  46      =1  #define DTV         4
  47      =1  #define TV          5
  48      =1  #define SCART       6
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 17  

  49      =1  
  50      =1  #define DIGITALVGA      8
  51      =1  
  52      =1  #define AIRTV       0 //9
  53      =1  #define CABLETV       1 //0xa
  54      =1  
  55      =1  
  56      =1  #define TVTUNER       0xd   //10
  57      =1  #define MUTE        1 
  58      =1  #define MENU        2 
  59      =1  #define TVVOL       4 
  60      =1  #define CC          8 
  61      =1  #define INPUTINFO     0x10
  62      =1  #define PCINFO        0x20
  63      =1  #define GAUGEINFO           0x40
  64      =1  //#define RATINGINFO      0x40
  65      =1  #define TVCHN       0x80
  66      =1  //#define MUTE        0x40
  67      =1  
  68      =1  #define YPBPR_480i      0
  69      =1  #define YPBPR_576i      1
  70      =1  #define YPBPR_480p      2
  71      =1  #define YPBPR_576p      3
  72      =1  #define YPBPR_1080i     4
  73      =1  #define YPBPR_720p      5
  74      =1  #define YPBPR_720p50    6
  75      =1  */
  76      =1  
  77      =1  #define _STOP_PWM     0x00
  78      =1  #define _RUN_PWM    0xFF
  79      =1  #define _BL_PWM     0x14
  80      =1  #define _CHG_CURR   0x15
  81      =1  
  82      =1  //ADC
  83      =1  #define P16_BTH   6  //P1.6
  84      =1  #define P17_BAT   7  //P1.7
  85      =1  
  86      =1  
  87      =1  
  88      =1  //--------------------------- P0 Define -----------------------------
  89      =1  //#define SEL_MIX     P0_6  // 
  90      =1  //--------------------------- P1 Define -----------------------------
  91      =1  //#define SEL_DVI     P3_5  //LJY062001   
  92      =1  
  93      =1  #define TW88HWReset     P3_4  //LJY001010 //LJY000721
  94      =1  #define PowerUp             P3_7
  95      =1  #define LBEN P1_6
  96      =1  //======================= CDS Control ================================= 
  97      =1  //#define CDS_CTRL           P1_5
  98      =1  /*
  99      =1  extern BYTE SelectModeType;
 100      =1  extern BYTE InputSelection;
 101      =1  extern BYTE SEQTime;
 102      =1  extern BYTE Priority;
 103      =1  extern BYTE PowerFlag;
 104      =1  //extern bit AutoDayNight;
 105      =1  extern bit SDCardCoverDetect;
 106      =1  */
 107      =1  BYTE keyIn(void);
 108      =1  void TimerForRemocon(void);
 109      =1  void TimerForTick(void);
 110      =1  void DisableRemoconInt(void);
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 18  

 111      =1  BYTE SetSupport_remocon(BYTE newd);
 112      =1  
 113      =1  void delay(BYTE cnt);
 114      =1  
 115      =1  BYTE RS_ready(void);
 116      =1  #ifdef Hs_debug
 117      =1  BYTE RS_rx(void);
 118      =1  #endif
 119      =1  void RS_tx(BYTE tx_buf);
 120      =1  
 121      =1  BYTE RS2_rx(void);
 122      =1  void RS2_tx(BYTE tx_buf);
 123      =1  
 124      =1  //void NewLine(void);
 125      =1  //void PutsP(PDATA_P BYTE *ptr);
 126      =1  #ifdef Hs_debug
 127      =1  //void MonWriteI2C(BYTE addr, BYTE index, BYTE val);
 128      =1  //BYTE MonReadI2C(BYTE addr, BYTE index);
 129      =1  #endif
 130      =1  BYTE Asc1Bin(BYTE asc);
 131      =1  BYTE Asc2Bin(PDATA_P BYTE *s);
 132      =1  
 133      =1  //void I2CDeviceInitialize( CODE_P BYTE *RegSet);
 134      =1  
 135      =1  //void RestartSystemClock(WORD clock_hm);
 136      =1  //WORD GetTime_ms(void);
 137      =1  #if 0
           =1 BYTE GetTime_H(void);
           =1 BYTE GetTime_M(void);
           =1 #endif
 141      =1  //void ChangeTime_H( char add );
 142      =1  //void ChangeTime_M( char add );
 143      =1  //WORD GetWakeupTime(void);
 144      =1  //void SetWakeupTime(WORD wtime);
 145      =1  
 146      =1  
 147      =1  //WORD GetOffTime(void);
 148      =1  //void SetOffTime(WORD wtime);
 149      =1  //BYTE GetSleepTimer(void);
 150      =1  //void SetSleepTimer(BYTE stime);
 151      =1  /*
 152      =1  WORD DiffTime_ms( WORD stime, WORD etime );
 153      =1  //void SetLastBlockedTime(void);
 154      =1  void SetLastCCTime(void);       //ljy010904...CC_FIX_CLEAR_ON_TIME
 155      =1  
 156      =1  void SetOSDLastKeyInTime(void);
 157      =1  WORD GetOSDLastKeyInTime(void);
 158      =1  WORD GetIVF(void);
 159      =1  DWORD GetIHF(void);
 160      =1  BYTE ReadVInputSTD(void);
 161      =1  void SetVInputStd(BYTE newd);
 162      =1  BYTE GetVInputStd(void);
 163      =1  BYTE GetInputSelection(void);
 164      =1  #ifdef ADD_ANALOGPANEL
 165      =1  BYTE IsAnalogOn(void);
 166      =1  #endif
 167      =1  void InitVideoData(BYTE src);
 168      =1  void ChangeVInputStdDetectMode(BYTE val);
 169      =1  BYTE GetVInputStdInx(void);
 170      =1  
 171      =1  void MonWriteI2Cn_(BYTE addr, BYTE *val, BYTE cnt) ;
 172      =1  */
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 19  

 173      =1  ///void Usage(void);
 174      =1  #ifdef Hs_debug
 175      =1    void Prompt(void);
 176      =1  #endif
 177      =1  /*
 178      =1  void DebugKeyIn(BYTE ikey);
 179      =1  void DVIPowerDown(bit flag);
 180      =1  void PowerDown_XTAL(bit flag);
 181      =1  */
 182      =1  //void ChangeInput(BYTE newsel);
 183      =1  
 184      =1  
 185      =1  void WaitPowerOn(void);
 186      =1  //void PowerOff(void);
 187      =1  //BYTE GetNextInputSelection(void);
 188      =1  
 189      =1  //BYTE WantToStopTVScan(void);
 190      =1  
 191      =1  //BYTE IsTW8801(void);
 192      =1  //BYTE IsTW8803(void);
 193      =1  //BYTE ConvertVideoVSAT(BYTE reg);
 194      =1  
 195      =1  //BYTE IsNoInput(void);
 196      =1  void LoadEEPROM (void);
 197      =1  void Hs_InitVars(void);
 198      =1  /*
 199      =1  void AdjustAutoDayNight(BYTE val);
 200      =1  void ACCPowerControl(void);
 201      =1  void AdjustBacklight(BYTE val);//val=0~110
 202      =1  */
 203      =1  BYTE mcuLib_ProtocolAppend(BYTE *pucBuf, BYTE* piLen, BYTE ucByte);
 204      =1  BYTE mcuLib_ProtocolSendCmdWithParamNum(BYTE ucType, BYTE* pucParam, BYTE ucSize);
 205      =1  void MCU_SendCmdToDVR(BYTE ucType);
 206      =1  void SetAD5110Step(BYTE newv) ;
 207      =1  
 208      =1  
 209      =1  
 210      =1  extern BYTE ScanPowerkey(void);
 211      =1  extern void MCUTimerInitialTimerEvent(void);
 212      =1  extern void MCUTimerActiveTimerEvent(WORD usTime, BYTE ucEventID);
 213      =1  extern void SysTimerHandler(void);
 214      =1  extern void SysJudgeHandler(void);
 215      =1  extern void SysModeHandler(void);
 216      =1  extern void SysPowerHandler(void);
 217      =1  
 218      =1  extern void MCUTimerDelayXms(WORD usNum);
 219      =1  
 220      =1  
 221      =1  struct RegisterInfo
 222      =1  {
 223      =1     int  Min;
 224      =1     int  Max;
 225      =1     int  Default;
 226      =1  };
 227      =1  struct LongRegisterInfo
 228      =1  {
 229      =1     WORD Min;
 230      =1     WORD Max;
 231      =1     WORD Default;
 232      =1  };
 233      =1  
 234      =1  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 20  

 235      =1  
 236      =1  
 237      =1  #endif  // __MAIN__
  15          //#include "tw88.h"
  16          //#include "osdbasic.h"
  17          //#include "dispinfo.h"
  18          //#include "measure.h"
  19          //#include "debug.h"
  20          #include "printf.h"
   1      =1  #ifndef __PRINTF__
   2      =1  #define __PRINTF__
   3      =1  
   4      =1  #define _outchar(c) while(1) { if( !RS_Xbusy ) { SBUF = c; RS_Xbusy=1; break; } }
   5      =1  #define Putch(c) _outchar(c)
   6      =1  
   7      =1  #ifdef SERIAL
   8      =1  
   9      =1   void Printf ( const char CODE_P *fmt, ... );
  10      =1   void Puts ( CODE_P char *ptr );
  11      =1  
  12      =1  #define TW2835Cmd(a)   Puts ( a )
  13      =1  
  14      =1  #else
           =1 
           =1  #undef  DEBUG
           =1  #define Printf(a,b)  //
           =1  #define Puts(a)      //
           =1 
           =1 #endif
  21      =1  
  22      =1  
  23      =1  #ifndef DEBUG
  24      =1  
  25      =1   #define dPuts(a)   //
  26      =1   #define wPuts(a)   //
  27      =1   #define ePuts(a)   //
  28      =1  
  29      =1  #else
           =1 
           =1  void dPrintf( const char CODE_P *fmt, ... );
           =1  void wPrintf( const char CODE_P *fmt, ... );
           =1  void ePrintf( const char CODE_P *fmt, ... );
           =1 
           =1  void dPuts( CODE_P char *ptr );
           =1  void wPuts( CODE_P char *ptr );
           =1  void ePuts( CODE_P char *ptr );
           =1 
           =1 #endif  // DEBUG
  40      =1  
  41      =1  BYTE Getch(void);
  42      =1  BYTE Getche(void);
  43      =1  
  44      =1  
  45      =1  #endif  //__PRINTF__
  21          //#include "udfont.h"
  22          //#include "regmap.h"
  23          //#include "externs.h"
  24          #include "CPU.h"
   1      =1  #ifndef __CPU__
   2      =1  #define __CPU__
   3      =1  
   4      =1  /*
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 21  

   5      =1  #ifdef INTERNAL_MCU
   6      =1  #define I2C_SCL   P2_0
   7      =1  #else
   8      =1  #define I2C_SCL   P1_0
   9      =1  #endif
  10      =1  #define I2C_SDA   P1_1
  11      =1  */
  12      =1  #define I2C_SCL   P1_0
  13      =1  #define I2C_SDA   P1_1
  14      =1  #define BUF_MAX   8
  15      =1  #define DVR_BUF_MAX   30
  16      =1  
  17      =1  //--------------------------------------------------
  18      =1  // Panel  Related MACRO
  19      =1  //--------------------------------------------------
  20      =1  #define GET_P_IO1()   (P3_4)  
  21      =1  #define SET_P_IO1()   (P3_4 = 1)    
  22      =1  #define CLR_P_IO1()   (P3_4 = 0)  
  23      =1  
  24      =1  #define GET_P_IO2()   (P3_5)  
  25      =1  #define SET_P_IO2()   (P3_5 = 1)    
  26      =1  #define CLR_P_IO2()   (P3_5 = 0)  
  27      =1  
  28      =1  #define GET_BL_PWM()    (P1_4)  
  29      =1  #define SET_BL_PWM()    (P1_4 = 1)    //ON
  30      =1  #define CLR_BL_PWM()    (P1_4 = 0)  //OFF
  31      =1  
  32      =1  #define GET_PCON3V3_P()  (P0_3) 
  33      =1  #define SET_PCON3V3_P()  (P0_3 = 0)    //ON
  34      =1  #define CLR_PCON3V3_P()  (P0_3 = 1) //OFF
  35      =1  
  36      =1  #define GET_PCON5V_P()   (P0_4) 
  37      =1  #define SET_PCON5V_P()   (P0_4 = 0)    //ON
  38      =1  #define CLR_PCON5V_P()   (P0_4 = 1) //OFF
  39      =1  
  40      =1  #define GET_Panel_EN()   (P2_1) 
  41      =1  #define SET_Panel_EN()   (P2_1 = 1)    //ON
  42      =1  #define CLR_Panel_EN()   (P2_1 = 0) //OFF
  43      =1  
  44      =1  #define GET_CTP_INT()   (P2_4)  
  45      =1  #define SET_CTP_INT()   (P2_4 = 1)     //ON
  46      =1  #define CLR_CTP_INT()   (P2_4 = 0)  //OFF
  47      =1  
  48      =1  #define GET_CTP_RST()   (P2_5)  
  49      =1  #define SET_CTP_RST()   (P2_5 = 1)     //ON
  50      =1  #define CLR_CTP_RST()   (P2_5 = 0)  //OFF
  51      =1  
  52      =1  #define GET_PWCTRL()    (P3_7)  
  53      =1  #define SET_PWCTRL()    (P3_7 = 1)     //ON
  54      =1  #define CLR_PWCTRL()    (P3_7 = 0)  //OFF
  55      =1  
  56      =1  //--------------------------------------------------
  57      =1  // Battery  Related MACRO
  58      =1  //--------------------------------------------------
  59      =1  
  60      =1  #define GET_PWR_GOOD()  (P1_5)    
  61      =1  
  62      =1  #define GET_STAT1()   (P0_0)    
  63      =1  #define GET_STAT2()   (P0_1)    
  64      =1  
  65      =1  #define GET_CHG_CURR()    (P0_6)  
  66      =1  #define SET_CHG_CURR()    (P0_6 = 1)     //ON
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 22  

  67      =1  #define CLR_CHG_CURR()    (P0_6 = 0)  //OFF
  68      =1  
  69      =1  #define GET_AC_MODE()   (P4_2)  
  70      =1  #define SET_AC_MODE()   (P4_2 = 1)     //ON
  71      =1  #define CLR_AC_MODE()   (P4_2 = 0)  //OFF
  72      =1  
  73      =1  //--------------------------------------------------
  74      =1  // DVR Power  Related MACRO
  75      =1  //--------------------------------------------------
  76      =1  
  77      =1  #define GET_BAT_SYS()   (P2_6)  
  78      =1  #define SET_BAT_SYS()   (P2_6 = 1)     //ON
  79      =1  #define CLR_BAT_SYS()   (P2_6 = 0)  //OFF
  80      =1  
  81      =1  //--------------------------------------------------
  82      =1  // CAM Power  Related MACRO
  83      =1  //--------------------------------------------------
  84      =1  
  85      =1  #define GET_PCON_CAM()    (P2_2)  
  86      =1  #define SET_PCON_CAM()    (P2_2 = 1)     //ON
  87      =1  #define CLR_PCON_CAM()    (P2_2 = 0)  //OFF
  88      =1  
  89      =1  //--------------------------------------------------
  90      =1  // TW8836 Power  Related MACRO
  91      =1  //--------------------------------------------------
  92      =1  
  93      =1  #define GET_PCON3V3_TW()    (P3_6)  
  94      =1  #define SET_PCON3V3_TW()    (P3_6 = 0)     //ON
  95      =1  #define CLR_PCON3V3_TW()    (P3_6 = 1)  //OFF
  96      =1  
  97      =1  #define GET_TW8836_RST()      (P2_0)  
  98      =1  #define SET_TW8836_RST()      (P2_0 = 0)     //ON
  99      =1  #define CLR_TW8836_RST()      (P2_0 = 1)  //OFF
 100      =1  
 101      =1  
 102      =1  //--------------------------------------------------
 103      =1  // I/O board  Related MACRO
 104      =1  //--------------------------------------------------
 105      =1  
 106      =1  #define GET_GREEN()       (P4_0)  
 107      =1  #define SET_GREEN()       (P4_0 = 0)     
 108      =1  #define CLR_GREEN()       (P4_0 = 1)  
 109      =1  
 110      =1  #define GET_RED()         (P4_1)  
 111      =1  #define SET_RED()         (P4_1 = 0)     
 112      =1  #define CLR_RED()         (P4_1 = 1)  
 113      =1  
 114      =1  #define GET_PSW()       (P4_3)  
 115      =1  #define SET_PSW()       (P4_3 = 1)     
 116      =1  #define CLR_PSW()       (P4_3 = 0)  
 117      =1  
 118      =1  #define GET_ADAP_12()     (P0_5)  
 119      =1  #define SET_ADAP_12()     (P0_5 = 1)     
 120      =1  #define CLR_ADAP_12()     (P0_5 = 0)  
 121      =1  
 122      =1  
 123      =1  #ifdef REMO_RC5
           =1 #define EnableRemoconInt()  { RemoDataReady = 0;  EX0 = 1;}
           =1 #endif
 126      =1  void  InitCPU(void);
 127      =1  void  InitVars(void);
 128      =1  void  InitTechwell(void);
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 23  

 129      =1  void  main_init (void);
 130      =1  void  PowerDown( void );
 131      =1  #if 0
           =1 BYTE  OKSleepTime(void);
           =1 #endif
 134      =1  #ifdef REMO_RC5
           =1 void  InitForRemo(void);
           =1 #endif
 137      =1  void  PowerLED(BYTE flag);
 138      =1  void    Wait_ms(WORD Tms);
 139      =1  BYTE    TW2835Command(char,char,char,char,char);
 140      =1  void SET_PWM(BYTE index, BYTE val);
 141      =1  
 142      =1  #endif
  25          
  26          //#include "panel.h"
  27          //#include "osdmenu.h"
  28          #include "HS_DVRProtocol.h"
   1      =1  
   2      =1  #ifndef _HS_DVRProtocol_
   3      =1  #define _HS_DVRProtocol_
   4      =1  
   5      =1  //==================================================
   6      =1  //
   7      =1  //
   8      =1  //
   9      =1  //==================================================
  10      =1  /*
  11      =1  #define bSetDVRParam  0x0001
  12      =1  #define bSetDVRDefault  0x0002
  13      =1  #define bSetDATETIME  0x0004
  14      =1  #define bGetDVRParam  0x0008
  15      =1  #define bGetDVRStatus 0x0010
  16      =1  #define bGetDATETIME  0x0020
  17      =1  #define bBOOKMARK   0x0040
  18      =1  #define bSetSystem    0x0080
  19      =1  #define bHalt_Start     0x0100
  20      =1  #define bSetFormatSD    0x0200  
  21      =1  #define bGetDVRVersion  0x0400  
  22      =1  #define bFW_Update_Start 0x0800
  23      =1  #define bUpdate_CONFIG  0x1000
  24      =1  #define bDoorClose    0x2000
  25      =1  #define bDoorOpen     0x4000
  26      =1  */
  27      =1  //DVR to MCU command 
  28      =1  
  29      =1  #define MCU_PROTOCOL_CMD_SYS_READY_NOTICE   0x01///DVR system ready notice
  30      =1  #define MCU_PROTOCOL_CMD_WATCH_DOG_KICK     0x02///DVR WDT kick
  31      =1  #define MCU_PROTOCOL_CMD_ENTRY_SLEEP        0x03///DVR sleep mode
  32      =1  #define MCU_PROTOCOL_CMD_DISTANCE_RESET     0x04///DVR distance reset  0M
  33      =1  #define MCU_PROTOCOL_CMD_ENCODER_SET        0x05///Encoder deviation setting
  34      =1  #define MCU_PROTOCOL_CMD_CAMERA_VOLTAGE     0x06///Camera voltage adjust
  35      =1  #define MCU_PROTOCOL_CMD_STOP_REBOOT                        0x07///stop retoot 
  36      =1  #define MCU_PROTOCOL_CMD_GET_MCU_FW     0x10///MCU FW version
  37      =1  #define MCU_PROTOCOL_CMD_DVR_REBOOT     0x11///DVR Reboot
  38      =1  #define MCU_PROTOCOL_CMD_DVR_SHUTDOWN   0x12///DVR shutdown
  39      =1  
  40      =1  //MCU to DVR command 
  41      =1  #define MCU_PROTOCOL_CMD_REPLY_MCU_FW     0x80  //Reply MCU firmware version
  42      =1  #define MCU_PROTOCOL_CMD_REGULAR_DATA       0x81      //Regular data
  43      =1  #define MCU_PROTOCOL_CMD_SYSTEM_SHUTDOWN    0x82      //system shutdown
  44      =1  #define MCU_PROTOCOL_CMD_ENTRY_FACTORY      0x83      //Entry factory mode
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 24  

  45      =1  
  46      =1  // 3521 Command
  47      =1  #define CMD_TEMP      0x0A
  48      =1  #define CMD_BATERY      0x0B
  49      =1  #define CMD_ROLLENC     0x0C
  50      =1  #define CMD_MCU_ROLLENC     0x80
  51      =1  #define CMD_MCU_TEMP      0x8A
  52      =1  #define CMD_MCU_BATERY    0x8B
  53      =1  #define CMD_DVR_PING        0x00
  54      =1  
  55      =1  #define CMD_OSDTYPE      0x11
  56      =1  #define CMD_KEY        0x12
  57      =1  #define CMD_BRIGHTNESS     0x13
  58      =1  #define CMD_GET_VERSION    0x18
  59      =1  #define CMD_RESPONSE_VERSION 0x09
  60      =1  #define CMD_REC_LED          0x0D
  61      =1  #define CMD_Protect_POWER  0x39
  62      =1  #define CMD_POWER_ON         0x38
  63      =1  #define CMD_BATT_Lo     0x40
  64      =1  
  65      =1  #define CMD_POWER_SEL        0x0E
  66      =1  #define CMD_POWER_LINK     0x0F
  67      =1  
  68      =1  
  69      =1  
  70      =1  
  71      =1  #define PROTOCOL_DEFINE
  72      =1  
  73      =1  #define PROTOCOL_DATA_LENGTH                256
  74      =1  
  75      =1  #define PROTOCOL_STATE_NONE               0
  76      =1  #define PROTOCOL_STATE_TYPE               1
  77      =1  #define PROTOCOL_STATE_LENGTH             2
  78      =1  #define PROTOCOL_STATE_DATA               3
  79      =1  #define PROTOCOL_STATE_CHECKSUM             4
  80      =1  
  81      =1  #define PROTOCOL_MCU_VERSION                          0x22
  82      =1  #define PROTOCOL_CMD_GET_VERSION                      0x08
  83      =1  #define PROTOCOL_RESPONSE_VERSION           0x09
  84      =1  
  85      =1  #define PROTOCOL_CMD_ENTER_ISP              0x30
  86      =1  #define PROTOCOL_CMD_ISP_PING             0x31
  87      =1  #define PROTOCOL_CMD_ISP_ERASE              0x32
  88      =1  #define PROTOCOL_CMD_ISP_WRITE              0x33
  89      =1  #define PROTOCOL_CMD_ISP_READ             0x34
  90      =1  #define PROTOCOL_CMD_ISP_SEND_DATA            0x35
  91      =1  #define PROTOCOL_CMD_ISP_ACK              0x36
  92      =1  #define PROTOCOL_CMD_ISP_NAK              0x37
  93      =1  #define PROTOCOL_CMD_ISP_REBOOT             0x38
  94      =1  
  95      =1  enum BATERY_State
  96      =1  {
  97      =1   BATERY_100,
  98      =1   BATERY_75,
  99      =1   BATERY_50,
 100      =1   BATERY_25,
 101      =1   BATERY_10,
 102      =1   BATERY_AC
 103      =1  };
 104      =1  
 105      =1  enum BRIGHTNESS_STATE
 106      =1  {
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 25  

 107      =1    BRIGHTNESS_MIN,
 108      =1    BRIGHTNESS_NORMAL,
 109      =1    BRIGHTNESS_MAX
 110      =1  };
 111      =1  
 112      =1  enum POWER_STATE
 113      =1  {
 114      =1    POWER_SEL_ON,
 115      =1    POWER_SEL_OFF,
 116      =1    POWER_SEL_SAVING
 117      =1  };
 118      =1  
 119      =1  enum TEMP_State
 120      =1  {
 121      =1   TEMP_OK,
 122      =1   TEMP_Alarm1,
 123      =1   TEMP_Alarm2
 124      =1  };
 125      =1  /*
 126      =1  enum HS_DvrCommand
 127      =1  {
 128      =1    CMD_NULL,
 129      =1    SetDVRParam,  // 1
 130      =1    SetDVRDefault,
 131      =1    SetDATETIME,
 132      =1    GetDVRParam,
 133      =1    GetDVRStatus,
 134      =1    GetDATETIME, 
 135      =1    SetFormatSD, 
 136      =1    SendAlarm, 
 137      =1    GetDVRVersion=0x09, 
 138      =1    SendDVRStatus=0x14,
 139      =1    GetLCDMode=0x15,
 140      =1    SendDVRParam=0x16,
 141      =1    SendDVRParamDT=0x17,
 142      =1    SetFormatSDDone=0x18,
 143      =1    GetInformation=0x19,
 144      =1    SetSystem=0x1a,
 145      =1    GPSReset=0x1b,
 146      =1    Halt_Start=0xc8,
 147      =1    Halt_OK=0xc9,
 148      =1    FW_Update_Start=0xca,
 149      =1    FW_Update_OK=0xcb,
 150      =1    MANUALRECSTART=0xdc,
 151      =1    MANUALRECSTOP=0xdd,
 152      =1    SNAPSHOT=0xde,
 153      =1    BOOKMARK=0xdf,
 154      =1    Update_CONFIG=0xe0,
 155      =1    Update_CONFIG_OK=0xe1,
 156      =1    DoorOpen=0xe2,
 157      =1    DoorClose=0xe3,
 158      =1    CMD_UNKNOWN=0xff,
 159      =1    CMD_NUM
 160      =1  };
 161      =1  */
 162      =1  
 163      =1  //RS485 TX or RX define
 164      =1  /*
 165      =1  enum
 166      =1  {
 167      =1    RS485_TX,   //RS485 Transmit  
 168      =1    RS485_RX    //Rs485 Receive
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 26  

 169      =1  };
 170      =1  
 171      =1  enum
 172      =1  {
 173      =1    Baud_rate2400,    
 174      =1    Baud_rate4800,  
 175      =1    Baud_rate9600
 176      =1  };
 177      =1  
 178      =1  
 179      =1  
 180      =1  //Camera Command ID define
 181      =1  enum
 182      =1  {
 183      =1  //  CAM_CLEAR,        //Clear 
 184      =1    CAM_ZOOM_OUT_START,     //Zoom Out  Start
 185      =1  //  CAM_ZOOM_OUT_END,     //Zoom Out  End
 186      =1    CAM_ZOOM_IN_START,      //Zoom In Start
 187      =1  //  CAM_ZOOM_IN_END,      //Zoom In End
 188      =1  //  CAM_IRIS_CLOSE_START,   //IRIS Close Start
 189      =1  //  CAM_IRIS_CLOSE_END,   //IRIS Close End
 190      =1  //  CAM_IRIS_OPEN_START,      //IRIS Open Start
 191      =1  //  CAM_IRIS_OPEN_END,      //IRIS Open End
 192      =1  //  CAM_FOCUS_FAR_START,    //Focus Far Start
 193      =1  //  CAM_FOCUS_FAR_END,    //Focus Far End
 194      =1  //  CAM_FOCUS_NEAR_START,   //Focus Near Start
 195      =1  //  CAM_FOCUS_NEAR_END,   //Focus Near End
 196      =1    CAM_SET,        //Set 
 197      =1    CAM_CALL,       //Call 
 198      =1  //  CAM_FOCUS_SPEED,    //Focus Speed
 199      =1  //  CAM_ZOOM_SPEED,   //Zoom Speed
 200      =1    CAM_PTZ_RIGHT,      //PTZ Right 
 201      =1    CAM_PTZ_LEFT,     //PTZ Left
 202      =1    CAM_PTZ_UP,     //PTZ Up
 203      =1    CAM_PTZ_DOWN,     //PTZ Down
 204      =1    CAM_MENU_ENTER,     //PTZ Down
 205      =1    CAM_Iris_Open,
 206      =1  
 207      =1  //  CAM_PTZ_RIGHT_UP,   //PTZ Right with Up
 208      =1  //  CAM_PTZ_RIGHT_DOWN, //PTZ Right with Down
 209      =1  //  CAM_PTZ_LEFT_UP,    //PTZ Left with Up
 210      =1  //  CAM_PTZ_LEFT_DOWN,  //PTZ Left with Down
 211      =1    CAM_PTZ_STOP      //PTZ Control Stop
 212      =1  };
 213      =1  */
 214      =1  
 215      =1  void Hs_DvrTxCmdPaser(BYTE Cmd_Id );
 216      =1  void Hs_Protocol_Init(void);
 217      =1  void DvrReceivePaser(void);
 218      =1  void DVRCommandReSend(void);
 219      =1  extern void MCUTimerDelayXms(WORD usNum);
 220      =1  
 221      =1  
 222      =1  #if 0
           =1 BYTE TW2835ReceivePaser(void);
           =1 #endif
 225      =1  extern bit   DVR_Ready;
 226      =1  void CAM_TxCommand_toRS485(BYTE Com_ID);
 227      =1  void Send_PelcoP_Command(void);
 228      =1  void Send_PelcoD_Command(void);
 229      =1  void Send_GE_Command(void);
 230      =1  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 27  

 231      =1  
 232      =1  
 233      =1  
 234      =1  #endif
 235      =1  
  29          //#include "HS_IOdef.h"
  30          //#include "HS_DisplayOSD.h"
  31          
  32          #include "keyremo.h"
   1      =1  #ifndef __KEYREMO_H__
   2      =1  #define __KEYREMO_H__
   3      =1  
   4      =1  //
   5      =1  // KeyRemo.h
   6      =1  // Default function for Key Input and Remocon Input
   7      =1  //
   8      =1  //=============================================================================
   9      =1  //                        Operation Key Mapping
  10      =1  //=============================================================================
  11      =1  
  12      =1  
  13      =1  
  14      =1  /*
  15      =1  
  16      =1  #define ResetKey()    { P2 = 0xff;}
  17      =1  //#define ReadKey()   (~P1 & 0xfc);
  18      =1  
  19      =1  
  20      =1  #define DVR_POWER 0x01
  21      =1  #define DVR_MENU  0x03
  22      =1  #define DVR_RECORD  0x05
  23      =1  #define DVR_PLAY  0x07
  24      =1  #define DVR_STOP  0x09
  25      =1  #define DVR_RIGHT 0x0b
  26      =1  #define DVR_LEFT  0x0d
  27      =1  #define DVR_UP    0x10
  28      =1  #define DVR_DOWN  0x12
  29      =1  #define DVR_RESET 0x13
  30      =1  #define DVR_FAC     0x99
  31      =1  #define DVR_RESET_OSD   0x98
  32      =1  */
  33      =1  
  34      =1  #if 0//def QUAD
           =1 #define EVENTKEY    0x02
           =1 #endif
  37      =1  /*
  38      =1  #define POWERKEY    0x04 //andy AWT 980907
  39      =1  #define MENUKEY     0x08
  40      =1  #define INPUTSOURCEKEY  0x10
  41      =1  #define UPKEY       0x20
  42      =1  #define DOWNKEY       0x40
  43      =1  #define SELECTKEY     0x80
  44      =1  #define VersionKEY      0x90
  45      =1  #define PLAYKEY         0x01
  46      =1  
  47      =1  #define REMO_CUSTOM   0
  48      =1  
  49      =1  #define REMO_NUM0   0
  50      =1  #define REMO_NUM1   1
  51      =1  #define REMO_NUM2   2
  52      =1  #define REMO_NUM3   3
  53      =1  #define REMO_NUM4   4
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 28  

  54      =1  #define REMO_NUM5   5
  55      =1  #define REMO_NUM6   6
  56      =1  #define REMO_NUM7   7
  57      =1  #define REMO_NUM8   8
  58      =1  #define REMO_NUM9   9
  59      =1  
  60      =1  #define REMO_STANDBY  12
  61      =1  #define REMO_CHNUP    32
  62      =1  #define REMO_CHNDN    33
  63      =1  #define REMO_VOLUP    16
  64      =1  #define REMO_VOLDN    17
  65      =1  #define REMO_SELECT   21
  66      =1  #define REMO_MENU   63
  67      =1  #define REMO_MUTE   13
  68      =1  #define REMO_INPUT    56
  69      =1  
  70      =1  #define REMO_AUTO   10
  71      =1  #define REMO_INFO   58
  72      =1  #define REMO_AUDIO    38
  73      =1  #define REMO_ASPECT   62
  74      =1  #define REMO_CC     15
  75      =1  #define REMO_EXIT   0x16
  76      =1  
  77      =1  #define REMO_TTXRED     0x37
  78      =1  #define REMO_TTXGREEN   0x36
  79      =1  #define REMO_TTXYELLOW    0x32
  80      =1  #define REMO_TTXCYAN    0x34
  81      =1  
  82      =1  */
  83      =1  
  84      =1  //=============================================================================
  85      =1  //                                 RC5 type
  86      =1  //=============================================================================
  87      =1  #if 0//def REMO_RC5
           =1 
           =1 #ifdef TECHWELL_REMOCON
           =1 #define REMO_CUSTOM   0
           =1 
           =1 #define REMO_NUM0   0
           =1 #define REMO_NUM1   1
           =1 #define REMO_NUM2   2
           =1 #define REMO_NUM3   3
           =1 #define REMO_NUM4   4
           =1 #define REMO_NUM5   5
           =1 #define REMO_NUM6   6
           =1 #define REMO_NUM7   7
           =1 #define REMO_NUM8   8
           =1 #define REMO_NUM9   9
           =1 
           =1 #define REMO_STANDBY  12
           =1 #define REMO_CHNUP    32
           =1 #define REMO_CHNDN    33
           =1 #define REMO_VOLUP    16
           =1 #define REMO_VOLDN    17
           =1 #define REMO_SELECT   21
           =1 #define REMO_MENU   63
           =1 //#define REMO_TV     63
           =1 //#define REMO_VCR    60
           =1 //#define REMO_SVIDEO   56
           =1 #define REMO_MUTE   13
           =1 #define REMO_INPUT    56
           =1 
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 29  

           =1 #define REMO_AUTO   10
           =1 #define REMO_INFO   58
           =1 #define REMO_AUDIO    38
           =1 #define REMO_ASPECT   62
           =1 #define REMO_CC     15
           =1 #define REMO_EXIT   0x16
           =1 
           =1 #define REMO_TTXRED     0x37
           =1 #define REMO_TTXGREEN   0x36
           =1 #define REMO_TTXYELLOW    0x32
           =1 #define REMO_TTXCYAN    0x34
           =1 
           =1 #ifdef SUPPORT_DEBUG
           =1 #define REMO_DEBUG    0x2b
           =1 #define REMO_READ   0x29
           =1 #define REMO_WRITE    0x2a
           =1 #define REMO_RESERVED 0x30
           =1 #endif
           =1 
           =1 #else 
           =1 #define REMO_CUSTOM   0
           =1 
           =1 #define REMO_NUM0   0
           =1 #define REMO_NUM1   1
           =1 #define REMO_NUM2   2
           =1 #define REMO_NUM3   3
           =1 #define REMO_NUM4   4
           =1 #define REMO_NUM5   5
           =1 #define REMO_NUM6   6
           =1 #define REMO_NUM7   7
           =1 #define REMO_NUM8   8
           =1 #define REMO_NUM9   9
           =1 
           =1 #define REMO_STANDBY  12
           =1 #define REMO_CHNUP    32
           =1 #define REMO_CHNDN    33
           =1 #define REMO_VOLUP    16
           =1 #define REMO_VOLDN    17
           =1 #define REMO_SELECT   18
           =1 #define REMO_MENU   48
           =1 #define REMO_TV     63
           =1 #define REMO_VCR    60
           =1 #define REMO_SVIDEO   56
           =1 #define REMO_MUTE   13
           =1 #define REMO_INPUT    0xff
           =1 
           =1 #define REMO_INFO   0x0a //??
           =1 #endif
           =1 
           =1 //=============================================================================
           =1 //                                 NEC type
           =1 //=============================================================================
           =1 #elif defined REMO_NEC
           =1 /*
           =1 // Techwell Origin
           =1 #define REMO_CUSTOM1  0x20
           =1 #define REMO_CUSTOM2  0xdf
           =1 
           =1 
           =1 #define REMO_NUM0   0x08
           =1 #define REMO_NUM1   0x88
           =1 #define REMO_NUM2   0x48
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 30  

           =1 #define REMO_NUM3   0xc8
           =1 #define REMO_NUM4   0x28
           =1 #define REMO_NUM5   0xa8
           =1 #define REMO_NUM6   0x68
           =1 #define REMO_NUM7   0xe8
           =1 #define REMO_NUM8   0x18
           =1 #define REMO_NUM9   0x98
           =1 
           =1 #define REMO_STANDBY  0x10
           =1 #define REMO_CHNUP    0x00
           =1 #define REMO_CHNDN    0x80
           =1 #define REMO_VOLUP    0x40
           =1 #define REMO_VOLDN    0xc0
           =1 #define REMO_SELECT   0x70
           =1 #define REMO_MENU   0x9c
           =1 #define REMO_MUTE   0x90
           =1 #define REMO_INPUT    0xd0
           =1 */
           =1 
           =1 // Techwell New Remocon after 4/7/2005
           =1 #if 0//def PHILIPS_REMOCON
           =1 #define REMO_CUSTOM1  0x02
           =1 #define REMO_CUSTOM2  0xfd
           =1 
           =1 #define REMO_NUM0   0x00
           =1 #define REMO_NUM1   0x80
           =1 #define REMO_NUM2   0x40
           =1 #define REMO_NUM3   0xc0
           =1 #define REMO_NUM4   0x20
           =1 #define REMO_NUM5   0xa0
           =1 #define REMO_NUM6   0x60
           =1 #define REMO_NUM7   0xe0
           =1 #define REMO_NUM8   0x10
           =1 #define REMO_NUM9   0x90
           =1 
           =1 #define REMO_STANDBY  0x48
           =1 #define REMO_CHNUP    0xd8
           =1 #define REMO_CHNDN    0xf8
           =1 #define REMO_VOLUP    0x58
           =1 #define REMO_VOLDN    0x78
           =1 #define REMO_SELECT   0xe8
           =1 #define REMO_MENU   0x01
           =1 #define REMO_MUTE   0x08
           =1 #define REMO_INPUT    0xf0
           =1 
           =1 #define REMO_INFO   0x38
           =1 
           =1 
           =1 
           =1 #define REMO_TTXRED     0x4E
           =1 #define REMO_TTXGREEN   0x8E
           =1 #define REMO_TTXYELLOW    0xC6
           =1 #define REMO_TTXCYAN    0x86
           =1 
           =1 /#else
           =1 // RYU For Test
           =1 #define REMO_CUSTOM1    0x04
           =1 #define REMO_CUSTOM2    0xfb
           =1 
           =1 #define REMO_NUM0   0xf8
           =1 #define REMO_NUM1   0x48
           =1 #define REMO_NUM2   0xc8
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 31  

           =1 #define REMO_NUM3   0x28
           =1 #define REMO_NUM4   0xa8
           =1 #define REMO_NUM5   0x18
           =1 #define REMO_NUM6   0x98
           =1 #define REMO_NUM7   0x58
           =1 #define REMO_NUM8   0xd8
           =1 #define REMO_NUM9   0x78
           =1 
           =1 #define REMO_STANDBY  0x00
           =1 #define REMO_CHNUP    0x40  //
           =1 #define REMO_CHNDN    0x70  //
           =1 #define REMO_VOLUP    0x90  //
           =1 #define REMO_VOLDN    0xe0  //
           =1 #define REMO_SELECT   0x11//??
           =1 #define REMO_MENU   0x10
           =1 
           =1 #define REMO_MUTE   0x60
           =1 #define REMO_INPUT    0xc0
           =1 #define REMO_AUTO   0x30
           =1 #define REMO_AUTOSCAN 0x80
           =1 #define REMO_TV     0x20
           =1 #define REMO_EXIT   0xa0
           =1 #define REMO_INFO   0x08
           =1 #define REMO_ASPECT   0x62
           =1 
           =1 #define REMO_TTXRED   0xb8
           =1 #define REMO_TTXGREEN 0x02
           =1 #define REMO_TTXYELLOW  0x82
           =1 #define REMO_TTXCYAN  0x42
           =1 
           =1 #ifdef SUPPORT_DEBUG
           =1 #define REMO_DEBUG    0xb8
           =1 #define REMO_READ   0x02
           =1 #define REMO_WRITE    0x82
           =1 #endif
           =1 
           =1 #endif //PHILIPS_REMOCON
           =1 
           =1 #endif // REMO_NEC
 279      =1  
 280      =1  BYTE GetKey(BYTE repeat);
 281      =1  void Scankey(void);
 282      =1  
 283      =1  /*
 284      =1  BYTE ActionRemo(BYTE, BYTE);
 285      =1  BYTE CheckKeyIn(void);
 286      =1  
 287      =1  BYTE IsRemoDataReady(BYTE *, BYTE *);
 288      =1  
 289      =1  void protocol_send_cmd_with_param_num(unsigned char type, unsigned char* param, unsigned char len) ;
 290      =1  BYTE ScanPowerkey(void);
 291      =1  */
 292      =1  
 293      =1  #endif
  33          //#include "HS_keyremo.h"
  34          #include "Etc_eep.h"
   1      =1  #ifndef __ETC_EEP__
   2      =1  #define __ETC_EEP__
   3      =1  
   4      =1  
   5      =1  ////eeprom.h
   6      =1  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 32  

   7      =1  
   8      =1  #define  EEP_Powerflag            0x10   
   9      =1  #define  EEP_CameraVolt           0x11   
  10      =1  
  11      =1  
  12      =1  //=========================================================================
  13      =1  //  EEPROM structure
  14      =1  //  0x00  BYTE  4 'TW88'
  15      =1  #define EEP_FWREV_MAJOR     0x04  //BYTE  1 F/W Rev.-major(Hex) 
  16      =1  #define EEP_FWREV_MINOR     0x05  //BYTE  1 F/W Rev.-minor(Hex)
  17      =1  #define EEP_DEBUGLEVEL      0x06  //BYTE  1 DebugLevel
  18      =1  /*//
  19      =1  #define EEP_AUTODETECT      0x07  //BYTE  1 Flag for Input Auto Detect  -0:Auto, 1:NTSC,....
  20      =1  #define EEP_AUTODETECTTYTE    0x08  //BYTE  1 Type of Auto-detect(will be value of register 0x1d)
  21      =1  //      ---------------------------------------------------------------
  22      =1  #define EEP_WIDEMODE      0x09  //BYTE  1   Wide Mode
  23      =1  
  24      =1  #define EEP_AUTORECOGNITION   0x0a  //BYTE  1 Auto Recognition
  25      =1  #define EEP_VIDEOMODE     0x0b  //BYTE  1   Video Mode
  26      =1  
  27      =1  #define EEP_OSDLANG       0x0c  //BYTE  1   OSDLang           // 0
  28      =1  
  29      =1  #define EEP_OSDPOSITIONMODE   0x0d  //BYTE  1 OSD Position Mode
  30      =1  #define EEP_CCD         0x0e  //BYTE  1 Closed Caption- 0: off, 1:on
  31      =1  
  32      =1  #define EEP_INPUTSELECTION    0x0f  //BYTE  1 InputSelection
  33      =1  
  34      =1  //
  35      =1  #define EEP_PC_CONTRAST     0x10
  36      =1  #define EEP_PC_BRIGHT     0x11
  37      =1  
  38      =1  #define EEP_CONTRAST      0x12  //BYTE  1 Contrast 
  39      =1  #define EEP_BRIGHTNESS      0x13  //BYTE  1 Brightness
  40      =1  #define EEP_SATURATION_U    0x14  //BYTE  1 Saturation :U
  41      =1  #define EEP_SATURATION_V    0x15  //BYTE  1 Saturation :V
  42      =1  #define EEP_SHARPNESS     0x16  //BYTE  1 Sharpness 
  43      =1  #define EEP_HUE         0x17  //BYTE  1 Hue                    
  44      =1  
  45      =1  //====================================HS AWT 981001
  46      =1  #define  EEP_AutoMode           0xa0
  47      =1  #define  EEP_IMAGEMode          0xa1
  48      =1  #define  EEP_RearMode           0xa2
  49      =1  #define  EEP_COSDMode           0xa3
  50      =1  #define  EEP_GAUGEMode          0xa4
  51      =1  #define  EEP_CAMAMode           0xa5 
  52      =1  #define  EEP_CAMBMode           0xa6
  53      =1  #define  EEP_CAMCMode           0xa7
  54      =1  #define  EEP_CAMRMode           0xa8
  55      =1  #define  EEP_CAMOutMode         0xa9  
  56      =1  #define  EEP_TimeStep           0xaa
  57      =1  
  58      =1  
  59      =1  
  60      =1  #define  EEP_ONOFFChoice        0xac 
  61      =1  
  62      =1  #define  EEP_PRIORITY           0xad
  63      =1  #define  EEP_JUMPMode           0xae
  64      =1  #define  EEP_NowModeState       0xaf
  65      =1  #define  EEP_SelectMode         0xb0
  66      =1  #define  EEP_PriorityOffSelectMode  0xb1
  67      =1  #define  EEP_AudioRecord    0xb2
  68      =1  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 33  

  69      =1  #define  EEP_FirstNumber    0xb3
  70      =1  #define  EEP_SecondNumber   0xb4
  71      =1  #define  EEP_ThridNumber    0xb5
  72      =1  #define  EEP_FourthNumber   0xb6
  73      =1  
  74      =1  #define  EEP_CAMNUMBER     0xb7
  75      =1  #define  EEP_PELCO       0xb8
  76      =1  #define  EEP_Baud_rate     0xb9
  77      =1  #define  EEP_TriggerVGA    0xba
  78      =1  #define  EEP_DVRDisplay    0xbb
  79      =1  #define  EEP_IMAGE_A_Mode    0xbc//andy A1.4 20100113
  80      =1  #define  EEP_IMAGE_B_Mode    0xbd//andy A1.4 20100113
  81      =1  #define  EEP_IMAGE_C_Mode    0xbe//andy A1.4 20100113
  82      =1  
  83      =1  #define  EEP_SDCardDetect    0xbf//andy A1.4 20100113
  84      =1  
  85      =1  
  86      =1  #define  EEP_DELAYCAMA           0xC0 
  87      =1  #define  EEP_DELAYCAMB           0xC1
  88      =1  #define  EEP_DELAYCAMC           0xC2
  89      =1  #define  EEP_DELAYCAMR           0xC3
  90      =1  #ifdef USE_CAMD
  91      =1  #define  EEP_DELAYCAMD           0xC4
  92      =1  #endif
  93      =1  //#define  EEP_SelectModeBuf         0xb2
  94      =1  #define  EEP_ReverseMode    0xc5
  95      =1  #define  EEP_JUMPAV_TIMESET 0xc6
  96      =1  
  97      =1  #define EEP_OSD_TYPE    0xc7
  98      =1  #define EEP_OSD_LANGUAGE  0xc8
  99      =1  #define EEP_OSD_BRIGHTNESS  0xc9
 100      =1  #define EEP_OSD_PWR_LINK  0xca
 101      =1  
 102      =1  #if 0
 103      =1  #define  EEP_Resolution     0xc0
 104      =1  #define  EEP_FPS        0xc1
 105      =1  #define  EEP_Quality      0xc2
 106      =1  #define  EEP_RecordMode     0xc3
 107      =1  #define  EEP_RecordLength   0xc4
 108      =1  #define  EEP_PreAlarmLength   0xc5
 109      =1  #define  EEP_PostAlarmLength  0xc6
 110      =1  #endif
 111      =1  //====================================HS AWT 981001
 112      =1  
 113      =1  //
 114      =1  //        ---------------------------------------------------------------
 115      =1  #define EEP_PCAUDIOPVOL   0x37  //BYTE  1   AudioVol
 116      =1  #define EEP_AUDIOPVOL     0x38  //BYTE  1   AudioVol
 117      =1  #define EEP_AUDIOBALANCE    0x39  //BYTE  1   AudioBalance
 118      =1  //
 119      =1  //        ---------------------------------------------------------------
 120      =1  
 121      =1  #define EEP_BLOCKMOVIE      0x40  //BYTE  1 BlockedMovie:Blocked rating for Movie 
 122      =1  #define EEP_BLOCKTV       0x41  //BYTE  1 BlockedTV:Blocked rating for TV     
 123      =1  #define EEP_FVSLD       0x42  //BYTE  6
 124      =1  //                            7    6       4    3    2    1    0
 125      =1  //  FVSLD Level                        ALL   FV(V)   S    L    D    
 126      =1  //  0x43    BYTE    1   TV-Y            X  
 127      =1  //  0x44  BYTE    1   TV-Y7           X    X 
 128      =1  //  0x45  BYTE    1   TV-G            X 
 129      =1  //  0x46  BYTE    1   TV-PG           X       X    X    X    X
 130      =1  //  0x47  BYTE    1   TV-14           X       X    X    X    X 
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 34  

 131      =1  //  0x48  BYTE    1   TV-MA           X       X    X    X
 132      =1  //
 133      =1  #define EEP_VCHIPPASSWORD   0x49  //BYTE  4   OSDPassword         //Defualt:3366
 134      =1  */
 135      =1  //      ---------------------------------------------------------------
 136      =1  //
 137      =1  //
 138      =1  //  0x61  WORD  2   PanelXRes
 139      =1  //  0x63  WORD  2 PanelYRes
 140      =1  //  0x65  BYTE  1 PanelHsyncMinPulseWidth
 141      =1  //  0x66  BYTE  1 PanelVsyncMinPulseWidth
 142      =1  //  0x67  WORD  2 PanelHminBackPorch
 143      =1  //  0x69  BYTE  1 PanelHsyncPolarity
 144      =1  //  0x6a  BYTE  1 PanelVsyncPolarity
 145      =1  //  0x6b  WORD  2 PanelDotClock
 146      =1  //  0x6d  BYTE  1 PanelPixsPerClock
 147      =1  //  0x6e  BYTE  1 PanelDEonly
 148      =1  //      ---------------------------------------------------------------
 149      =1  //
 150      =1  //  0x80  PC Data
 151      =1  //
 152      =1  //      ---------------------------------------------------------------
 153      =1  //
 154      =1  //  0x300 TV Data
 155      =1  //
 156      =1  //  --- NTSC_TV -------------------------------------------------------------
 157      =1  //  CNT_SAVEDAIR      BYTE  1   Total count of saved Air TV Channel.
 158      =1  //  IDX_CURAIR        BYTE  1   Index of Current Air TV Channel
 159      =1  //  CHN_CURAIR        BYTE    1   Current Air TV Channel.
 160      =1  //
 161      =1  //  FIRSTSAVED_AIRCHN   BYTE    1 First saved Air TV channel no (maximum 100)
 162      =1  //  ....
 163      =1  //
 164      =1  //  CNT_SAVEDCABLE      BYTE  1   Total count of saved Cable TV Channel.
 165      =1  //  IDX_CURCABLE      BYTE  1   Index of Current Cable TV Channel
 166      =1  //  CHN_CURCABLE      BYTE    1   Current Cable TV Channel.
 167      =1  //
 168      =1  //  FIRSTSAVED_CABLECHN   BYTE  1 First saved Cable TV channel no (maximum 100)
 169      =1  //
 170      =1  //  --- PAL_TV --------------------------------------------------------------
 171      =1  //  PR_CUR          BYTE  1   Current PR no.
 172      =1  //  FIRST_SAVEDPR     DWORD 4   Freq of PR0.  (TOTAL_PR)
 173      =1  //  FIRST_SAVEDPR+4     DWORD   4   Freq of PR1.
 174      =1  //  .....
 175      =1  //
 176      =1  
 177      =1  
 178      =1  
 179      =1  //
 180      =1  // Offset of EEPROM
 181      =1  //
 182      =1  /*
 183      =1  #define VIDEOCONTRAST   0x18    // for NTSC.(PAL:0x20,SECAM:0x28)
 184      =1  #define VIDEOBRIGHTNESS   0x19
 185      =1  #define VIDEOSATURATION_U 0x1a
 186      =1  #define VIDEOSATURATION_V 0x1b
 187      =1  #define VIDEOHUE      0x1c    // only for NTSC
 188      =1  #define VIDEOSHARPNESS    0x1d
 189      =1  */
 190      =1  /*
 191      =1  #define CCCOLOR   0x52
 192      =1  #define VOLZOOM   0x53
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 35  

 193      =1  
 194      =1  #define PANELINFO 0x61
 195      =1  
 196      =1  // PAL_TV
 197      =1  #define  PR_CUR         0x301 
 198      =1  #define  FIRST_SAVEDPR      0x308 
 199      =1   #define TVFREQ_HIGH 0 
 200      =1   #define TVFREQ_LOW  1
 201      =1  #ifdef PAL_TV
 202      =1   #define TVFINETUNE  2
 203      =1      // NOT Finetune: 0 , Range: -32 ~ +32
 204      =1   #define TVPRSYSTEM  3  
 205      =1      // bit 7: Add:1 Ereased :0
 206      =1      // 
 207      =1   #define TVCHNAME    4
 208      =1  
 209      =1   #define BYTEPERCHANNEL 9 
 210      =1  #endif
 211      =1  // NTSC_TV
 212      =1  #define  EEP_TVInputSel     0x302
 213      =1  #define  CHN_CURAIR       0x303 
 214      =1  #define  FIRSTSAVED_AIRCHN    0x308 
 215      =1  #define  CHN_CURCABLE     0x403 
 216      =1  #define  FIRSTSAVED_CABLECHN  0x408 
 217      =1  #ifdef NTSC_TV
 218      =1   #define TVFINETUNE  0
 219      =1      // NOT Finetune: 0 , Range: -32 ~ +32
 220      =1   #define TVPRSYSTEM  1  
 221      =1      // bit 7: Add:1 Ereased :0
 222      =1      // 
 223      =1   #define BYTEPERCHANNEL 2
 224      =1  #endif
 225      =1  
 226      =1  */
 227      =1  
 228      =1  
 229      =1  WORD GetFWRevEE(void);
 230      =1  void SaveFWRevEE(WORD);
 231      =1  
 232      =1  BYTE GetDebugLevelEE(void);
 233      =1  void SaveDebugLevelEE(BYTE);
 234      =1  
 235      =1  #if 0//def WIDE_SCREEN
           =1 BYTE GetWideModeEE(void);
           =1 void SaveWideModeEE(BYTE dl);
           =1 #endif
 239      =1  
 240      =1  /*
 241      =1  //BYTE GetRange4CoarseEE(void);
 242      =1  //void SaveRange4CoarseEE(BYTE);
 243      =1  
 244      =1  BYTE GetPossibleAutoDetectStdEE(void);
 245      =1  void SetPossibleAutoDetectStdEE(void);
 246      =1  
 247      =1  //BYTE GetOSDXPositionEE(void);
 248      =1  //BYTE GetOSDYPositionEE(void);
 249      =1  BYTE GetClosedCaptionFlagEE(void);
 250      =1  
 251      =1  BYTE GetVideoDatafromEE(BYTE);
 252      =1  void SaveVideoDatatoEE(BYTE offset, BYTE ndata);
 253      =1  
 254      =1  //BYTE GetVideoBrightnessEE(void);
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 36  

 255      =1  //BYTE GetVideoSaturationEE(BYTE);
 256      =1  //BYTE GetVideoHueEE(void);
 257      =1  //BYTE GetVideoSharpnessEE(void);
 258      =1  
 259      =1  //void SaveVideoContrastEE(BYTE ndata);
 260      =1  //void SaveVideoBrightnessEE(BYTE ndata);
 261      =1  //void SaveVideoSaturationEE(BYTE, BYTE ndata);
 262      =1  //void SaveVideoHueEE(BYTE ndata);
 263      =1  //void SaveVideoSharpnessEE(BYTE ndata);
 264      =1  
 265      =1  BYTE GetOSDPositionModeEE(void);
 266      =1  void SaveOSDPositionModeEE(BYTE ndata);
 267      =1  //void SaveOSDXPositionEE(BYTE);
 268      =1  //void SaveOSDYPositionEE(BYTE);
 269      =1  
 270      =1  void SaveClosedCaptionFlagEE(BYTE);
 271      =1  
 272      =1  BYTE GetBlockedTVEE(void);      
 273      =1  void SaveBlockedTVEE(BYTE vi);    
 274      =1  BYTE GetBlockedTV_FLDSLEE( BYTE level ) ;
 275      =1  void SaveBlockedTV_FLDSLEE(BYTE level, BYTE vi) ;
 276      =1  
 277      =1  BYTE GetBlockedMovieEE(void);   
 278      =1  void SaveBlockedMovieEE(BYTE vi); 
 279      =1  #if 0
 280      =1  BYTE GetInputSelectionEE(void);
 281      =1  #endif
 282      =1  void SaveInputSelectionEE(BYTE val);
 283      =1  
 284      =1  //BYTE GetOSDDurationEE(void);
 285      =1  //void SaveOSDDurationEE(BYTE val);
 286      =1  
 287      =1  BYTE GetOSDLangEE(void);
 288      =1  void SaveOSDLangEE(BYTE val);
 289      =1  
 290      =1  //ljy100303...BYTE GetOSDZoomEE(void);
 291      =1  //ljy100303...void SaveOSDZoomEE(BYTE val);
 292      =1  
 293      =1  BYTE GetAudioVolEE(void);
 294      =1  void SetAudioVolEE( BYTE vol );
 295      =1  BYTE GetPCAudioVolEE(void);
 296      =1  void SetPCAudioVolEE( BYTE vol );
 297      =1  */
 298      =1  #if 0
           =1 BYTE GetAudioBalanceEE(void);
           =1 void SetAudioBalanceEE( BYTE vol );
           =1 BYTE GetAudioBassEE(void);
           =1 void SetAudioBassEE( BYTE vol );
           =1 BYTE GetAudioTrebleEE(void);
           =1 void SetAudioTrebleEE( BYTE vol );
           =1 #endif
 306      =1  //BYTE GetAudioEffectEE(void);
 307      =1  //void SetAudioEffectEE( BYTE vol );
 308      =1  
 309      =1  void ClearBasicEE(void);
 310      =1  /*
 311      =1  BYTE ValidPassword(DATA_P BYTE *numstr, BYTE index);
 312      =1  BYTE SetNewPassword(DATA_P BYTE *numstr, BYTE index);
 313      =1  */
 314      =1  //WORD GetPanelXRes(void);
 315      =1  //WORD GetPanelYRes(void);
 316      =1  /*
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 37  

 317      =1  BYTE GetPanelHsyncMinPulseWidth(void);
 318      =1  BYTE GetPanelVsyncMinPulseWidth(void);
 319      =1  WORD GetPanelHMinBackPorch(void);
 320      =1  BYTE GetPanelHsyncPolarity(void);
 321      =1  BYTE GetPanelVsyncPolarity(void);
 322      =1  WORD GetPanelDotClock(void);
 323      =1  WORD GetPanelMaxClock(void);
 324      =1  BYTE GetPanelPixsPerClock(void);
 325      =1  // Not used yet *************************  BYTE GetPanelDEonly(void);
 326      =1  
 327      =1  void AddTVChannelEE( BYTE tvtype, BYTE chn);
 328      =1  BYTE GetTVChannelEE( BYTE tvtype, BYTE inx);
 329      =1  void ResetTVChannelEE( BYTE tvtype );
 330      =1  BYTE GetTVChannelCntEE(BYTE tvtype);
 331      =1  BYTE GetTVChnIdxEE(BYTE tvtype);
 332      =1  BYTE GetCurTVChannelEE(BYTE tvtype);
 333      =1  void SetTVChnIdxEE(BYTE tvtype, BYTE newd);
 334      =1  void SetCurTVChannelEE(BYTE tvtype, BYTE newd);
 335      =1  BYTE InsertTVChannelEE(BYTE tvtype, BYTE newd);
 336      =1  BYTE RemoveTVChannelEE(BYTE tvtype, BYTE newd);
 337      =1  
 338      =1  void SetTVPrEE(void);
 339      =1  BYTE GetTVPrEE(void);
 340      =1  void SetTVFreqEE(BYTE, WORD);
 341      =1  WORD GetTVFreqEE(BYTE);
 342      =1  void SetFineTuneEE(BYTE, BYTE);
 343      =1  BYTE GetFineTuneEE(BYTE);
 344      =1  BYTE GetTVPrSystem(BYTE);
 345      =1  void SetTVPrSystem(BYTE, BYTE);
 346      =1  BYTE GetTVInputSelEE(void);
 347      =1  void SetTVInputSelEE(BYTE);
 348      =1  */
 349      =1  /*
 350      =1  #define GetVInputStdDetectModeEE()        ReadEEP(EEP_AUTODETECTTYTE)
 351      =1  #define SaveVInputStdDetectModeEE(A)      WriteEEP(EEP_AUTODETECTTYTE, A)
 352      =1  
 353      =1  #define GetAutoRecogntionEE()         ReadEEP(EEP_AUTORECOGNITION)
 354      =1  #define SaveAutoRecogntionEE(A)         WriteEEP(EEP_AUTORECOGNITION, A)
 355      =1  
 356      =1  #define SetVideoModeEE( ctid )          WriteEEP( EEP_VIDEOMODE, ctid )
 357      =1  #define GetVideoModeEE()            ReadEEP( EEP_VIDEOMODE )
 358      =1  
 359      =1  #define GetPanelContrastEE()          ReadEEP(0x10)
 360      =1  
 361      =1  #if defined( SUPPORT_PC ) || defined( SUPPORT_DTV )
 362      =1  //#define GetPanelHueEE()             ReadEEP(0x28)
 363      =1  //#define GetPanelSharpnessEE()         ReadEEP(0x29)
 364      =1  #define GetPanelBrightnessEE()          ReadEEP(0x11)
 365      =1  //#define GetPanelSaturationEE()          ReadEEP(0x2a)
 366      =1  
 367      =1  //#define SavePanelHueEE(A)           WriteEEP(0x28, A)
 368      =1  //#define SavePanelSharpnessEE(A)         WriteEEP(0x29, A)
 369      =1  #define SavePanelContrastEE(A)          WriteEEP(0x10, A)
 370      =1  #define SavePanelBrightnessEE(A)        WriteEEP(0x11, A)
 371      =1  //#define SavePanelSaturationEE(A)        WriteEEP(0x2a, A)
 372      =1  #endif
 373      =1  */
 374      =1  /*
 375      =1  #define GetDigitalVideoContrastEE()       ReadEEP(0x2b)
 376      =1  #define GetDigitalVideoBrightnessEE()     ReadEEP(0x2c)
 377      =1  #define GetDigitalVideoHueEE()          ReadEEP(0x2d)
 378      =1  #define GetDigitalVideoSaturationEE(off)    ReadEEP(0x2e+off)
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 38  

 379      =1  
 380      =1  #define SaveDigitalVideoContrastEE(A)     WriteEEP(0x2b, A)
 381      =1  #define SaveDigitalVideoBrightnessEE(A)     WriteEEP(0x2c, A)
 382      =1  #define SaveDigitalVideoHueEE(A)        WriteEEP(0x2d, A)
 383      =1  #define SaveDigitalVideoSaturationEE(off,A)   WriteEEP(0x2e+off, A)
 384      =1  */
 385      =1  
 386      =1  #endif  // __ETC_EEP__
  35          
  36          //********************************************************************
  37          //  LOCAL DEFINE
  38          //********************************************************************
  39          /*
  40          
  41          //#define DEBUG_HS_PROTOCOL
  42          #define ProtocolDebug
  43          #define LCDMode 4
  44          
  45          //********************************************************************
  46          //  GLOBAL VARIABLES
  47          //********************************************************************
  48          //#ifdef SUPPORT_SDCARD
  49          
  50          BYTE  year1,year2,month,day,hour,minute,second;
  51          BYTE  DVR_daylightsaving;
  52          BYTE  DVR_timebeginesmonth;
  53          BYTE  DVR_timebeginesweek;
  54          BYTE  DVR_timebeginesTime;
  55          BYTE  DVR_sandardtimebeginesMonth;
  56          BYTE  DVR_standardtimebeginesWeek;
  57          BYTE  DVR_standardtimebeginesTime;
  58          BYTE  DVR_Resolution      ;
  59          BYTE  DVR_FPS         ;
  60          BYTE  DVR_Quality       ;
  61          BYTE  DVR_RecordMode      ;
  62          BYTE  DVR_RecordLength    ;
  63          BYTE  DVR_PreAlarmLength    ;
  64          BYTE  DVR_PostAlarmLength   ;
  65          BYTE  DVR_TimeZone;
  66          BYTE  DVR_SDCardAvailable=255   ;
  67          BYTE  DVR_RecordStatus    ;
  68          BYTE  DVR_Busy        ;
  69          BYTE  DVR_OverWrite;
  70          BYTE  FormatStatus      ;
  71          bit FormatStart       ;
  72          BYTE  TriggerStatus     ;
  73          BYTE  DVR_System=0;
  74          
  75          bit   DVR_Ready       ;
  76          bit   GetDVRStatusflag    ;
  77          bit    DoorState;
  78          bit   POWER_LINK_FLAG=0;
  79          */
  80          
  81          bit protocol_escape_flag;
  82          BYTE protocol_state=0;
  83          BYTE protocol_type;
  84          BYTE protocol_len;
  85          BYTE protocol_param;
  86          BYTE protocol_chksum;
  87          BYTE protocol_data_count;
  88          BYTE protocol_data[PROTOCOL_DATA_LENGTH];
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 39  

  89          
  90          
  91          extern DATA  BYTE RS_out;
  92          extern BYTE WDT_Echo_Count;
  93          
  94          /*
  95          BYTE GPSState;
  96          //bit   GetDVRVersionOK=0   ;
  97          BYTE DVRVersion[1]=0;
  98          BYTE DVRVersionLen=17;
  99          //#endif    //#ifdef SUPPORT_SDCARD
 100          
 101          extern  bit PowerDownStart    ;
 102          extern  BYTE PowerDownWait    ;
 103          extern  bit AccPowerDown    ;
 104          extern  bit PowerDownStart    ;
 105          extern  BYTE PowerDownWait    ;
 106          extern  bit AccPowerDown    ;
 107          extern DATA BYTE RS_in,RS2_in;
 108          extern DATA  BYTE DVR_buf[DVR_BUF_MAX];
 109          extern BYTE Protect_Power_Flag,OSD_TYPE_FLAG,OSD_LANGUAGE,OSD_BRIGHTNESS_FLAG;
 110          //extern DATA BYTE RS_in;
 111          //extern DATA BYTE RS_buf2[BUF_MAX];
 112          BYTE Power_Saving_Flag=0;
 113          extern volatile BYTE OSD_TEMP_STAT;
 114          extern bit OSD_reset_flag;
 115          
 116          extern DATA  DWORD  tic_PWR_SAVING;
 117          extern volatile bit PWR_SAVING_ACT_FLAG;
 118          bit PWR_OFF_KEY_LOCK=0;
 119          BYTE gb_P_Com[2]; //Pelco P Command Buffer
 120          //BYTE gb_P_Com[7]; //Pelco D Command Buffer
 121          //BYTE GE_Com[9]; //GE Command Buffer
 122          BYTE gb_PTZ_Speed;
 123          bit SpeedDomeMode=0;
 124          BYTE PresetMode=0;
 125          BYTE PresetNumber=1;
 126          extern BYTE  CAMNumber;
 127          extern BYTE  PelcoChoiceFLAG;
 128          extern BYTE  Baud_rate;
 129          BYTE  UpdateOK=0;
 130          BYTE Information[1];
 131          */
 132            
 133          //BYTE Param_BAT[3],Param_Roll[4],Param_TEMP[2];
 134          extern float Encorder1,Encorder2,Encorder3,Encorder4;
 135          extern float TempAlarm1,TempAlarm2;
 136          extern float BattDetect1,BattDetect2,BattDetect3,BattDetect4;
 137          
 138          extern BYTE BATERY_STAT;
 139          
 140          extern BYTE ACmode;
 141          
 142          
 143          
 144          //BYTE WIFI_IP[4];
 145          //BYTE WIFI_MAC[6]; 
 146          //BYTE GET_WAY[4]; 
 147          /*
 148          BYTE InformationLen=14;
 149          WORD CommandBuffer;
 150          //********************************************************************
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 40  

 151          //  LOCAL VARIABLES
 152          //********************************************************************
 153          BYTE  SerialNumber,OSD_Ready_Flag=0; 
 154          extern BYTE Ready_Flag;
 155          
 156          
 157          extern BYTE FWUPDATE_FLAG;
 158          */
 159          //********************************************************************
 160          //  LOCAL FUNCTIONS
 161          //********************************************************************
 162          
 163          //void Hs_Send_DVR_Command(BYTE * DVR_Com, BYTE len );
 164          void DvrReceivePaser();
 165          
 166          
 167          
 168          #if 0
              //#ifdef SUPPORT_SDCARD
              void Hs_Protocol_Init(void)
              {
              
              SerialNumber=0;
              year1=0;
              year2=0;
              month=0;
              day=0;
              hour=0;
              minute=0;
              second=0;
              
              DVR_Resolution=0x01;
              DVR_FPS=0x01;
              DVR_Quality=0x01;
              DVR_RecordMode=0x01;
              DVR_RecordLength=0x01;
              DVR_PreAlarmLength=0x01;
              DVR_PostAlarmLength=0x01;
              DVR_TimeZone=0x01;  
              DVR_daylightsaving=0x01;        
              DVR_timebeginesmonth=0x01;    
              DVR_timebeginesweek=0x01;   
              DVR_timebeginesTime=0x01;   
              DVR_sandardtimebeginesMonth=0x01; 
              DVR_standardtimebeginesWeek=0x01; 
              DVR_standardtimebeginesTime=0x01;   
              DVR_SDCardAvailable=0;
              DVR_RecordStatus=0x01;
              DVR_Busy=0;
              DVR_Ready=0;
              FormatStatus=0;
              FormatStart=0;
              DVR_OverWrite=1;
              GPSState=0;
              }
              #endif
 207          /*
 208          void Hs_DvrTxCmdPaser(BYTE Cmd_Id )
 209          {
 210          //bit check;
 211          BYTE j;
 212          //BYTE  Check_GM8126;
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 41  

 213          BYTE DVR_Com[25]; //DVR Protocol Command Buffer
 214          for(j=0;j<30;j++)
 215              DVR_Com[j] = 0 ;
 216          
 217          DVR_Com[0] ='H';  //
 218          DVR_Com[1] ='S';  //  
 219          DVR_Com[2] = 0x01;    
 220          DVR_Com[3] = SerialNumber;
 221          
 222          
 223          switch(Cmd_Id)
 224            {
 225            case SetDVRParam:
 226              DVR_Com[4] = SetDVRParam;     //Command Data
 227              DVR_Com[5] = 8;         //Data len    
 228              DVR_Com[6] = DVR_Resolution;    //Data 1
 229              DVR_Com[7] = DVR_FPS;       //Data 2
 230              DVR_Com[8] = DVR_Quality;     //Data 3
 231              DVR_Com[9] = DVR_RecordMode;    //Data 4
 232              DVR_Com[10] = DVR_RecordLength;   //Data 5
 233              DVR_Com[11] = DVR_PreAlarmLength; //Data 6
 234              DVR_Com[12] = DVR_PostAlarmLength;  //Data 7
 235              DVR_Com[13] = DVR_OverWrite;  //Data 7
 236          
 237              CommandBuffer|=bSetDVRParam;
 238              #ifdef ProtocolDebug
 239              Printf("\r\n SetDVRParam",0);
 240              #endif
 241              break;
 242          
 243            case SetDVRDefault:
 244              DVR_Com[4] = SetDVRDefault;     //Command Data
 245              DVR_Com[5] = 0;         //Data len    
 246              CommandBuffer|=bSetDVRDefault;
 247              #ifdef ProtocolDebug
 248              Printf("\r\n SetDVRDefault",0);
 249              #endif
 250              break;  
 251              
 252            case SetDATETIME:
 253              DVR_Com[4] = SetDATETIME;     //Command Data
 254              DVR_Com[5] = 15;          //Data len    
 255              DVR_Com[6] = year1;   //Data 1
 256              DVR_Com[7] = year2;       //Data 2
 257              DVR_Com[8] = month;     //Data 3
 258              DVR_Com[9] = day;   //Data 4
 259              DVR_Com[10] = hour;   //Data 5
 260              DVR_Com[11] = minute; //Data 6
 261              DVR_Com[12] = second; //Data 7
 262              DVR_Com[13] = DVR_TimeZone;   //Data 8
 263              DVR_Com[14] = DVR_daylightsaving;       //Data 9
 264              DVR_Com[15] = DVR_timebeginesmonth;     //Data 10
 265              DVR_Com[16] = DVR_timebeginesweek;    //Data 11
 266              DVR_Com[17] = DVR_timebeginesTime;    //Data 12
 267              DVR_Com[18] = DVR_sandardtimebeginesMonth;  //Data 13
 268              DVR_Com[19] = DVR_standardtimebeginesWeek;  //Data 14
 269              DVR_Com[20] = DVR_standardtimebeginesTime;    //Data 15
 270              CommandBuffer|=bSetDATETIME;
 271              #ifdef ProtocolDebug
 272              Printf("\r\n SetDATETIME",0);
 273              #endif
 274              break;    
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 42  

 275          
 276            
 277            case GetDVRParam:
 278              DVR_Com[4] = GetDVRParam;     //Command Data
 279              DVR_Com[5] = 0;         //Data len    
 280              CommandBuffer|=bGetDVRParam;
 281              #ifdef ProtocolDebug
 282              Printf("\r\n GetDVRParam",0);
 283              #endif
 284              break;  
 285          
 286            case GetDVRStatus:
 287              DVR_Com[4] = GetDVRStatus;    //Command Data
 288              DVR_Com[5] = 1;         //Data len  
 289              DVR_Com[6] = 0;         //Param1
 290              CommandBuffer|=bGetDVRStatus;
 291              #ifdef ProtocolDebug
 292              Printf("\r\n GetDVRStatus",0);
 293              #endif
 294              break;  
 295          
 296            case GetDATETIME:
 297              DVR_Com[4] = GetDATETIME;   //Command Data
 298              DVR_Com[5] = 0;         //Data len  
 299              CommandBuffer|=bGetDATETIME;
 300              #ifdef ProtocolDebug
 301              Printf("\r\n GetDATETIME",0);
 302              #endif
 303              break;  
 304          
 305            case MANUALRECSTART:
 306              DVR_Com[4] = MANUALRECSTART;    //Command Data
 307              DVR_Com[5] = 0;         //Data len  
 308              #ifdef ProtocolDebug
 309              Printf("\r\n MANUALRECSTART",0);
 310              #endif
 311              break;  
 312          
 313            case MANUALRECSTOP:
 314              DVR_Com[4] = MANUALRECSTOP;   //Command Data
 315              DVR_Com[5] = 0;         //Data len  
 316              #ifdef ProtocolDebug
 317              Printf("\r\n MANUALRECSTOP",0);
 318              #endif
 319              break;  
 320          
 321            case SNAPSHOT:
 322              DVR_Com[4] = SNAPSHOT;    //Command Data
 323              DVR_Com[5] = 0;         //Data len  
 324              #ifdef ProtocolDebug
 325              Printf("\r\n SNAPSHOT",0);
 326              #endif
 327              break;
 328          
 329            case BOOKMARK:
 330              DVR_Com[4] = BOOKMARK;    //Command Data
 331              DVR_Com[5] = 0;         //Data len  
 332              CommandBuffer|=bBOOKMARK;
 333              #ifdef ProtocolDebug
 334              Printf("\r\n BOOKMARK",0);
 335              #endif
 336              break;
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 43  

 337          
 338            case SetSystem:
 339              DVR_Com[4] = SetSystem;   //Command Data
 340              DVR_Com[5] = 1;         //Data len  
 341              DVR_Com[6] = DVR_System;    
 342              CommandBuffer|=bSetSystem;
 343              #ifdef ProtocolDebug
 344              Printf("\r\n SetSystem",0);
 345              #endif
 346              break;
 347              
 348            case Halt_Start:
 349              DVR_Com[4] = Halt_Start;    //Command Data
 350              DVR_Com[5] = 0;         //Data len  
 351              CommandBuffer|=bHalt_Start;
 352              #ifdef ProtocolDebug
 353              Printf("\r\n Halt_Start",0);
 354              #endif
 355              break;  
 356          
 357            case SetFormatSD :
 358              DVR_Com[4] = SetFormatSD ;    //Command Data
 359              DVR_Com[5] = 0;         //Data len  
 360              //FormatStart=1;
 361              CommandBuffer|=bSetFormatSD;
 362              #ifdef ProtocolDebug
 363              Printf("\r\n SetFormatSD",0);
 364              #endif
 365              break;
 366          
 367            case SendAlarm :
 368              DVR_Com[4] = SendAlarm;   //Command Data
 369              DVR_Com[5] = 1;         //Data len  
 370              DVR_Com[6] = 0;         //Param1
 371              #ifdef ProtocolDebug
 372              Printf("\r\n SendAlarm",0);
 373              #endif
 374              break;  
 375              
 376            case GetDVRVersion :
 377              DVR_Com[4] = GetDVRVersion;   //Command Data
 378              DVR_Com[5] = 0;         //Data len  
 379              CommandBuffer|=bGetDVRVersion;
 380              #ifdef ProtocolDebug
 381              Printf("\r\n GetDVRVersionLCD",0);
 382              #endif
 383          
 384              break;  
 385              
 386            case FW_Update_Start:
 387              DVR_Com[4] = FW_Update_Start ;    //Command Data
 388              DVR_Com[5] = 0;         //Data len  
 389              CommandBuffer|=bFW_Update_Start;
 390              //FormatStart=1;
 391              #ifdef ProtocolDebug
 392              Printf("\r\n FW_Update_Start",0);
 393              #endif
 394              break;
 395          
 396            case Update_CONFIG:
 397              DVR_Com[4] = Update_CONFIG ;    //Command Data
 398              DVR_Com[5] = 0;         //Data len  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 44  

 399              CommandBuffer|=bUpdate_CONFIG;
 400              //FormatStart=1;
 401              #ifdef ProtocolDebug
 402              Printf("\r\n Update_CONFIG",0);
 403              #endif
 404              break;  
 405          
 406            case DoorClose:
 407              DVR_Com[4] = DoorClose;   //Command Data
 408              DVR_Com[5] = 0;         //Data len  
 409              CommandBuffer&=(!bDoorOpen);
 410              CommandBuffer|=bDoorClose;
 411              
 412              DoorState=0;
 413              #ifdef ProtocolDebug
 414              Printf("\r\n DoorClose",0);
 415              #endif
 416              break;    
 417          
 418            case DoorOpen:
 419              DVR_Com[4] = DoorOpen;    //Command Data
 420              DVR_Com[5] = 0;         //Data len  
 421              CommandBuffer&=(!bDoorClose);
 422              CommandBuffer|=bDoorOpen;
 423              DoorState=1;
 424              #ifdef ProtocolDebug
 425              Printf("\r\n DoorOpen",0);
 426              #endif
 427              break;  
 428              
 429          
 430            }
 431          #if 1
 432          //for(j=0;j<2;j++)
 433          //{
 434            RS2_in=0;
 435            Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
 436            //Wait_ms(200);
 437          
 438          //  Check_GM8126=DvrReceivePaser();
 439          //  if(Check_GM8126==TRUE)
 440          //    break;
 441          //}
 442          #endif
 443          #if 0
 444            if(Check_GM8126==FALSE)
 445              DisplayInformation(InfoSDCARDNotReady);
 446            else
 447              {
 448              ClearOSDInfo();
 449                ClearDataCnt(0,30*5);    
 450              }
 451          #endif
 452          }
 453          
 454          */
 455          /*
 456          void Hs_Send_DVR_Command(BYTE * DVR_Com, BYTE len )
 457          {
 458            BYTE ii,j;
 459          
 460            //Generate DVR Mode  Check Sum
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 45  

 461            DVR_Com[len+6] = DVR_Com[0];
 462          
 463            
 464            for(j=1;j<(len+6);j++)
 465              DVR_Com[len+6] = DVR_Com[len+6]^DVR_Com[j];
 466            //CheckSum = Byte1 XOR Byte2 XOR Byte3 XOR......
 467          
 468            
 469            //Change_RS485_TxRx(1,RS485_TX);
 470            //Start Send DVR Command
 471            for(ii=0;ii<(len+7);ii++)
 472            {
 473              RS2_tx(DVR_Com[ii]);  
 474            }
 475          
 476          
 477          
 478          #ifdef DEBUG_HS_PROTOCOL
 479          for(ii=0;ii<len+7;ii++)
 480          {
 481            Printf("\r\nSend DVR Command[%d] = 0x%02x",(WORD)ii,(WORD)DVR_Com[ii]); 
 482          }
 483          #endif
 484          
 485          }
 486          */
 487          //#define Debug_CMD
 488          #if 0
              BYTE DvrReceivePaser(void)
              {
                BYTE i,j,k,CheckSum,NoCheck=0;
              /*  BYTE DVR_Com[30]; //DVR Protocol Command Buffer*/
                BYTE param[4];
                //BYTE Information[14];
              
                //Wait_ms(200);   //william-v1410-20120524
              #if 0
                for(i=0;i<RS2_in;i++) 
                {  
                  Printf("\r\nDVR_buf[%d]=0x%02x",(WORD)i,(WORD)DVR_buf[i]);
                }
              #endif
                //DisplayNumber(DVRStatus_ADDR,year1,4);
                //Printf("\r\n RS2_in=%d ",RS2_in);
                
              
              
              #if 0
              for(i=0;i<RS_in;i++) 
              {  
                if(DVR_buf[i]==0x7E /*&& DVR_buf[(i+1)]=='S'*/)
                {
                  //Generate DVR Mode  Check Sum
                    break;
                  CheckSum=DVR_buf[i];
              
              
                  for(j=0;j<(DVR_buf[i+2]);j++)
                    CheckSum = CheckSum^DVR_buf[i+j];
              
                  if(!(CheckSum==(DVR_buf[i+DVR_buf[i+2]+3])))
                    return FALSE; 
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 46  

              
                Printf("\r\n DVR_CheckSum  OK",0);  
                  break;
                }
                else
                  {
                  Printf("\r\n DVR_CheckSum  False",0); 
                  return FALSE;
                  }
              }
              
              #else
              
              
                #ifdef USE_HI3521_UART2
                for(i=0;i<RS2_in;i++) 
                #else
              //  for(i=0;i<RS_in;i++) 
                #endif
                {  
              #if 1//test 
              for(i=0;i<RS_in;i++) 
                {  
              //    Printf("\r\nDVR_buf[%d]=0x%02x",(WORD)i,(WORD)DVR_buf[i]);
                  Printf("(");
                  Printf("%02x",(WORD)DVR_buf[i]);
                  Printf(")");
                }
              
              for(i=0;i<RS_in;i++) 
              {  
                
              
                if(DVR_buf[i]==0x7E /*&& DVR_buf[(i+1)]=='S'*/)
                {
                  //Generate DVR Mode  Check Sum
                  //  break;
              #if 0   
                  CheckSum=DVR_buf[i];
              
                  for(j=0;j<(DVR_buf[i+2]);j++)
                    CheckSum = CheckSum^DVR_buf[i+j];
              #else
                  CheckSum=0;
                  CheckSum=CheckSum^DVR_buf[i+0];
                  CheckSum=CheckSum^DVR_buf[i+1];
                  for(j=0;j<=(DVR_buf[i+2]);j++)
                    CheckSum = CheckSum^DVR_buf[i+j+2];
              
              #endif
                  if(!(CheckSum==(DVR_buf[i+DVR_buf[i+2]+3])))
                    {
                      for(j=0;j<29;j++)
                  DVR_buf[j] = 0 ;  
                  
                  RS_in=0;
                  Printf("\r\nError1(%02x)",(WORD)CheckSum);
                  
                    return FALSE; 
                    }
              
              //  Printf("\r\n DVR_CheckSum  OK",0);  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 47  

                Printf("\r\n(OK)",0); 
                  break;
                }
                else
                  {
              //    Printf("\r\n DVR_CheckSum  Error2(%02x)",(WORD)CheckSum); 
                  Printf("\r\nError2(%02x)",(WORD)CheckSum);  
              
                  for(j=0;j<29;j++)
                  DVR_buf[j] = 0 ;  
                  
                  RS_in=0;
                  return FALSE;
                  }
              }
              
              #else
                  //Printf("\r\n Enter DVR_buf[i]=0x%02x",(WORD)DVR_buf[i]);
                  if(DVR_buf[i]==0x7E /*&& DVR_buf[(i+1)]=='S'*/)
                  {
                    //Generate DVR Mode  Check Sum
                  #if 0
                      break;
                    CheckSum=DVR_buf[i];
              
              
                    for(j=0;j<(DVR_buf[i+2]);j++)
                      CheckSum = CheckSum^DVR_buf[i+j];
              
                    if(!(CheckSum==(DVR_buf[i+DVR_buf[i+2]+3])))
                      return FALSE; 
              
                  Printf("\r\n DVR_CheckSum  OK",0);  
                    break;
                  #endif
                  //check sum
                  CheckSum=0;
              
              CheckSum=0;
              CheckSum=CheckSum^DVR_buf[i+0];
              CheckSum=CheckSum^DVR_buf[i+1];
              for(j=0;j<=(DVR_buf[i+2]);j++)
                CheckSum = CheckSum^DVR_buf[i+j+2];
              
              if(CheckSum==0x7E)
              {
              NoCheck=1;
              }
              
              #endif
              #if 0
                  //for(k=0;k<1;k++)
                  //{
                if(NoCheck)
                {
                  Printf("\r\n DVR_CheckSum  OK1(%02x)",(WORD)CheckSum);  
                  Printf("\r\n(%02x,%02x,%02x,%02x,%02x)",(WORD)DVR_buf[i],(WORD)DVR_buf[i+1],(WORD)DVR_buf[i+2],(WORD)DVR
             -_buf[i+3],(WORD)DVR_buf[i+4]);  
                  NoCheck=0;
                  //break;
                }
                else if(!(CheckSum==(DVR_buf[i+DVR_buf[i+2]+3])))
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 48  

                {
                  Printf("\r\n DVR_CheckSum  OK2(%02x)",(WORD)CheckSum);  
                  Printf("\r\n(%02x,%02x,%02x,%02x,%02x)",(WORD)DVR_buf[i],(WORD)DVR_buf[i+1],(WORD)DVR_buf[i+2],(WORD)DVR
             -_buf[i+3],(WORD)DVR_buf[i+4]);  
                //  break;
                }
                else
                {
                //return FALSE;
                Printf("\r\n DVR_CheckSum  False(%02x)",(WORD)CheckSum);  
                Printf("\r\n(%02x,%02x,%02x,%02x,%02x)",(WORD)DVR_buf[i],(WORD)DVR_buf[i+1],(WORD)DVR_buf[i+2],(WORD)DVR_
             -buf[i+3],(WORD)DVR_buf[i+4]); 
                Wait_ms(3);
              
                }
              #endif
                  //}
                
                  //Printf("\r\nCAL_CheckSum=0x%02x",(WORD)CheckSum);
                  //Printf("\r\nSEND_CheckSum=0x%02x",DVR_buf[i+DVR_buf[i+2]+3]);
                
                    #if 1 
                    // Printf("\r\n Enter DVR_buf=0x7E",0);
                    //Printf("\r\n Enter DVR_buf[i+1]=0x%02x",(WORD)DVR_buf[i+1]);
                    switch(DVR_buf[i+1])
                    {
                     case MCU_PROTOCOL_CMD_SYS_READY_NOTICE:
                       Printf("\r\nMCU_PROTOCOL_CMD_SYS_READY_NOTICE");
                       //MCUTimerDelayXms(100);//delay 100ms
                    break;
                  case MCU_PROTOCOL_CMD_WATCH_DOG_CHK:
                    Printf("\r\nDVR ACK");    
                    break;
                      case CMD_TEMP:
                        #ifdef Debug_CMD 
                      Printf("\r\nCMD_TEMP",0);
                      Printf("\r\n DVR_buf[i+2]=%02x",(WORD)DVR_buf[i+2]);
                      Printf("\r\n DVR_buf[i+3]=%02x",(WORD)DVR_buf[i+3]);
                      Printf("\r\n DVR_buf[i+4]=%02x",(WORD)DVR_buf[i+4]);
                      #endif  
                      TempAlarm1=DVR_buf[i+3];
                      TempAlarm2=DVR_buf[i+4];
                      //Printf("\r\n TempAlarm1=%02x",(WORD)(TempAlarm1));
                      //Printf("\r\n TempAlarm2=%02x",(WORD)(TempAlarm2));
                      TempAlarm1=((TempAlarm1*255)/3.3)*0.1f;
                      TempAlarm2=((TempAlarm2*255)/3.3)*0.1f;
                      //TempAlarm1=TempAlarm1*100;
                      //TempAlarm2=TempAlarm2*100;
                      Printf("\r\n TempAlarm1=%02x",(WORD)(TempAlarm1));
                      Printf("\r\n TempAlarm2=%02x",(WORD)(TempAlarm2));
                      param[0]=DVR_buf[i+1];//DVR_buf[i+1];
                      protocol_send_cmd_with_param_num(0x09, (BYTE *)param, 1);
                      Wait_ms(100);
                      break;
                        
                      case CMD_BATERY:
                        #ifdef Debug_CMD 
                      Printf("\r\nCMD_BATERY",0);
                      Printf("\r\n DVR_buf[i+2]=%02x",(WORD)DVR_buf[i+2]);
                      Printf("\r\n DVR_buf[i+3]=%02x",(WORD)DVR_buf[i+3]);
                      Printf("\r\n DVR_buf[i+4]=%02x",(WORD)DVR_buf[i+4]);
                      Printf("\r\n DVR_buf[i+5]=%02x",(WORD)DVR_buf[i+5]);
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 49  

                      Printf("\r\n DVR_buf[i+6]=%02x",(WORD)DVR_buf[i+6]);
                      #endif
                                   if(ACmode)
                                    {
                              param[0]=0x05;
                        
                      protocol_send_cmd_with_param_num(0x8C, (BYTE *)param, 1);
              
                                    }
                         else
                          {
                              param[0]=0x00;
                        
                      protocol_send_cmd_with_param_num(0x8C, (BYTE *)param, 1);
              
                                    }
              
              
                      BattDetect1=DVR_buf[i+3];
                      BattDetect2=DVR_buf[i+4];
                      BattDetect3=DVR_buf[i+5];
                      BattDetect4=DVR_buf[i+6];
                      
                      BattDetect1=(((BattDetect1*0.1f)*255)*0.28)/3.3;
                      BattDetect2=(((BattDetect2*0.1f)*255)*0.28)/3.3;
                      BattDetect3=(((BattDetect3*0.1f)*255)*0.28)/3.3;
                      BattDetect4=(((BattDetect4*0.1f)*255)*0.28)/3.3;
                      #if 0
                      Printf("\r\n BattDetect1=%02x",(WORD)BattDetect1);
                      Printf("\r\n BattDetect2=%02x",(WORD)BattDetect2);
                      Printf("\r\n BattDetect3=%02x",(WORD)BattDetect3);
                      Printf("\r\n BattDetect4=%02x",(WORD)BattDetect4);
                      #endif
                      
                        param[0]=DVR_buf[i+1];
                        protocol_send_cmd_with_param_num(0x09, (BYTE *)param, 1);
                        Wait_ms(100);
                        break;
                        
                      case CMD_ROLLENC:
                          #ifdef Debug_CMD 
                          Printf("\r\nCMD_ROLLENC",0);
                        Printf("\r\n DVR_buf[i+2]=%02x",(WORD)DVR_buf[i+2]);
                        Printf("\r\n DVR_buf[i+3]=%02x",(WORD)DVR_buf[i+3]);
                        Printf("\r\n DVR_buf[i+4]=%02x",(WORD)DVR_buf[i+4]);
                        Printf("\r\n DVR_buf[i+5]=%02x",(WORD)DVR_buf[i+5]);
                        Printf("\r\n DVR_buf[i+6]=%02x",(WORD)DVR_buf[i+6]);
                        #endif          
                        Encorder1=DVR_buf[i+3];
                        Encorder2=DVR_buf[i+4];
                        Encorder3=DVR_buf[i+5];
                        Encorder4=DVR_buf[i+6];
                        param[0]=DVR_buf[i+1];
                        protocol_send_cmd_with_param_num(0x09, (BYTE *)param, 1);
                        Wait_ms(100);
                        break;  
                      case CMD_DVR_PING:
                            #ifdef Debug_CMD 
                          Printf("\r\nDVR_READY",0);
                        #if 1
                        Printf("\r\n CMD_DVR_PING DVR_buf[%d]=0x%02x",(WORD)i,(WORD)DVR_buf[i]);
                        Printf("\r\n CMD_DVR_PING DVR_buf[%d]=0x%02x",(WORD)i+1,(WORD)DVR_buf[i+1]);
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 50  

                        Printf("\r\n CMD_DVR_PING DVR_buf[%d]=0x%02x",(WORD)i+2,(WORD)DVR_buf[i+2]);
                        Printf("\r\n CMD_DVR_PING DVR_buf[%d]=0x%02x",(WORD)i+3,(WORD)DVR_buf[i+3]);
                        Printf("\r\n CMD_DVR_PING DVR_buf[%d]=0x%02x",(WORD)i+4,(WORD)DVR_buf[i+4]);
                        #endif
                        #endif
                        //SelectModeType=SOURCE_A; 
                        //SetNowMode();
              
                        if(DVR_buf[i+3]==0x00)//Eng
                        {
                        WriteEEP(EEP_OSD_LANGUAGE,0x00);
                        OSD_LANGUAGE=0;
                        }
                        else//JPN
                        {
                        WriteEEP(EEP_OSD_LANGUAGE,0x01);
                        OSD_LANGUAGE=1;
                        }
                        ChangeInput(CH_TW2835);
                        P1_7=1;
                        ClearGAUGEINFO();
                        OSD_Ready_Flag=1;
                        Ready_Flag=1;
                        
                        param[0]=0x00;//DVR_buf[i+1];
                        protocol_send_cmd_with_param_num(0x09, (BYTE *)param, 1);
                        Wait_ms(100);
                        if(OSD_reset_flag)
                        {
                         //param[0]=0x00; 
                         param[0]=DVR_RESET_OSD;        
                        protocol_send_cmd_with_param_num(0x02, (BYTE *)param, 1);
                        OSD_reset_flag=0;
                        }
                        //Printf("\r\n BATERY_STAT=%02x",(WORD)BATERY_STAT);
                        //param[0]=BATERY_STAT;
                        //protocol_send_cmd_with_param_num(0x8B, (BYTE *)param, 1);       
                        //param[0]=BATERY_STAT;
                        //protocol_send_cmd_with_param_num(0x8B, (BYTE *)param, 1);
                        break;
                      case CMD_OSDTYPE:
                          #ifdef Debug_CMD 
                          Printf("\r\nDVR_OSDTYPE",0);
                        #endif
                        //Printf("\r\nCMD_OSDTYPE DVR_buf[%d]=0x%02x",(WORD)i,(WORD)DVR_buf[i+3]);
                        if(DVR_buf[i+3]==0)//type1
                        {
                        WriteEEP(EEP_OSD_TYPE,0x00);
                        OSD_TYPE_FLAG=0;
                        }
                        else//Type 2
                        {
                        WriteEEP(EEP_OSD_TYPE,0x01);
                        OSD_TYPE_FLAG=1;
                        }
                        param[0]=DVR_buf[i+1];
                        protocol_send_cmd_with_param_num(0x09, (BYTE *)param, 1);
                        Wait_ms(100);
                        break;
                        
                      case CMD_KEY:
                          #ifdef Debug_CMD 
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 51  

                          Printf("\r\nDVR_CMD_KEY",0);
                        #endif
                        param[0]=DVR_buf[i+1];
                        protocol_send_cmd_with_param_num(0x09, (BYTE *)param, 1);
                        Wait_ms(100);
                        break;
                      case CMD_BRIGHTNESS:
                           #ifdef Debug_CMD 
                           Printf("\r\nDVR_CMD_BRIGHTNESS",0);  
                         #endif
                         //AdjustBacklight(0);
                         //Printf("\r\n CMD_BRIGHTNESS DVR_buf[%d]=0x%02x",(WORD)i+2,(WORD)DVR_buf[i+2]);
                         //Printf("\r\n CMD_BRIGHTNESS DVR_buf[%d]=0x%02x",(WORD)i+3,(WORD)DVR_buf[i+3]);
                        switch(DVR_buf[i+3])
                        {
                        case BRIGHTNESS_MIN:
                          WriteEEP(EEP_OSD_BRIGHTNESS,BRIGHTNESS_MIN);
                          AdjustBacklight(0x80);
                          //Printf("\r\nHELLO MIN",0);  
                          break;
                        case BRIGHTNESS_NORMAL:
                          WriteEEP(EEP_OSD_BRIGHTNESS,BRIGHTNESS_NORMAL);
                           //AdjustBacklight(0xBF);
                          // AdjustBacklight(0x93);
                           AdjustBacklight(0x97);
                           //AdjustBacklight(0xE8);
                          //Printf("\r\nHELLO NORMAL",0);  
                          break;
                        case BRIGHTNESS_MAX:
                          WriteEEP(EEP_OSD_BRIGHTNESS,BRIGHTNESS_MAX);
                           AdjustBacklight(0xFF);
                          //Printf("\r\nHELLO MAX",0);  
                          break;
                        }
                        param[0]=DVR_buf[i+1];
                        protocol_send_cmd_with_param_num(0x09, (BYTE *)param, 1);
                        Wait_ms(100);
                        break;
                      case CMD_GET_VERSION:
                        #ifdef Debug_CMD 
                        Printf("\r\nDVR_CMD_GET_VERSION",0);
                        #endif
                        param[0]=DVR_buf[i+1];
                        protocol_send_cmd_with_param_num(0x09, (BYTE *)param, 1);
                        Wait_ms(100);
                        break;
                      case CMD_REC_LED:
                          //Printf("\r\nDVR_CMD_REC_LED",0);          
                          #if 0//def Debug_CMD 
                        CheckSum=0;
                        CheckSum=CheckSum^DVR_buf[i+1];
                        for(j=0;j<=(DVR_buf[i+2]);j++)
                          CheckSum = CheckSum^DVR_buf[i+j+2];
                        
                        Printf("\r\nDVR_buf[%d]=0x%02x",(WORD)i,(WORD)DVR_buf[i]);
                        Printf("\r\nDVR_buf[%d]=0x%02x",(WORD)i+1,(WORD)DVR_buf[i+1]);
                        Printf("\r\nDVR_buf[%d]=0x%02x",(WORD)i+2,(WORD)DVR_buf[i+2]);
                          Printf("\r\nDVR_buf[%d]=0x%02x",(WORD)i+3,(WORD)DVR_buf[i+3]);
                          Printf("\r\nDVR_buf[%d]=0x%02x",(WORD)i+4,(WORD)DVR_buf[i+4]);
                          Printf("\r\nCAL_CheckSum=0x%02x",(WORD)CheckSum);
                        Printf("\r\nSEND_CheckSum=0x%02x",DVR_buf[i+DVR_buf[i+2]+3]);
                        #endif
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 52  

                        if(DVR_buf[i+3])
                          TL057I_RED_LED=0;
                        else
                          TL057I_RED_LED=1;
                        break;
                      case CMD_Protect_POWER:
                        //if(TEMP_STAT==TEMP_Alarm2 || BATERY_STAT==BATERY_10)
                        {
                        param[0]=DVR_POWER;
                        protocol_send_cmd_with_param_num(0x02, (BYTE *)param, 1);       
                          clrBacklight();
                        ////  TL057I_GREEN_LED=1;
              
              
                           FWUPDATE_FLAG = 1;
              
                          Protect_Power_Flag=0;
                        P1_7=0;
                        }
                        break;
              
                      case CMD_BATT_Lo:
                        //if(TEMP_STAT==TEMP_Alarm2 || BATERY_STAT==BATERY_10)
                        {
                        param[0]=DVR_POWER;
                        protocol_send_cmd_with_param_num(0x02, (BYTE *)param, 1);       
                          clrBacklight();
                          TL057I_GREEN_LED=1;
                          Protect_Power_Flag=0;
                        P1_7=0;
                        }
                        break;
              
                        
                      case CMD_POWER_ON:
                          {
                        P1_7=1;
                        SetBacklight();
                          TL057I_GREEN_LED=0;
                        }
                      break;
                        
                      case CMD_POWER_SEL:
                      //Printf("\r\n DVR_buf[i+2]=%02x",(WORD)DVR_buf[i+2]);
                      //Printf("\r\n DVR_buf[i+3]=%02x",(WORD)DVR_buf[i+3]);
                      //Printf("\r\n CMD_POWER_SEL DVR_buf[i+3]=%02x",(WORD)DVR_buf[i+3]);
                      #ifdef Debug_CMD 
                        Printf("\r\nCMD_POWER_SEL",0);
                      #endif
                      switch(DVR_buf[i+3])
                      {
                      case POWER_SEL_ON:
                        #if 1
                        //PowerFlag=1;
                        SetBacklight();
                        Power_Saving_Flag=0;
                        TL057I_GREEN_LED=0;
                        PWR_OFF_KEY_LOCK=0;
                        
                        ////_Anderson_add_20140225_xx for LED Flash
                        FWUPDATE_FLAG = 0;
              
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 53  

                        
                        #endif
                        break;
                      case POWER_SEL_OFF:
                        #if 1
                        //PowerFlag=0;
                        Power_Saving_Flag=0;
                        clrBacklight();
                        TL057I_GREEN_LED=1;
                        PWR_OFF_KEY_LOCK=1;
                        #endif
                        break;
                      case POWER_SEL_SAVING:
                        SetBacklight();
                        Power_Saving_Flag=1;
                        PWR_SAVING_ACT_FLAG=1;
                        tic_PWR_SAVING=100000;
                        //PWR_OFF_KEY_LOCK=1;
                        break;
                      }
                      param[0]=CMD_POWER_SEL;
                      protocol_send_cmd_with_param_num(0x09, (BYTE *)param, 1); 
                      Wait_ms(100);
                      break;
                    case CMD_POWER_LINK:
                      
                      #ifdef Debug_CMD 
                        Printf("\r\nCMD_POWER_LINK",0);
                      #endif
                      
                      Printf("\r\n CMD_POWER_LINK DVR_buf[%d]=0x%02x",(WORD)i+3,(WORD)DVR_buf[i+3]);
                      if(DVR_buf[i+3]==1)//off
                      {
                        POWER_LINK_FLAG=1;  
                         //Printf("\r\nCMD_POWER_LINK=1",0);
                      }
                      else
                      {
                        POWER_LINK_FLAG=0;//on
                         //Printf("\r\nCMD_POWER_LINK=0",0);
                      }
                      WriteEEP(EEP_OSD_PWR_LINK,POWER_LINK_FLAG);
                      param[0]=BATERY_STAT;
                      protocol_send_cmd_with_param_num(0x8B, (BYTE *)param, 1);
                      Wait_ms(10);
                      param[0]=CMD_POWER_LINK;
                      protocol_send_cmd_with_param_num(0x09, (BYTE *)param, 1);
                      Wait_ms(10);
                      
                      Printf("\r\n TEMP_STAT=0x%02x",OSD_TEMP_STAT);
                      param[0]=0x00;
                      protocol_send_cmd_with_param_num(0x8A, (BYTE *)param, 1);
                    
                      //param[0]=TEMP_STAT;
                      //protocol_send_cmd_with_param_num(0x8A, (BYTE *)param, 1);
                      //Wait_ms(100);
                      break;
                        
                      default:
                        {
                        //Printf("\r\nCMD_ERROR",0);
                        //Printf("\r\nDVR_buf[%d]=0x%02x",(WORD)i,(WORD)DVR_buf[i+1]);
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 54  

                        }
                      break;
                        
                  }
                   #endif
                  }
                //}
                #endif
              #if 0
              switch(DVR_buf[i+1])
              {
                case CMD_TEMP:
                  Printf("\r\nCMD_TEMP",0);
                  break;
                  
                case CMD_BATERY:
                  Printf("\r\nCMD_BATERY",0);
                  break;
                  
                case CMD_ROLLENC:
                  Printf("\r\nCMD_ROLLENC",0);
                  break;  
                case CMD_DVR_PING:
                    Printf("\r\nDVR_READY",0);
                    //ClearOSDInfo();
                  ClearGAUGEINFO();
                  break;
              
                default:
                  Printf("\r\nCMD_ERROR",0);
                  break;
                  
              }
              #endif
                //for(j=0;j<29;j++)
                //    DVR_buf[j] = 0xff;
              
                for(j=0;j<29;j++)
                    DVR_buf[j] = 0 ;  
                
                #ifdef USE_HI3521_UART2
                RS2_in=0;
                #else
                RS_in=0;
                #endif
              
                return TRUE;
              
              
              }
              #else 
1067          void DvrReceivePaser(void)
1068          {
1069   1      
1070   1      if ( RS_ready())
1071   1        {
1072   2          BYTE c= RS_rx();
1073   2          
1074   2          if (c == 0x7E)
1075   2          {     
1076   3            Printf("\r\n(GOT CMD)");
1077   3            protocol_escape_flag = 0;
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 55  

1078   3            protocol_state = PROTOCOL_STATE_TYPE;
1079   3            protocol_chksum = 0;
1080   3            return; 
1081   3          }
1082   2          
1083   2          if (c == 0x7D)
1084   2          {
1085   3            protocol_escape_flag = 1;
1086   3            return;
1087   3          }
1088   2          
1089   2          if (protocol_escape_flag)
1090   2          {
1091   3            protocol_escape_flag = 0;
1092   3            c |= 0x70;
1093   3          }
1094   2      
1095   2          if (protocol_state != PROTOCOL_STATE_CHECKSUM)
1096   2          {
1097   3            protocol_chksum ^= c;
1098   3          }
1099   2      
1100   2          switch (protocol_state)
1101   2          {
1102   3            case PROTOCOL_STATE_TYPE:
1103   3              protocol_type = c;
1104   3              switch (protocol_type)
1105   3              {
1106   4              case MCU_PROTOCOL_CMD_SYS_READY_NOTICE:
1107   4              case MCU_PROTOCOL_CMD_WATCH_DOG_KICK:
1108   4              case MCU_PROTOCOL_CMD_ENTRY_SLEEP:
1109   4              case MCU_PROTOCOL_CMD_DISTANCE_RESET:
1110   4              case MCU_PROTOCOL_CMD_ENCODER_SET:           
1111   4              case MCU_PROTOCOL_CMD_CAMERA_VOLTAGE:
1112   4              case MCU_PROTOCOL_CMD_STOP_REBOOT:
1113   4              case MCU_PROTOCOL_CMD_GET_MCU_FW:
1114   4              case MCU_PROTOCOL_CMD_DVR_REBOOT:
1115   4              case MCU_PROTOCOL_CMD_DVR_SHUTDOWN:
1116   4                    protocol_state = PROTOCOL_STATE_LENGTH;
1117   4                    break;
1118   4                default:
1119   4                   protocol_state = PROTOCOL_STATE_NONE;
1120   4                   break;
1121   4              }
1122   3              break;
1123   3            case PROTOCOL_STATE_LENGTH:
1124   3              protocol_len = c;
1125   3              switch (protocol_type)
1126   3              {
1127   4                case MCU_PROTOCOL_CMD_SYS_READY_NOTICE:
1128   4                case MCU_PROTOCOL_CMD_WATCH_DOG_KICK:
1129   4                case MCU_PROTOCOL_CMD_ENTRY_SLEEP:
1130   4                case MCU_PROTOCOL_CMD_DISTANCE_RESET:
1131   4                case MCU_PROTOCOL_CMD_ENCODER_SET:           
1132   4                case MCU_PROTOCOL_CMD_CAMERA_VOLTAGE:
1133   4                case MCU_PROTOCOL_CMD_STOP_REBOOT:
1134   4                case MCU_PROTOCOL_CMD_GET_MCU_FW:
1135   4                case MCU_PROTOCOL_CMD_DVR_REBOOT:
1136   4                case MCU_PROTOCOL_CMD_DVR_SHUTDOWN:
1137   4                  if (protocol_len == 0)
1138   4                  {
1139   5                    protocol_state = PROTOCOL_STATE_CHECKSUM;
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 56  

1140   5                  }
1141   4                  else
1142   4                  {   
1143   5                    protocol_data_count = 0;
1144   5                    protocol_state = PROTOCOL_STATE_DATA;
1145   5                    Printf("(1)");
1146   5                  }
1147   4                  break;            
1148   4                default:
1149   4                  protocol_state = PROTOCOL_STATE_NONE;
1150   4                  break;
1151   4              }
1152   3              break;
1153   3            case PROTOCOL_STATE_DATA:
1154   3              switch (protocol_type) {
1155   4                case MCU_PROTOCOL_CMD_SYS_READY_NOTICE:
1156   4                case MCU_PROTOCOL_CMD_WATCH_DOG_KICK:
1157   4                case MCU_PROTOCOL_CMD_ENTRY_SLEEP:
1158   4                case MCU_PROTOCOL_CMD_DISTANCE_RESET:
1159   4                case MCU_PROTOCOL_CMD_ENCODER_SET:           
1160   4                case MCU_PROTOCOL_CMD_CAMERA_VOLTAGE:
1161   4                case MCU_PROTOCOL_CMD_STOP_REBOOT:
1162   4                case MCU_PROTOCOL_CMD_GET_MCU_FW:
1163   4                case MCU_PROTOCOL_CMD_DVR_REBOOT:
1164   4                case MCU_PROTOCOL_CMD_DVR_SHUTDOWN:
1165   4                    protocol_data[protocol_data_count] = c;
1166   4                  protocol_data_count++;
1167   4                   if (protocol_data_count == protocol_len) {
1168   5                    protocol_state = PROTOCOL_STATE_CHECKSUM;
1169   5                       Printf("(2)");
1170   5                  }
1171   4                   
1172   4                   Printf("(3)");
1173   4                   break;
1174   4                default:
1175   4                  protocol_state = PROTOCOL_STATE_NONE;
1176   4                  break;
1177   4              }
1178   3              break;
1179   3            case PROTOCOL_STATE_CHECKSUM:
1180   3              if (protocol_chksum == c)
1181   3              {
1182   4      
1183   4              Printf("\r\n(Work CMD=%02x)",(WORD)protocol_type);
1184   4              
1185   4                switch (protocol_type)
1186   4                {
1187   5                case MCU_PROTOCOL_CMD_SYS_READY_NOTICE:           
1188   5                  Printf("\r\n(SYS READY)");
1189   5                  break;
1190   5                case MCU_PROTOCOL_CMD_WATCH_DOG_KICK:
1191   5                  WDT_Echo_Count=0;
1192   5                  Printf("(CLR WDT_Echo_Count)");
1193   5                  break;
1194   5                case MCU_PROTOCOL_CMD_ENTRY_SLEEP:  
1195   5                MCUTimerActiveTimerEvent(SEC(0.25),_USER_TIMER_EVENT_OSD_MCU_ENTRY_SLEEP_MODE);
1196   5                  break;
1197   5                case MCU_PROTOCOL_CMD_DISTANCE_RESET:
1198   5                  MCUTimerActiveTimerEvent(SEC(0.25),_USER_TIMER_EVENT_OSD_DISTANCE_RESET);
1199   5                  break;
1200   5                case MCU_PROTOCOL_CMD_ENCODER_SET:  
1201   5                  MCUTimerActiveTimerEvent(SEC(0.25),_USER_TIMER_EVENT_OSD_ENCODER_DEVIATION_SETTING);            
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 57  

1202   5                  break;
1203   5                case MCU_PROTOCOL_CMD_CAMERA_VOLTAGE:           
1204   5                  if(protocol_data[0])
1205   5                    MCUTimerActiveTimerEvent(SEC(0.25),_USER_TIMER_EVENT_OSD_CAMERA_VOLTAGE_INC);
1206   5                  else
1207   5                    MCUTimerActiveTimerEvent(SEC(0.25),_USER_TIMER_EVENT_OSD_CAMERA_VOLTAGE_DEC);
1208   5                  break;
1209   5                case MCU_PROTOCOL_CMD_STOP_REBOOT:          
1210   5                  break;
1211   5                case MCU_PROTOCOL_CMD_GET_MCU_FW:           
1212   5                  MCUTimerActiveTimerEvent(SEC(0.25),_USER_TIMER_EVENT_OSD_GET_MCU_VERSION);
1213   5                  break;
1214   5                case MCU_PROTOCOL_CMD_DVR_REBOOT:           
1215   5                  MCUTimerActiveTimerEvent(SEC(0.25),_USER_TIMER_EVENT_OSD_DVR_REBOOT);
1216   5                  break;
1217   5                case MCU_PROTOCOL_CMD_DVR_SHUTDOWN:
1218   5                  MCUTimerActiveTimerEvent(SEC(0.25),_USER_TIMER_EVENT_OSD_DVR_SHUTDOWN);
1219   5                  break;
1220   5                default:
1221   5                  break;
1222   5                }
1223   4                
1224   4              }
1225   3              else
1226   3                  {
1227   4                  Printf("(CS error)");
1228   4      
1229   4                  }
1230   3              protocol_state = PROTOCOL_STATE_NONE;
1231   3              break;
1232   3            default:
1233   3              break;
1234   3          }
1235   2        }
1236   1      
1237   1      
1238   1      
1239   1      #if 0
                BYTE i,j,CheckSum;
                BYTE DVR_Com[30]; //DVR Protocol Command Buffer
                //BYTE Information[14];
              
                //Wait_ms(200);   //william-v1410-20120524
              #if 1
                for(i=0;i<RS_in;i++) 
                {  
                  Printf("\r\nDVR_buf[%d]=0x%02x",(WORD)i,(WORD)DVR_buf[i]);
                }
              #endif
                //DisplayNumber(DVRStatus_ADDR,year1,4);
                for(i=0;i<DVR_BUF_MAX;i++) 
                {  
                  if(DVR_buf[i]=='H' /*&& DVR_buf[(i+1)]=='S'*/)
                  {
                   if( DVR_buf[i+1]=='S'  ) 
                    break;
                  }
                }
              
              
              #if 0 
              if(DVR_buf[(i+2)]==0x02)
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 58  

                {
                  if(!(DVR_buf[(i+3)]==SerialNumber))
                    return FALSE;
                }
              #endif
              
              
                
                //Generate DVR Mode  Check Sum
              
                CheckSum=DVR_buf[i];
              
                for(j=1;j<(DVR_buf[i+5]+6);j++)
                  CheckSum = CheckSum^DVR_buf[i+j];
              
                if(!(CheckSum==(DVR_buf[i+DVR_buf[i+5]+6])))
                  return FALSE; 
              
              switch(DVR_buf[i+4])
                {
                case SetDVRParam:
                  CommandBuffer&=(!bSetDVRParam);
                  #ifdef ProtocolDebug
                  Printf("\r\nR SetDVRParam",0);
                  #endif
                  break;
              
                case SetDVRDefault:
                  CommandBuffer&=(!bSetDVRDefault);
                  #ifdef ProtocolDebug
                  Printf("\r\nR SetDVRDefault",0);
                  #endif
                  break;  
                  
                case SetDATETIME:
                  CommandBuffer&=(!bSetDATETIME);
                  #ifdef ProtocolDebug
                  Printf("\r\nR SetDATETIME",0);  
                  #endif
                  break;    
              
                case Halt_Start:
                  CommandBuffer&=(!bHalt_Start);
                  #ifdef ProtocolDebug
                  Printf("\r\nR Halt_Start",0); 
                  #endif
                  break;    
              
                case FW_Update_Start:
                  CommandBuffer&=(!bFW_Update_Start);
                  #ifdef ProtocolDebug
                  Printf("\r\nR FW_Update_Start",0);  
                  #endif
                  break;    
              
                case SetFormatSD:
                  CommandBuffer&=(!bSetFormatSD);
                  #ifdef ProtocolDebug
                  Printf("\r\nR SetDATETIME",0);  
                  #endif
                  break;  
              
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 59  

                case SetSystem:
                  CommandBuffer&=(!bSetSystem);
                  #ifdef ProtocolDebug
                  Printf("\r\nR SetSystem",0);  
                  #endif
                  break;  
                
                case GetDVRParam:
                  DVR_Resolution=DVR_buf[i+6];                //Data 1
                  DVR_FPS=DVR_buf[i+7];                   //Data 2
                  DVR_Quality=DVR_buf[i+8];                 //Data 3
                  DVR_RecordMode=DVR_buf[i+9];                //Data 4
                  DVR_RecordLength=DVR_buf[i+10];               //Data 5
                  DVR_PreAlarmLength=DVR_buf[i+11];             //Data 6
                  DVR_PostAlarmLength=DVR_buf[i+12];              //Data 7
                  DVR_OverWrite=DVR_buf[i+13];              //Data 7
                  
                  CommandBuffer&=(!bGetDVRParam);
                  #ifdef ProtocolDebug
                  Printf("\r\nR GetDVRParam",0);  
                  #endif
                  break;  
              
              
                case GetDVRStatus:
                  year1=DVR_buf[i+6];               //Data 1
                  year2=DVR_buf[i+7];               //Data 2
                  month=DVR_buf[i+8];               //Data 3
                  day=DVR_buf[i+9];               //Data 4
                  hour=DVR_buf[i+10];               //Data 5
                  minute=DVR_buf[i+11];             //Data 6
                  second=DVR_buf[i+12];             //Data 7
                  DVR_RecordStatus=DVR_buf[i+13];         //Data 8
                  DVR_SDCardAvailable=DVR_buf[i+14];        //Data 9
                  DVR_Busy=DVR_buf[i+15];             //Data 10
                  CommandBuffer&=(!bGetDVRStatus);
                  #ifdef ProtocolDebug
                  Printf("\r\nR GetDVRStatus",0); 
                  #endif
                  break;  
              
                case GetDATETIME:
                  year1=DVR_buf[i+6];               //Data 1
                  year2=DVR_buf[i+7];               //Data 2
                  month=DVR_buf[i+8];               //Data 3
                  day=DVR_buf[i+9];               //Data 4
                  hour=DVR_buf[i+10];               //Data 5
                  minute=DVR_buf[i+11];             //Data 6
                  second=DVR_buf[i+12];             //Data 7
                  DVR_TimeZone=DVR_buf[i+13];           //Data 8
                  DVR_daylightsaving=DVR_buf[i+14];       //Data 9
                  DVR_timebeginesmonth=DVR_buf[i+15];       //Data 10
                  DVR_timebeginesweek=DVR_buf[i+16];        //Data 11
                  DVR_timebeginesTime=DVR_buf[i+17];        //Data 12
                  DVR_sandardtimebeginesMonth=DVR_buf[i+18];    //Data 13
                  DVR_standardtimebeginesWeek=DVR_buf[i+19];    //Data 14
                  DVR_standardtimebeginesTime=DVR_buf[i+20];    //Data 15         //Data len  
                  CommandBuffer&=(!bGetDATETIME);
                  #ifdef ProtocolDebug
                  Printf("\r\nR GetDATETIME",0);  
                  #endif
                  break;  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 60  

                  
                case SendDVRStatus:
                  year1=DVR_buf[i+6];               //Data 1
                  year2=DVR_buf[i+7];               //Data 2
                  month=DVR_buf[i+8];               //Data 3
                  day=DVR_buf[i+9];               //Data 4
                  hour=DVR_buf[i+10];               //Data 5
                  minute=DVR_buf[i+11];             //Data 6
                  second=DVR_buf[i+12];             //Data 7
                  DVR_RecordStatus=DVR_buf[i+13];           //Data 8
                  DVR_SDCardAvailable=DVR_buf[i+14];        //Data 9
                  DVR_Busy=DVR_buf[i+15];             //Data 10
              
                  for(j=0;j<30;j++)
                    DVR_Com[j] = 0 ;
                
                  DVR_Com[0] ='H';  //
                  DVR_Com[1] ='S';  //  
                  DVR_Com[2] = 0x02;    
                  DVR_Com[3] = DVR_buf[i+3];
                  DVR_Com[4] = SendDVRStatus;   //Command Data
                  DVR_Com[5] = 0;         //Data len    
                  Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
                  #ifdef ProtocolDebug
                  Printf("\r\nR SendDVRStatus",0);
                  Printf("\r\nR DVR_RecordStatus=%02x",(WORD)DVR_RecordStatus); 
                  #endif
                  break;  
              
                case SendDVRParam:
                  DVR_Resolution=DVR_buf[i+6];                //Data 1
                  DVR_FPS=DVR_buf[i+7];                   //Data 2
                  DVR_Quality=DVR_buf[i+8];                 //Data 3
                  DVR_RecordMode=DVR_buf[i+9];                //Data 4
                  DVR_RecordLength=DVR_buf[i+10];               //Data 5
                  DVR_PreAlarmLength=DVR_buf[i+11];             //Data 6
                  DVR_PostAlarmLength=DVR_buf[i+12];              //Data 7
                  DVR_OverWrite=DVR_buf[i+13];              //Data 7
                  
              
                  for(j=0;j<30;j++)
                    DVR_Com[j] = 0 ;
                
                  DVR_Com[0] ='H';  //
                  DVR_Com[1] ='S';  //  
                  DVR_Com[2] = 0x02;    
                  DVR_Com[3] = DVR_buf[i+3];
                  DVR_Com[4] = SendDVRParam;    //Command Data
                  DVR_Com[5] = 0;         //Data len    
                  Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
                  #ifdef ProtocolDebug
                  Printf("\r\nR SendDVRParam",0); 
                  #endif
                  break;  
              
                case SendDVRParamDT:
              
                  year1=DVR_buf[i+6];               //Data 1
                  year2=DVR_buf[i+7];               //Data 2
                  month=DVR_buf[i+8];               //Data 3
                  day=DVR_buf[i+9];               //Data 4
                  hour=DVR_buf[i+10];               //Data 5
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 61  

                  minute=DVR_buf[i+11];             //Data 6
                  second=DVR_buf[i+12];             //Data 7
                  DVR_TimeZone=DVR_buf[i+13];           //Data 8
                  DVR_daylightsaving=DVR_buf[i+14];       //Data 9
                  DVR_timebeginesmonth=DVR_buf[i+15];       //Data 10
                  DVR_timebeginesweek=DVR_buf[i+16];        //Data 11
                  DVR_timebeginesTime=DVR_buf[i+17];        //Data 12
                  DVR_sandardtimebeginesMonth=DVR_buf[i+18];    //Data 13
                  DVR_standardtimebeginesWeek=DVR_buf[i+19];    //Data 14
                  DVR_standardtimebeginesTime=DVR_buf[i+20];    //Data 15         //Data len    
              
                  for(j=0;j<30;j++)
                    DVR_Com[j] = 0 ;
                
                  DVR_Com[0] ='H';  //
                  DVR_Com[1] ='S';  //  
                  DVR_Com[2] = 0x02;    
                  DVR_Com[3] = DVR_buf[i+3];
                  DVR_Com[4] = SendDVRParamDT;    //Command Data
                  DVR_Com[5] = 0;         //Data len    
                  Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
                  #ifdef ProtocolDebug
                  Printf("\r\nR SendDVRParamDT",0);   
                  #endif
                  break;  
                  
                case GetLCDMode:  
                  for(j=0;j<30;j++)
                    DVR_Com[j] = 0 ;
                
                  DVR_Com[0] ='H';  //
                  DVR_Com[1] ='S';  //  
                  DVR_Com[2] = 0x02;    
                  DVR_Com[3] = DVR_buf[i+3];
                  DVR_Com[4] = GetLCDMode;    //Command Data
                  DVR_Com[5] = 0x01;          //Data len    
                  DVR_Com[6] = LCDMode;         //Data 1
                  Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
                  #ifdef ProtocolDebug
                  Printf("\r\nR GetLCDMode",0);
                  #endif
                  break;  
              
                case MANUALRECSTART:      
                  break;  
              
                case MANUALRECSTOP:     
                  break;  
              
                case SNAPSHOT:        
                  break;
              
                case Halt_OK:
                  for(j=0;j<30;j++)
                  DVR_Com[j] = 0 ;
              
                  
                  
                  if(ACC_B==1)
                    { 
                  #ifdef BJTSwitch  
                    PPWR=0;
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 62  

                  #else
                    PPWR=1;
                  #endif
                    }
                  else
                    {
                    DVR_Com[0] ='H';  //
                    DVR_Com[1] ='S';  //  
                    DVR_Com[2] = 0x02;    
                    DVR_Com[3] = DVR_buf[i+3];
                    DVR_Com[4] = Halt_OK;   //Command Data
                    DVR_Com[5] = 1;         //Data len    
                    DVR_Com[6] = 0;         //Data 1
                    Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
                    PowerDownStart=0;
                    PowerDownWait=0;
                    AccPowerDown=1;
                    }
                  #ifdef ProtocolDebug
                  Printf("\r\nR Halt_OK",0);
                  #endif
                  
                  break;  
              
              
                  
                case SetFormatSDDone:
              
                  for(j=0;j<30;j++)
                  DVR_Com[j] = 0 ;
                  
                  DVR_Com[0] ='H';  //
                  DVR_Com[1] ='S';  //  
                  DVR_Com[2] = 0x02;    
                  DVR_Com[3] = DVR_buf[i+3];
                  DVR_Com[4] = SetFormatSDDone;   //Command Data
                  DVR_Com[5] = 0;         //Data len    
                  Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
                  FormatStatus=1;
                  UpdateOK=1;
                  CommandBuffer&=(!bSetFormatSD);
                  #ifdef ProtocolDebug
                  Printf("\r\nR SetFormatSDDone",0);
                  #endif
                  break;
              
                case FW_Update_OK:
              
                  //FormatStatus=DVR_buf[i+6];              //Data 1
              
                  UpdateOK=DVR_buf[i+6];
              
                  for(j=0;j<30;j++)
                  DVR_Com[j] = 0 ;
                  
                  DVR_Com[0] ='H';  //
                  DVR_Com[1] ='S';  //  
                  DVR_Com[2] = 0x02;    
                  DVR_Com[3] = DVR_buf[i+3];
                  DVR_Com[4] = FW_Update_OK;    //Command Data
                  DVR_Com[5] = 0;         //Data len    
                  Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 63  

                  FormatStatus=1;
                  CommandBuffer&=(!bFW_Update_Start);
                  #ifdef ProtocolDebug
                  Printf("\r\nR FW_Update_OK",0); 
                  #endif
                  break;
              
              
                case GetDVRVersion:
                  
                  DVRVersionLen = DVR_buf[i+5];
                  for(j=0;j<=DVRVersionLen;j++)
                  {
                    DVRVersion[j]=DVR_buf[i+6+j];               //Data 1  
                  } 
                  //GetDVRVersionOK=1;
                  DisplayFWVersion();
                  CommandBuffer&=(!bGetDVRVersion);
                  #ifdef ProtocolDebug
                  Printf("\r\nR GetDVRVersionDVR",0); 
                  #endif
                  break;    
              
                case GetInformation:
                    
                  InformationLen= DVR_buf[i+5];
                  for(j=0;j<InformationLen;j++)
                  {
                    Information[j]=DVR_buf[i+6+j];                //Data 1  
                  } 
              
                  DVR_Com[0] ='H';  //
                  DVR_Com[1] ='S';  //  
                  DVR_Com[2] = 0x02;    
                  DVR_Com[3] = DVR_buf[i+3];
                  DVR_Com[4] = GetInformation;    //Command Data
                  DVR_Com[5] = 0;         //Data len    
                  Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
              
                  //for(i=0;i<InformationLen;i++) 
                  //{  
                  //Printf("\r\nInformation[%d]=0x%02x",(WORD)i,(WORD)Information[i]);
                  //}
                  #ifdef ProtocolDebug
                  Printf("\r\nR GetInformation",0);
                  #endif
                  break;
                 
                case Update_CONFIG_OK:
              
                  for(j=0;j<30;j++)
                  DVR_Com[j] = 0 ;
                  
                  DVR_Com[0] ='H';  //
                  DVR_Com[1] ='S';  //  
                  DVR_Com[2] = 0x02;    
                  DVR_Com[3] = DVR_buf[i+3];
                  DVR_Com[4] = Update_CONFIG_OK;    //Command Data
                  DVR_Com[5] = 0;         //Data len    
                  Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
                  FormatStatus= 1;
                  UpdateOK=DVR_buf[i+6];
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 64  

              
                  CommandBuffer&=(!bUpdate_CONFIG);
                  #ifdef ProtocolDebug
                  Printf("\r\nR Update_CONFIG_OK",0);
                  #endif
                  break;
              
              #if 0
                case GPSReset:
              
                  GPSState=DVR_buf[i+6];                //Data 1
              
                  for(j=0;j<30;j++)
                  DVR_Com[j] = 0 ;
                  
                  DVR_Com[0] ='H';  //
                  DVR_Com[1] ='S';  //  
                  DVR_Com[2] = 0x02;    
                  DVR_Com[3] = DVR_buf[i+3];
                  DVR_Com[4] = GPSReset;    //Command Data
                  DVR_Com[5] = 0;         //Data len    
                  Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
              
              
                if(GPSState==1)
                  {
                  GPS_PWR=0;
                  Wait_ms(1000);
                  GPS_PWR=1;
                  }
                  #ifdef ProtocolDebug
                  Printf("\r\nR GPSReset",0);
                  #endif
                  break;
              #endif
              
                case BOOKMARK:
                  CommandBuffer&=(!bBOOKMARK);
                  #ifdef ProtocolDebug
                  Printf("\r\n RBOOKMARK",0);
                  #endif
                  break;
              
                case DoorClose:             
                  DoorState=0;
                  CommandBuffer&=(!bDoorClose);
                  #ifdef ProtocolDebug
                  Printf("\r\nR DoorClose",0);
                  #endif
                  break;    
              
                case DoorOpen:      
                  DoorState=1;
                  CommandBuffer&=(!bDoorOpen);
                  #ifdef ProtocolDebug
                  Printf("\r\nR DoorOpen",0);
                  #endif
                  break;  
                
                  
                }
              
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 65  

              
              
                for(j=0;j<29;j++)
                    DVR_buf[j] = 0 ;
              
                
                SerialNumber++;
                
                RS2_in=0;
              #if 1
              if(DVR_Ready==0)
                {
                  DVR_Ready=1;
                  GetDVRStatusflag=1;
                }
              #endif
              #endif
1715   1      
1716   1        //return TRUE;
1717   1      
1718   1      return;
1719   1      }
1720          #endif
1721          #if 0
              void DVRCommandReSend(void)
              {
              
              if(CommandBuffer&bSetDVRParam)
                Hs_DvrTxCmdPaser(SetDVRParam);
              
              if(CommandBuffer&bSetDVRDefault)
                Hs_DvrTxCmdPaser(SetDVRDefault);
              
              if(CommandBuffer&bGetDVRParam)
                Hs_DvrTxCmdPaser(GetDVRParam);
              
              if(CommandBuffer&bGetDATETIME)
                Hs_DvrTxCmdPaser(GetDATETIME);
              
              if(CommandBuffer&bGetDATETIME)
                Hs_DvrTxCmdPaser(GetDATETIME);
              
              if(CommandBuffer&bHalt_Start)
                Hs_DvrTxCmdPaser(Halt_Start);
              
              if(CommandBuffer&bSetFormatSD)
                Hs_DvrTxCmdPaser(SetFormatSD);
              
              if(CommandBuffer&bGetDVRVersion)
                Hs_DvrTxCmdPaser(GetDVRVersion);
              
              if(CommandBuffer&bFW_Update_Start)
                Hs_DvrTxCmdPaser(FW_Update_Start);
              
              if(CommandBuffer&bDoorClose)
                Hs_DvrTxCmdPaser(DoorClose);
              
              if(CommandBuffer&bDoorOpen)
                Hs_DvrTxCmdPaser(DoorOpen);
              
              if(CommandBuffer&bUpdate_CONFIG)
                Hs_DvrTxCmdPaser(Update_CONFIG);
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 66  

              
              
              
              }
              #endif
1765          #if 0
              BYTE TW2835ReceivePaser(void)
              {
              
              BYTE i,j;
              
                Wait_ms(100);
              #if 1
                for(i=0;i<RS_in;i++) 
                {  
                  Printf("\r\nRS_buf2[%d]=0x%02x",(WORD)i,(WORD)RS_buf2[i]);
                }
              #endif
              
                for(i=0;i<BUF_MAX;i++) 
                  {  
                    if(RS_buf2[i]=='N' /*&& DVR_buf[(i+1)]=='S'*/)
                    {
                     if( RS_buf2[i+1]=='T'  ) 
                      {
                       if( RS_buf2[i+2]=='S'  )
                        {
                         if( RS_buf2[i+3]=='C'  ) 
                          {
                          return NTSC;
                          break;
                          }
                        }
                      }
                    }
              
                  if(RS_buf2[i]=='P' /*&& DVR_buf[(i+1)]=='S'*/)
                    {
                     if( RS_buf2[i+1]=='A'  ) 
                      {
                       if( RS_buf2[i+2]=='L'  )
                        {
                         return PAL;
                         break;
                        }
                      }
                    }
                  }
              
                return 0;
              
              
              }
              #endif
1814          //#endif  //#ifdef SUPPORT_SDCARD
1815          
1816          
1817          /////////////////////////////////////////////////////////////////////////
1818          //
1819          //  Camera Mode Send Command to RS485 Poart A 
1820          //  Note: Com_ID: Camera Command ID Number 
1821          //      Dev_ID: Camera Device ID Number 1~256 
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 67  

1822          //      *Device ID Show with Input 1~256 Send Command then 0~255
1823          //      Protocol : 0:Pelco-P   1:Pelco-D
1824          /////////////////////////////////////////////////////////////////////////
1825          #if 0
              void CAM_TxCommand_toRS485(BYTE Com_ID)
              {
                BYTE j;
                //Printf("\r\nPelcoChoiceFLAG=%02x",(WORD)PelcoChoiceFLAG);
                //Printf("\r\nCAMNumber=%02x",(WORD)CAMNumber);
                //Printf("\r\nCom_ID=%02x",(WORD)Com_ID);
                //Select Speed Dome Protocol
                switch(PelcoChoiceFLAG)
                {
                  case 0: //Pelco P
                    //Clear Pelco P Command Buffer
                    for(j=0;j<8;j++)
                      gb_P_Com[j] = 0 ;
                    gb_P_Com[0] = 0xA0;   //STX-Start Transmission
                    //Check Input Source with Camera Address
                      gb_P_Com[1] = CAMNumber-1;  // 0~255
                    gb_P_Com[6] = 0xAF;   //ETX End Transmission
                    //Select Command ID
                    switch(Com_ID)
                    {
                    #if 0
                      case CAM_CLEAR:
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x05; //Data 2
                        gb_P_Com[4] = 0;  //Data 3
                        if(gb_Show_Number_Nor_HL_Status == 0)
                          gb_P_Com[5] = UserPrefNumberID; //Data 4
                        else
                          gb_P_Com[5] = 0xFF;
                        Send_PelcoP_Command();
                        break;
                    #endif      
                      case CAM_ZOOM_OUT_START:
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x40; //Data 2
                        gb_P_Com[4] = 0;  //Data 3
                        gb_P_Com[5] = 0;  //Data 4
                        Send_PelcoP_Command();
                        break;
                        
                    //  case CAM_ZOOM_OUT_END:
                    //  case CAM_ZOOM_IN_END:
                    //  case CAM_IRIS_CLOSE_END:
                    //  case CAM_IRIS_OPEN_END:
                    //  case CAM_FOCUS_FAR_END:
                    //  case CAM_FOCUS_NEAR_END:
                      case CAM_PTZ_STOP:
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0;  //Data 2
                        gb_P_Com[4] = 0;  //Data 3
                        gb_P_Com[5] = 0;  //Data 4
                        Send_PelcoP_Command();
                        break;
                      
                      case CAM_ZOOM_IN_START:
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x20; //Data 2
                        gb_P_Com[4] = 0;  //Data 3
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 68  

                        gb_P_Com[5] = 0;  //Data 4
                        Send_PelcoP_Command();
                        break;
                    #if 0     
                      case CAM_IRIS_CLOSE_START:
                        gb_P_Com[2] = 0x08; //Data 1
                        gb_P_Com[3] = 0;  //Data 2
                        gb_P_Com[4] = 0;  //Data 3
                        gb_P_Com[5] = 0;  //Data 4
                        Send_PelcoP_Command();
                        break;
                      case CAM_IRIS_OPEN_START:
                        gb_P_Com[2] = 0x04; //Data 1
                        gb_P_Com[3] = 0;  //Data 2
                        gb_P_Com[4] = 0;  //Data 3
                        gb_P_Com[5] = 0;  //Data 4
                        Send_PelcoP_Command();
                        break;
                      case CAM_FOCUS_FAR_START:
                        gb_P_Com[2] = 0x01; //Data 1
                        gb_P_Com[3] = 0;  //Data 2
                        gb_P_Com[4] = 0;  //Data 3
                        gb_P_Com[5] = 0;  //Data 4
                        Send_PelcoP_Command();
                        break;
                      case CAM_FOCUS_NEAR_START:
                        gb_P_Com[2] = 0x02; //Data 1
                        gb_P_Com[3] = 0;  //Data 2
                        gb_P_Com[4] = 0;  //Data 3
                        gb_P_Com[5] = 0;  //Data 4
                        Send_PelcoP_Command();
                        break;
              
                      case CAM_FOCUS_SPEED:
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x27; //Data 2
                        gb_P_Com[4] = 0;  //Data 3
                        if(gb_Show_Number_Nor_HL_Status == 0)
                          gb_P_Com[5] = UserPrefNumberID - 1; //Data 4
                        else
                          gb_P_Com[5] = 0xFF;
                        //Check Max Value
                        if(gb_P_Com[5] >= 0x03)
                          gb_P_Com[5] = 0x03;
                        Send_PelcoP_Command();
                        break;
                      case CAM_ZOOM_SPEED:
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x25; //Data 2
                        gb_P_Com[4] = 0;  //Data 3
                        if(gb_Show_Number_Nor_HL_Status == 0)
                          gb_P_Com[5] = UserPrefNumberID - 1; //Data 4
                        else
                          gb_P_Com[5] = 0xFF;
                        //Check Max Value
                        if(gb_P_Com[5] >= 0x03)
                          gb_P_Com[5] = 0x03;
                        Send_PelcoP_Command();
                        break;
                      #endif  
                      case CAM_SET:
                        gb_P_Com[2] = 0;  //Data 1
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 69  

                        gb_P_Com[3] = 0x03; //Data 2
                        gb_P_Com[4] = 0;  //Data 3
                        //if(gb_Show_Number_Nor_HL_Status == 0)
                        //  gb_P_Com[5] = UserPrefNumberID; //Data 4
                        //else
                          gb_P_Com[5] = PresetNumber;
                        Send_PelcoP_Command();
                        break;
                      case CAM_CALL:
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x07; //Data 2
                        gb_P_Com[4] = 0;  //Data 3
                        //if(gb_Show_Number_Nor_HL_Status == 0)
                        //  gb_P_Com[5] = UserPrefNumberID; //Data 4
                        //else
                          gb_P_Com[5] = PresetNumber;
                        Send_PelcoP_Command();
                        break;
                      case CAM_PTZ_RIGHT: 
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x02; //Data 2
                        if(SpeedDomeMode==1)
                          gb_P_Com[4] = 0xff; //Data 3  
                        else
                          gb_P_Com[4] = gb_PTZ_Speed; //Data 3
                        gb_P_Com[5] = 0;  //Data 4
                        Send_PelcoP_Command();
                        break;
                      case CAM_PTZ_LEFT:  
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x04; //Data 2
                        if(SpeedDomeMode==1)
                          gb_P_Com[4] = 0xff; //Data 3  
                        else
                          gb_P_Com[4] = gb_PTZ_Speed; //Data 3
                        gb_P_Com[5] = 0;  //Data 4
                        Send_PelcoP_Command();
                        break;
                      case CAM_PTZ_UP:  
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x08; //Data 2    
                        gb_P_Com[4] = 0;  //Data 3
                        if(SpeedDomeMode==1)
                          gb_P_Com[5] = 0xff; //Data 3  
                        else  
                          gb_P_Com[5] = gb_PTZ_Speed; //Data 4
                        Send_PelcoP_Command();
                        break;
                      case CAM_PTZ_DOWN:  
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x10; //Data 2          
                        gb_P_Com[4] = 0;  //Data 3
                        if(SpeedDomeMode==1)
                          gb_P_Com[5] = 0xff; //Data 3  
                        else  
                          gb_P_Com[5] = gb_PTZ_Speed; //Data 4
                        Send_PelcoP_Command();
                        break;
                      case CAM_MENU_ENTER:  
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x03; //Data 2
                        gb_P_Com[4] = 0;  //Data 3
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 70  

                        gb_P_Com[5] = 0x5F; //Data 4
                        Send_PelcoP_Command();
                        break;  
                      case CAM_Iris_Open: 
                        gb_P_Com[2] = 0x04; //Data 1
                        gb_P_Com[3] = 0; //Data 2
                        gb_P_Com[4] = 0;  //Data 3
                        gb_P_Com[5] = 0;  //Data 4
                        Send_PelcoP_Command();
                        break;  
                      #if 0 
                      case CAM_PTZ_RIGHT_UP:  
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x0A; //Data 2
                        gb_P_Com[4] = gb_PTZ_Right_Speed; //Data 3
                        gb_P_Com[5] = gb_PTZ_Up_Speed;  //Data 4
                        Send_PelcoP_Command();
                        break;
                      case CAM_PTZ_RIGHT_DOWN:  
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x12; //Data 2
                        gb_P_Com[4] = gb_PTZ_Right_Speed; //Data 3
                        gb_P_Com[5] = gb_PTZ_Down_Speed;  //Data 4
                        Send_PelcoP_Command();
                        break;
                      case CAM_PTZ_LEFT_UP: 
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x0C; //Data 2
                        gb_P_Com[4] = gb_PTZ_Left_Speed;  //Data 3
                        gb_P_Com[5] = gb_PTZ_Up_Speed;  //Data 4
                        Send_PelcoP_Command();
                        break;
                      case CAM_PTZ_LEFT_DOWN: 
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x14; //Data 2
                        gb_P_Com[4] = gb_PTZ_Left_Speed;  //Data 3
                        gb_P_Com[5] = gb_PTZ_Down_Speed;  //Data 4
                        Send_PelcoP_Command();
                        break;
                      #endif  
                    }
                    break;
                  case 1: //Pelco D
                    //Clear Pelco D Command Buffer
                    for(j=0;j<7;j++)
                      gb_P_Com[j] = 0 ;
                    gb_P_Com[0] = 0xFF;   //Synchronization Byte
                    //Check Input Source with Camera Address
                      gb_P_Com[1] = CAMNumber; // 1~256
                    //Select Command ID
                    switch(Com_ID)
                    {
                    #if 0
                      case CAM_CLEAR:
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x05; //Command 2
                        gb_P_Com[4] = 0;  //Data 1
                        if(gb_Show_Number_Nor_HL_Status == 0)
                          gb_P_Com[5] = UserPrefNumberID; //Data 2
                        else
                          gb_P_Com[5] = 0xFF;
                        Send_PelcoD_Command();
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 71  

                        break;
                    #endif      
                      case CAM_ZOOM_OUT_START:
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x40; //Command 2
                        gb_P_Com[4] = 0;  //Data 1
                        gb_P_Com[5] = 0;  //Data 2
                        Send_PelcoD_Command();
                        break;
                      
                    //  case CAM_ZOOM_OUT_END:
                    //  case CAM_ZOOM_IN_END:
                    //  case CAM_IRIS_CLOSE_END:
                    //  case CAM_IRIS_OPEN_END:
                    //  case CAM_FOCUS_FAR_END:
                    //  case CAM_FOCUS_NEAR_END:
                      case CAM_PTZ_STOP:
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0;  //Command 2
                        gb_P_Com[4] = 0;  //Data 1
                        gb_P_Com[5] = 0;  //Data 2
                        Send_PelcoD_Command();
                        break;
                      
                      case CAM_ZOOM_IN_START:
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x20; //Command 2
                        gb_P_Com[4] = 0;  //Data 1
                        gb_P_Com[5] = 0;  //Data 2
                        Send_PelcoD_Command();
                        break;
                    #if 0   
                      case CAM_IRIS_CLOSE_START:
                        gb_P_Com[2] = 0x04; //Command 1
                        gb_P_Com[3] = 0;  //Command 2
                        gb_P_Com[4] = 0;  //Data 1
                        gb_P_Com[5] = 0;  //Data 2
                        Send_PelcoD_Command();
                        break;
              
                      case CAM_FOCUS_FAR_START:
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x80; //Command 2
                        gb_P_Com[4] = 0;  //Data 1
                        gb_P_Com[5] = 0;  //Data 2
                        Send_PelcoD_Command();
                        break;
                      case CAM_FOCUS_NEAR_START:
                        gb_P_Com[2] = 0x01; //Command 1
                        gb_P_Com[3] = 0;  //Command 2
                        gb_P_Com[4] = 0;  //Data 1
                        gb_P_Com[5] = 0;  //Data 2
                        Send_PelcoD_Command();
                        break;
              
                      case CAM_FOCUS_SPEED:
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x27; //Command 2
                        gb_P_Com[4] = 0;  //Data 1
                        if(gb_Show_Number_Nor_HL_Status == 0)
                          gb_P_Com[5] = UserPrefNumberID - 1; //Data 2
                        else
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 72  

                          gb_P_Com[5] = 0xFF;
                        //Check Max Value
                        if(gb_P_Com[5] >= 0x03)
                          gb_P_Com[5] = 0x03;
                        Send_PelcoD_Command();
                        break;
                      case CAM_ZOOM_SPEED:
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x25; //Command 2
                        gb_P_Com[4] = 0;  //Data 1
                        if(gb_Show_Number_Nor_HL_Status == 0)
                          gb_P_Com[5] = UserPrefNumberID - 1; //Data 2
                        else
                          gb_P_Com[5] = 0xFF;
                        //Check Max Value
                        if(gb_P_Com[5] >= 0x03)
                          gb_P_Com[5] = 0x03;
                        Send_PelcoD_Command();
                        break;
                    #endif    
                      case CAM_PTZ_RIGHT: 
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x02; //Command 2
                        if(SpeedDomeMode==1)
                          gb_P_Com[4] = 0xff; //Data 3  
                        else
                          gb_P_Com[4] = gb_PTZ_Speed; //Data 1
                        gb_P_Com[5] = 0;  //Data 2
                        Send_PelcoD_Command();
                        break;
                      case CAM_PTZ_LEFT:  
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x04; //Command 2
                        if(SpeedDomeMode==1)
                          gb_P_Com[4] = 0xff; //Data 3  
                        else
                          gb_P_Com[4] = gb_PTZ_Speed; //Data 1
                        gb_P_Com[5] = 0;  //Data 2
                        Send_PelcoD_Command();
                        break;
                      case CAM_PTZ_UP:  
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x08; //Command 2
                        gb_P_Com[4] = 0;  //Data 1
                        if(SpeedDomeMode==1)
                          gb_P_Com[5] = 0xff; //Data 3  
                        else
                          gb_P_Com[5] = gb_PTZ_Speed; //Data 2
                        Send_PelcoD_Command();
                        break;
                      case CAM_PTZ_DOWN:  
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x10; //Command 2
                        gb_P_Com[4] = 0;  //Data 1
                        if(SpeedDomeMode==1)
                          gb_P_Com[5] = 0xff; //Data 3  
                        else
                          gb_P_Com[5] = gb_PTZ_Speed; //Data 2
                        Send_PelcoD_Command();
                        break;
                      case CAM_SET:
                        gb_P_Com[2] = 0;  //Command 1
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 73  

                        gb_P_Com[3] = 0x03; //Command 2
                        gb_P_Com[4] = 0;  //Data 1
                        //if(gb_Show_Number_Nor_HL_Status == 0)
                        //  gb_P_Com[5] = UserPrefNumberID; //Data 2
                        //else
                          gb_P_Com[5] = PresetNumber;
                        Send_PelcoD_Command();
                        break;
                      case CAM_CALL:
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x07; //Command 2
                        gb_P_Com[4] = 0;  //Data 1
                        //if(gb_Show_Number_Nor_HL_Status == 0)
                        //  gb_P_Com[5] = UserPrefNumberID; //Data 2
                        //else
                          gb_P_Com[5] = PresetNumber;
                        Send_PelcoD_Command();
                        break;
                      case CAM_MENU_ENTER:  
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x03; //Command 2
                        gb_P_Com[4] = 0;  //Data 1
                        gb_P_Com[5] = 0x5F; //Data 2
                        Send_PelcoD_Command();
                        break;
                      case CAM_Iris_Open: 
                        gb_P_Com[2] = 0x02; //Command 1
                        gb_P_Com[3] = 0;  //Command 2
                        gb_P_Com[4] = 0;  //Data 1
                        gb_P_Com[5] = 0;  //Data 2
                        Send_PelcoD_Command();
                        break;  
                    #if 0   
                      case CAM_PTZ_RIGHT_UP:  
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x0A; //Command 2
                        gb_P_Com[4] = gb_PTZ_Right_Speed; //Data 1
                        gb_P_Com[5] = gb_PTZ_Up_Speed;  //Data 2
                        Send_PelcoD_Command();
                        break;
                      case CAM_PTZ_RIGHT_DOWN:  
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x12; //Command 2
                        gb_P_Com[4] = gb_PTZ_Right_Speed; //Data 1
                        gb_P_Com[5] = gb_PTZ_Down_Speed;  //Data 2
                        Send_PelcoD_Command();
                        break;
                      case CAM_PTZ_LEFT_UP: 
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x0C; //Command 2
                        gb_P_Com[4] = gb_PTZ_Left_Speed;  //Data 1
                        gb_P_Com[5] = gb_PTZ_Up_Speed;  //Data 2
                        Send_PelcoD_Command();
                        break;
                      case CAM_PTZ_LEFT_DOWN: 
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x14; //Command 2
                        gb_P_Com[4] = gb_PTZ_Left_Speed;  //Data 1
                        gb_P_Com[5] = gb_PTZ_Down_Speed;  //Data 2
                        Send_PelcoD_Command();
                        break;
                    #endif    
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 74  

                    }
                    break;
              #ifdef GE_PROTOCOL
                  case 2:
                    //Clear GE Command Buffer
                    for(j=0;j<9;j++)
                      GE_Com[j] = 0 ;
                    
                    GE_Com[0] = 0xFF;   //STX-Start Transmission
                    //Check Input Source with Camera Address
                      GE_Com[6] = CAMNumber;  // 0~255
                    //Select Command ID
                    switch(Com_ID)
                    {
                      case CAM_PTZ_RIGHT: 
                        GE_Com[1] = 0x07; //Length 
                        GE_Com[2] = 0x09; //Message type 1 
                        GE_Com[3] = 0x05; //Message type 2
                        GE_Com[4] = 0;  //Destination
                        GE_Com[5] = 0;  //Source
                        GE_Com[7] = 0xc0; //Motor command 
                        Send_GE_Command();
                        break;
                      case CAM_PTZ_LEFT:  
                        GE_Com[1] = 0x07; //Length 
                        GE_Com[2] = 0x09; //Message type 1 
                        GE_Com[3] = 0x05; //Message type 2
                        GE_Com[4] = 0;  //Destination
                        GE_Com[5] = 0;  //Source
                        GE_Com[7] = 0x80; //Motor command 
                        Send_GE_Command();
                        break;
                      case CAM_PTZ_UP:  
                        GE_Com[1] = 0x07; //Length 
                        GE_Com[2] = 0x09; //Message type 1 
                        GE_Com[3] = 0x05; //Message type 2
                        GE_Com[4] = 0;  //Destination
                        GE_Com[5] = 0;  //Source
                        GE_Com[7] = 0x81; //Motor command 
                        Send_GE_Command();
                        break;
                      case CAM_PTZ_DOWN:  
                        GE_Com[1] = 0x07; //Length 
                        GE_Com[2] = 0x09; //Message type 1 
                        GE_Com[3] = 0x05; //Message type 2
                        GE_Com[4] = 0;  //Destination
                        GE_Com[5] = 0;  //Source
                        GE_Com[7] = 0xc1; //Motor command 
                        Send_GE_Command();
                        break;
                      case CAM_ZOOM_IN_START: 
                        GE_Com[1] = 0x07; //Length 
                        GE_Com[2] = 0x09; //Message type 1 
                        GE_Com[3] = 0x05; //Message type 2
                        GE_Com[4] = 0;  //Destination
                        GE_Com[5] = 0;  //Source
                        GE_Com[7] = 0xc1; //Motor command 
                        Send_GE_Command();  
                        break;
                      case CAM_ZOOM_OUT_START:  
                        GE_Com[1] = 0x07; //Length 
                        GE_Com[2] = 0x09; //Message type 1 
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 75  

                        GE_Com[3] = 0x05; //Message type 2
                        GE_Com[4] = 0;  //Destination
                        GE_Com[5] = 0;  //Source
                        GE_Com[7] = 0xc1; //Motor command 
                        Send_GE_Command();
                        break;
              
              
                    }
                    
                  break;
              #endif    
                }
                
              }
              #endif
2334          #if 0
              ////////////////////////////////////////////////////////////////
              //
              //  Send Pelco P Command Using RS485 Port A Function
              //
              ////////////////////////////////////////////////////////////////
              void Send_PelcoP_Command(void)
              {
                BYTE ii,j;
              
                //Generate Camera Mode Pelco P Check Sum
                gb_P_Com[7] = gb_P_Com[0];  
                for(j=1;j<7;j++)
                  gb_P_Com[7] = gb_P_Com[7]^gb_P_Com[j];
              
                //Change_RS485_TxRx(0,RS485_TX);
                //Start Send Pelco P Command
                //Printf("\r\nTH1=%02x",(WORD)TH1);
                //Printf("\r\nBaud_rate=%d",(WORD)Baud_rate);
                switch(Baud_rate)
                {
                case Baud_rate2400:
                  S2BRT=0xd0;//0xd0;
                  break;
                case Baud_rate4800:
                  S2BRT=0xe8;//0xe8;
                  break;
                case Baud_rate9600:
                  S2BRT=0xf4;//0xf4;
                  break;
                }
                
                Printf("\r\nTH111111111111111=%02x",(WORD)TH1);
                Wait_ms(100);
                for(ii=0;ii<8;ii++)
                {
                  RS2_tx(gb_P_Com[ii]); 
                }
                Wait_ms(100);
                S2BRT=0xf4; //Baud_rate960
                //TH1=0xf4; //Baud_rate9600
                //while(!(READ_PCB_REG(SP0STS) & TEMT));
                //Change_RS485_TxRx(0,RS485_RX);
              
              }
              
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 76  

              
              ////////////////////////////////////////////////////////////////
              //
              //  Send Pelco D Command Using RS485 Port A Function
              //
              ////////////////////////////////////////////////////////////////
              void Send_PelcoD_Command(void)
              {
                BYTE ii,j;
              
                //Generate Camera Mode Pelco D Check Sum
                gb_P_Com[6] = gb_P_Com[1];  
                for(j=2;j<6;j++)
                  gb_P_Com[6] = gb_P_Com[6]+gb_P_Com[j];
              
                switch(Baud_rate)
                {
                case Baud_rate2400:
                  S2BRT=0xd0;//0xd0;
                  break;
                case Baud_rate4800:
                  S2BRT=0xe8;//0xe8;
                  break;
                case Baud_rate9600:
                  S2BRT=0xf4;//0xf4;
                  break;
                }
              
                Printf("\r\ngb_p_Com[0]=%02x",(WORD)gb_P_Com[0]);
                Wait_ms(100);
                //Change_RS485_TxRx(0,RS485_TX);
                //Start Send Pelco D Command
                for(ii=0;ii<7;ii++)
                {
                  RS2_tx(gb_P_Com[ii]); 
                }
              
                Wait_ms(100);
                S2BRT=0xf4; //Baud_rate960
                //while(!(READ_PCB_REG(SP0STS) & TEMT));
                //Change_RS485_TxRx(0,RS485_RX);
              }
              #endif
2423          #if 0//def GE_PROTOCOL
              ////////////////////////////////////////////////////////////////
              //
              //  Send GE Command Using RS485 Port A Function
              //
              ////////////////////////////////////////////////////////////////
              void Send_GE_Command(void)
              {
                BYTE ii,j;
              
                //Generate Camera Mode Pelco D Check Sum
                GE_Com[8] = 0;  
                for(j=1;j<=GE_Com[1];j++)
                  {GE_Com[8] = GE_Com[8]+GE_Com[j];}
              
                GE_Com[8]=~GE_Com[8]+1;
              
                switch(Baud_rate)
                {
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 77  

                case Baud_rate2400:
                  S2BRT=0xd0;//0xd0;
                  break;
                case Baud_rate4800:
                  S2BRT=0xe8;//0xe8;
                  break;
                case Baud_rate9600:
                  S2BRT=0xf4;//0xf4;
                  break;
                }
              
                Printf("\r\n",0);
                
                Wait_ms(1000);
                //Change_RS485_TxRx(0,RS485_TX);
                //Start Send Pelco D Command
                for(ii=0;ii<=GE_Com[1];ii++)
                {
                  RS2_tx(GE_Com[ii]); 
                }
              
                Wait_ms(400);
                S2BRT=0xf4; //Baud_rate960
                //while(!(READ_PCB_REG(SP0STS) & TEMT));
                //Change_RS485_TxRx(0,RS485_RX);
              }
              #endif
2469          
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 78  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION DvrReceivePaser (BEGIN)
                                           ; SOURCE LINE # 1067
                                           ; SOURCE LINE # 1068
                                           ; SOURCE LINE # 1070
0000 120000      E     LCALL   RS_ready
0003 EF                MOV     A,R7
0004 7003              JNZ     $ + 5H
0006 020000      R     LJMP    ?C0003
                                           ; SOURCE LINE # 1071
                                           ; SOURCE LINE # 1072
0009 120000      E     LCALL   RS_rx
000C 900000      R     MOV     DPTR,#c
000F EF                MOV     A,R7
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1074
0011 647E              XRL     A,#07EH
0013 7017              JNZ     ?C0002
                                           ; SOURCE LINE # 1075
                                           ; SOURCE LINE # 1076
0015 7BFF              MOV     R3,#0FFH
0017 7A00        R     MOV     R2,#HIGH ?SC_0
0019 7900        R     MOV     R1,#LOW ?SC_0
001B 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 1077
001E C200        R     CLR     protocol_escape_flag
                                           ; SOURCE LINE # 1078
0020 900000      R     MOV     DPTR,#protocol_state
0023 7401              MOV     A,#01H
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1079
0026 E4                CLR     A
0027 900000      R     MOV     DPTR,#protocol_chksum
002A F0                MOVX    @DPTR,A
002B 22                RET     
                                           ; SOURCE LINE # 1081
002C         ?C0002:
                                           ; SOURCE LINE # 1083
002C 900000      R     MOV     DPTR,#c
002F E0                MOVX    A,@DPTR
0030 FF                MOV     R7,A
0031 647D              XRL     A,#07DH
0033 7003              JNZ     ?C0004
                                           ; SOURCE LINE # 1084
                                           ; SOURCE LINE # 1085
0035 D200        R     SETB    protocol_escape_flag
0037 22                RET     
                                           ; SOURCE LINE # 1087
0038         ?C0004:
                                           ; SOURCE LINE # 1089
0038 300009      R     JNB     protocol_escape_flag,?C0005
                                           ; SOURCE LINE # 1090
                                           ; SOURCE LINE # 1091
003B C200        R     CLR     protocol_escape_flag
                                           ; SOURCE LINE # 1092
003D EF                MOV     A,R7
003E 4470              ORL     A,#070H
0040 900000      R     MOV     DPTR,#c
0043 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1093
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 79  

0044         ?C0005:
                                           ; SOURCE LINE # 1095
0044 900000      R     MOV     DPTR,#protocol_state
0047 E0                MOVX    A,@DPTR
0048 FB                MOV     R3,A
0049 6404              XRL     A,#04H
004B 6010              JZ      ?C0006
                                           ; SOURCE LINE # 1096
                                           ; SOURCE LINE # 1097
004D 900000      R     MOV     DPTR,#protocol_chksum
0050 E0                MOVX    A,@DPTR
0051 FE                MOV     R6,A
0052 900000      R     MOV     DPTR,#c
0055 E0                MOVX    A,@DPTR
0056 FD                MOV     R5,A
0057 EE                MOV     A,R6
0058 6D                XRL     A,R5
0059 900000      R     MOV     DPTR,#protocol_chksum
005C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1098
005D         ?C0006:
                                           ; SOURCE LINE # 1100
005D EB                MOV     A,R3
005E 24FE              ADD     A,#0FEH
0060 602F              JZ      ?C0021
0062 14                DEC     A
0063 6066              JZ      ?C0036
0065 14                DEC     A
0066 7003              JNZ     $ + 5H
0068 020000      R     LJMP    ?C0050
006B 2403              ADD     A,#03H
006D 6003              JZ      $ + 5H
006F 020000      R     LJMP    ?C0003
                                           ; SOURCE LINE # 1101
                                           ; SOURCE LINE # 1102
0072         ?C0008:
                                           ; SOURCE LINE # 1103
0072 900000      R     MOV     DPTR,#c
0075 E0                MOVX    A,@DPTR
0076 900000      R     MOV     DPTR,#protocol_type
0079 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1104
007A 14                DEC     A
007B 24F9              ADD     A,#0F9H
007D 5008              JNC     ?C0019
007F 24F8              ADD     A,#0F8H
0081 24FD              ADD     A,#0FDH
0083 5002              JNC     ?C0019
0085 8007              SJMP    ?C0020
                                           ; SOURCE LINE # 1105
                                           ; SOURCE LINE # 1106
                                           ; SOURCE LINE # 1107
                                           ; SOURCE LINE # 1108
                                           ; SOURCE LINE # 1109
                                           ; SOURCE LINE # 1110
                                           ; SOURCE LINE # 1111
                                           ; SOURCE LINE # 1112
                                           ; SOURCE LINE # 1113
                                           ; SOURCE LINE # 1114
                                           ; SOURCE LINE # 1115
0087         ?C0019:
                                           ; SOURCE LINE # 1116
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 80  

0087 900000      R     MOV     DPTR,#protocol_state
008A 7402              MOV     A,#02H
008C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1117
008D 22                RET     
                                           ; SOURCE LINE # 1118
008E         ?C0020:
                                           ; SOURCE LINE # 1119
                                           ; SOURCE LINE # 1120
008E 020000      R     LJMP    ?C0072
                                           ; SOURCE LINE # 1121
                                           ; SOURCE LINE # 1122
                                           ; SOURCE LINE # 1123
0091         ?C0021:
                                           ; SOURCE LINE # 1124
0091 900000      R     MOV     DPTR,#c
0094 E0                MOVX    A,@DPTR
0095 900000      R     MOV     DPTR,#protocol_len
0098 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1125
0099 A3                INC     DPTR
009A E0                MOVX    A,@DPTR
009B 14                DEC     A
009C 24F9              ADD     A,#0F9H
009E 5008              JNC     ?C0032
00A0 24F8              ADD     A,#0F8H
00A2 24FD              ADD     A,#0FDH
00A4 5002              JNC     ?C0032
00A6 8020              SJMP    ?C0035
                                           ; SOURCE LINE # 1126
                                           ; SOURCE LINE # 1127
                                           ; SOURCE LINE # 1128
                                           ; SOURCE LINE # 1129
                                           ; SOURCE LINE # 1130
                                           ; SOURCE LINE # 1131
                                           ; SOURCE LINE # 1132
                                           ; SOURCE LINE # 1133
                                           ; SOURCE LINE # 1134
                                           ; SOURCE LINE # 1135
                                           ; SOURCE LINE # 1136
00A8         ?C0032:
                                           ; SOURCE LINE # 1137
00A8 900000      R     MOV     DPTR,#protocol_len
00AB E0                MOVX    A,@DPTR
00AC 7007              JNZ     ?C0033
                                           ; SOURCE LINE # 1138
                                           ; SOURCE LINE # 1139
00AE 900000      R     MOV     DPTR,#protocol_state
00B1 7404              MOV     A,#04H
00B3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1140
00B4 22                RET     
00B5         ?C0033:
                                           ; SOURCE LINE # 1142
                                           ; SOURCE LINE # 1143
00B5 E4                CLR     A
00B6 900000      R     MOV     DPTR,#protocol_data_count
00B9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1144
00BA 900000      R     MOV     DPTR,#protocol_state
00BD 7403              MOV     A,#03H
00BF F0                MOVX    @DPTR,A
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 81  

                                           ; SOURCE LINE # 1145
00C0 7BFF              MOV     R3,#0FFH
00C2 7A00        R     MOV     R2,#HIGH ?SC_12
00C4 7900        R     MOV     R1,#LOW ?SC_12
                                           ; SOURCE LINE # 1146
                                           ; SOURCE LINE # 1147
00C6 804D              SJMP    ?C0070
                                           ; SOURCE LINE # 1148
00C8         ?C0035:
                                           ; SOURCE LINE # 1149
00C8         ?C0069:
                                           ; SOURCE LINE # 1150
00C8 020000      R     LJMP    ?C0072
                                           ; SOURCE LINE # 1151
                                           ; SOURCE LINE # 1152
                                           ; SOURCE LINE # 1153
00CB         ?C0036:
                                           ; SOURCE LINE # 1154
00CB 900000      R     MOV     DPTR,#protocol_type
00CE E0                MOVX    A,@DPTR
00CF 14                DEC     A
00D0 24F9              ADD     A,#0F9H
00D2 5008              JNC     ?C0047
00D4 24F8              ADD     A,#0F8H
00D6 24FD              ADD     A,#0FDH
00D8 5002              JNC     ?C0047
00DA 803C              SJMP    ?C0049
                                           ; SOURCE LINE # 1155
                                           ; SOURCE LINE # 1156
                                           ; SOURCE LINE # 1157
                                           ; SOURCE LINE # 1158
                                           ; SOURCE LINE # 1159
                                           ; SOURCE LINE # 1160
                                           ; SOURCE LINE # 1161
                                           ; SOURCE LINE # 1162
                                           ; SOURCE LINE # 1163
                                           ; SOURCE LINE # 1164
00DC         ?C0047:
                                           ; SOURCE LINE # 1165
00DC 900000      R     MOV     DPTR,#c
00DF E0                MOVX    A,@DPTR
00E0 FF                MOV     R7,A
00E1 900000      R     MOV     DPTR,#protocol_data_count
00E4 E0                MOVX    A,@DPTR
00E5 2400        R     ADD     A,#LOW protocol_data
00E7 F582              MOV     DPL,A
00E9 E4                CLR     A
00EA 3400        R     ADDC    A,#HIGH protocol_data
00EC F583              MOV     DPH,A
00EE EF                MOV     A,R7
00EF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1166
00F0 900000      R     MOV     DPTR,#protocol_data_count
00F3 E0                MOVX    A,@DPTR
00F4 04                INC     A
00F5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1167
00F6 A3                INC     DPTR
00F7 E0                MOVX    A,@DPTR
00F8 FF                MOV     R7,A
00F9 900000      R     MOV     DPTR,#protocol_data_count
00FC E0                MOVX    A,@DPTR
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 82  

00FD B5070F            CJNE    A,AR7,?C0048
                                           ; SOURCE LINE # 1168
0100 900000      R     MOV     DPTR,#protocol_state
0103 7404              MOV     A,#04H
0105 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1169
0106 7BFF              MOV     R3,#0FFH
0108 7A00        R     MOV     R2,#HIGH ?SC_16
010A 7900        R     MOV     R1,#LOW ?SC_16
010C 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 1170
010F         ?C0048:
                                           ; SOURCE LINE # 1172
010F 7BFF              MOV     R3,#0FFH
0111 7A00        R     MOV     R2,#HIGH ?SC_20
0113 7900        R     MOV     R1,#LOW ?SC_20
0115         ?C0070:
0115 020000      E     LJMP    _Printf
                                           ; SOURCE LINE # 1173
                                           ; SOURCE LINE # 1174
0118         ?C0049:
                                           ; SOURCE LINE # 1175
0118         ?C0071:
                                           ; SOURCE LINE # 1176
0118 020000      R     LJMP    ?C0072
                                           ; SOURCE LINE # 1177
                                           ; SOURCE LINE # 1178
                                           ; SOURCE LINE # 1179
011B         ?C0050:
                                           ; SOURCE LINE # 1180
011B 900000      R     MOV     DPTR,#c
011E E0                MOVX    A,@DPTR
011F FF                MOV     R7,A
0120 900000      R     MOV     DPTR,#protocol_chksum
0123 E0                MOVX    A,@DPTR
0124 6F                XRL     A,R7
0125 6003              JZ      $ + 5H
0127 020000      R     LJMP    ?C0051
                                           ; SOURCE LINE # 1181
                                           ; SOURCE LINE # 1183
012A 7BFF              MOV     R3,#0FFH
012C 7A00        R     MOV     R2,#HIGH ?SC_24
012E 7900        R     MOV     R1,#LOW ?SC_24
0130 900000      R     MOV     DPTR,#protocol_type
0133 E0                MOVX    A,@DPTR
0134 FF                MOV     R7,A
0135 900000      E     MOV     DPTR,#?_Printf?BYTE+03H
0138 E4                CLR     A
0139 F0                MOVX    @DPTR,A
013A A3                INC     DPTR
013B EF                MOV     A,R7
013C F0                MOVX    @DPTR,A
013D 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 1185
0140 900000      R     MOV     DPTR,#protocol_type
0143 E0                MOVX    A,@DPTR
0144 120000      E     LCALL   ?C?CCASE
0147 0000        R     DW      ?C0053
0149 01                DB      01H
014A 0000        R     DW      ?C0054
014C 02                DB      02H
014D 0000        R     DW      ?C0055
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 83  

014F 03                DB      03H
0150 0000        R     DW      ?C0056
0152 04                DB      04H
0153 0000        R     DW      ?C0057
0155 05                DB      05H
0156 0000        R     DW      ?C0058
0158 06                DB      06H
0159 0000        R     DW      ?C0062
015B 10                DB      010H
015C 0000        R     DW      ?C0063
015E 11                DB      011H
015F 0000        R     DW      ?C0064
0161 12                DB      012H
0162 0000              DW      00H
0164 0000        R     DW      ?C0066
                                           ; SOURCE LINE # 1186
                                           ; SOURCE LINE # 1187
0166         ?C0053:
                                           ; SOURCE LINE # 1188
0166 7BFF              MOV     R3,#0FFH
0168 7A00        R     MOV     R2,#HIGH ?SC_42
016A 7900        R     MOV     R1,#LOW ?SC_42
                                           ; SOURCE LINE # 1189
016C 8040              SJMP    ?C0074
                                           ; SOURCE LINE # 1190
016E         ?C0054:
                                           ; SOURCE LINE # 1191
016E E4                CLR     A
016F 900000      E     MOV     DPTR,#WDT_Echo_Count
0172 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1192
0173 7BFF              MOV     R3,#0FFH
0175 7A00        R     MOV     R2,#HIGH ?SC_56
0177 7900        R     MOV     R1,#LOW ?SC_56
0179         ?C0073:
                                           ; SOURCE LINE # 1193
0179 8033              SJMP    ?C0074
                                           ; SOURCE LINE # 1194
017B         ?C0055:
                                           ; SOURCE LINE # 1195
017B 7D05              MOV     R5,#05H
                                           ; SOURCE LINE # 1196
017D 8014              SJMP    ?C0076
                                           ; SOURCE LINE # 1197
017F         ?C0056:
                                           ; SOURCE LINE # 1198
017F 7D06              MOV     R5,#06H
0181         ?C0075:
                                           ; SOURCE LINE # 1199
0181 8010              SJMP    ?C0076
                                           ; SOURCE LINE # 1200
0183         ?C0057:
                                           ; SOURCE LINE # 1201
0183 7D09              MOV     R5,#09H
                                           ; SOURCE LINE # 1202
0185 8018              SJMP    ?C0080
                                           ; SOURCE LINE # 1203
0187         ?C0058:
                                           ; SOURCE LINE # 1204
0187 900000      R     MOV     DPTR,#protocol_data
018A E0                MOVX    A,@DPTR
018B 6004              JZ      ?C0059
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 84  

                                           ; SOURCE LINE # 1205
018D 7D02              MOV     R5,#02H
018F 8002              SJMP    ?C0068
0191         ?C0059:
                                           ; SOURCE LINE # 1207
0191 7D03              MOV     R5,#03H
0193         ?C0068:
0193         ?C0076:
0193         ?C0077:
                                           ; SOURCE LINE # 1208
0193 800A              SJMP    ?C0080
                                           ; SOURCE LINE # 1209
                                           ; SOURCE LINE # 1210
                                           ; SOURCE LINE # 1211
0195         ?C0062:
                                           ; SOURCE LINE # 1212
0195 7D04              MOV     R5,#04H
0197         ?C0078:
                                           ; SOURCE LINE # 1213
0197 8006              SJMP    ?C0080
                                           ; SOURCE LINE # 1214
0199         ?C0063:
                                           ; SOURCE LINE # 1215
0199 7D07              MOV     R5,#07H
019B         ?C0079:
                                           ; SOURCE LINE # 1216
019B 8002              SJMP    ?C0080
                                           ; SOURCE LINE # 1217
019D         ?C0064:
                                           ; SOURCE LINE # 1218
019D 7D08              MOV     R5,#08H
019F         ?C0080:
019F 7FFA              MOV     R7,#0FAH
01A1 7E00              MOV     R6,#00H
01A3 120000      E     LCALL   _MCUTimerActiveTimerEvent
                                           ; SOURCE LINE # 1219
01A6 8009              SJMP    ?C0066
                                           ; SOURCE LINE # 1220
                                           ; SOURCE LINE # 1221
                                           ; SOURCE LINE # 1222
                                           ; SOURCE LINE # 1224
01A8         ?C0051:
                                           ; SOURCE LINE # 1226
                                           ; SOURCE LINE # 1227
01A8 7BFF              MOV     R3,#0FFH
01AA 7A00        R     MOV     R2,#HIGH ?SC_77
01AC 7900        R     MOV     R1,#LOW ?SC_77
01AE         ?C0074:
01AE 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 1229
01B1         ?C0066:
                                           ; SOURCE LINE # 1230
01B1         ?C0072:
01B1 E4                CLR     A
01B2 900000      R     MOV     DPTR,#protocol_state
01B5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1231
                                           ; SOURCE LINE # 1232
                                           ; SOURCE LINE # 1233
                                           ; SOURCE LINE # 1234
                                           ; SOURCE LINE # 1235
                                           ; SOURCE LINE # 1719
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 85  

01B6         ?C0003:
01B6 22                RET     
             ; FUNCTION DvrReceivePaser (END)

C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 86  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_SCALER_TIMER_EVENT_DP_LINK_STATUS_IRQ  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_GO_TO_POWER_SAVING .  E_CONST  -----  U_CHAR   -----  1
POWER_SEL_SAVING . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_AUDIO_LOAD_STABLE_  E_CONST  -----  U_CHAR   -----  1
EnumBatteryStatus. . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_START. . . . . . .  E_CONST  -----  U_CHAR   -----  1
protocol_data_count. . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0000H  1
EnumModeAction . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
DWORD. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
_POWER_ACTION_NORMAL_TO_NOSUPPORT_PS .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_JUDGE_BTH_STATE. .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_CAPACITY_HIGH . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_DISABLE. . . . .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_STOP_CHARGE . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_RED_OFF. . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_SOURCE_CLEAR_DETEC  E_CONST  -----  U_CHAR   -----  1
BATERY_10. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_ABNORMAL_MODE . . . . . .  E_CONST  -----  U_CHAR   -----  1
EnumPowerAction. . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_SHOW_NO_CABLE. .  E_CONST  -----  U_CHAR   -----  1
_MODE_STATUS_NOSIGNAL. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_STATUS_NOSUPPORT . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_RESET_TO_DISPLAY_SETTING.  E_CONST  -----  U_CHAR   -----  1
BATERY_50. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
POWER_SEL_OFF. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
BATERY_25. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_CAPACITY_LEVEL1 . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_NO_RESET_MODE . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_KEY_SCAN_READY . . .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_CAPACITY_LEVEL2 . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_GRN_RED_ON . . . .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_CAPACITY_LEVEL3 . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_RESET_TO_FACTORY_MODE . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_NOSUPPORT_PS_TO_OFF. . .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_CAPACITY_LEVEL4 . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_GRN_OFF. . . . . .  E_CONST  -----  U_CHAR   -----  1
BATERY_75. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
EnumMCUTimerEventID. . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_BATT_STATUS_TEMP_NORMAL . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_NR_DETECTION_FINIS  E_CONST  -----  U_CHAR   -----  1
protocol_len . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0001H  1
_POWER_STATUS_AC_ON. . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TEMP_State . . . . . . . . . . . . . .  * TAG *  -----  ENUM     -----  -----
protocol_type. . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0002H  1
_SCALER_TIMER_EVENT_END. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_SHOW_BURN_IN . . . .  E_CONST  -----  U_CHAR   -----  1
RS_ready . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
StructBatteryInfoType. . . . . . . . .  TYPEDEF  -----  STRUCT   -----  4
  b5BatteryStatus. . . . . . . . . . .  MEMBER   -----  FIELD    0000H  5.0
  b1NoBattery. . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.5
  b1AC_PLUG. . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.6
  b3BTHStatus. . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  3.0
  b1BatteryCapacityLow . . . . . . . .  MEMBER   -----  FIELD    0001H  1.3
  b1BatteryAbnormal. . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.4
  b2BatteryChargeStatus. . . . . . . .  MEMBER   -----  FIELD    0001H  2.5
  BatteryCapacity. . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
_USER_TIMER_EVENT_OSD_ENCODER_DEVIATIO  E_CONST  -----  U_CHAR   -----  1
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 87  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_SYSTEM_TIMER_EVENT_RED_BLINK. . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_DP_HOTPLUG_ASSERTED E_CONST  -----  U_CHAR   -----  1
_POWER_STATUS_NOSUPPORT_SAVING . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_JUDGE_PSW_STATE. .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_END. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_NONE . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_AC_ON_TO_NORMAL. . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_RESET_TO_DISPLAY_SETTING_  E_CONST  -----  U_CHAR   -----  1
StructTimerEventTableType. . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  b1EventValid . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.0
  b7EventID. . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  7.1
  usTime . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0001H  2
_USER_TIMER_EVENT_PANEL_BACKLIGHT_ON .  E_CONST  -----  U_CHAR   -----  1
EnumModeStatus . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_CHECK. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
BRIGHTNESS_NORMAL. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_RESET_TO_SEARCH . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_GRN_BLINK. . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_RESET_TO_POWER_SAVING . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_DVR_REBOOT . . .  E_CONST  -----  U_CHAR   -----  1
BATERY_State . . . . . . . . . . . . .  * TAG *  -----  ENUM     -----  -----
BATERY_AC. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_MHL_D0_READY_TO_TR  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_MHL_D1_READY_TO_TR  E_CONST  -----  U_CHAR   -----  1
EnumPowerStatus. . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
TEMP_OK. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_PANEL_USED_TIMER . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_AC_ON_TO_OFF . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_JUDGE_WDT_ECHO . .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_LOW_CHARGE. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_JUDGE_POWER_STATE.  E_CONST  -----  U_CHAR   -----  1
BYTE . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
TEMP_Alarm1. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_NONE. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TEMP_Alarm2. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_TMDS_HDMI_PACKET_D  E_CONST  -----  U_CHAR   -----  1
EnumSystemTimerEventID . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_LED_POWER_SAVING . .  E_CONST  -----  U_CHAR   -----  1
BATERY_100 . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_STATUS_INITIAL . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_RESET_TO_POWER_OFF. . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_MHL_D0_ACTIVE_VBUS  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_JUDGE_DVR_COMM . .  E_CONST  -----  U_CHAR   -----  1
WORD . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
WDT_Echo_Count . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
_SCALER_TIMER_EVENT_MHL_D1_ACTIVE_VBUS  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_TEMP_LOW. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_AC_MODE . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_PHASE_CNT_CHECK. .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_HLWIN_TYPE5_MOVE . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_GET_MCU_VERSION.  E_CONST  -----  U_CHAR   -----  1
BRIGHTNESS_MIN . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_NORMAL_TO_PS . . . . . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_PS_TO_NORMAL . . . . . .  E_CONST  -----  U_CHAR   -----  1
BRIGHTNESS_MAX . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
StructModeInfoType . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  b5ModeState. . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  5.0
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 88  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  b1DisplaySettingReady. . . . . . . .  MEMBER   -----  FIELD    0000H  1.5
  b1TimingConfirm. . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.6
  b1ModeStateChanged . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.7
  b4ModeResetFlag. . . . . . . . . . .  MEMBER   -----  FIELD    0001H  4.0
  b1NoWaitForActive. . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.4
  b1ActiveReady. . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.5
_USER_TIMER_EVENT_OSD_DISTANCE_RESET .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_PHASE_CALIBRATION.  E_CONST  -----  U_CHAR   -----  1
_POWER_STATUS_NONE . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_END. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_STATUS_FACTORY . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_STATUS_DISPLAY_SETTING . . . . .  E_CONST  -----  U_CHAR   -----  1
protocol_escape_flag . . . . . . . . .  PUBLIC   DATA   BIT      0000H  1
_SYSTEM_TIMER_EVENT_RED_ON . . . . . .  E_CONST  -----  U_CHAR   -----  1
Register . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_JUDGE_AC_MODE. . .  E_CONST  -----  U_CHAR   -----  1
StructPowerInfoType. . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  b4PowerAction. . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  4.0
  b4PowerStatus. . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  4.4
  b1GDIIsolationFlag . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.0
  b1TopIsolationFlag . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.1
  b1AnalogIsolationFlag. . . . . . . .  MEMBER   -----  FIELD    0001H  1.2
_USER_TIMER_EVENT_OSD_MCU_ENTRY_SLEEP_  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_RESET_TO_NOSIGNAL . . . .  E_CONST  -----  U_CHAR   -----  1
_MODE_ACTION_RESET_TO_NOSUPPORT. . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_COUNT. . . . . . .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_START_CHARGE. . . . . . .  E_CONST  -----  U_CHAR   -----  1
POWER_SEL_ON . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_JUDGE_BATT_STATE .  E_CONST  -----  U_CHAR   -----  1
EnumUserTimerEventID . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_POWER_ACTION_PS_TO_OFF. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_COUNT. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_START. . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MCUTimerActiveTimerEvent. . . . . . .  EXTERN   CODE   PROC     -----  -----
_SYSTEM_TIMER_EVENT_GRN_ON . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_JUDGE_TW8836_COMM.  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_DP_HDCP_LONG_HOTPL  E_CONST  -----  U_CHAR   -----  1
RegisterInfo . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  6
  Min. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  Max. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0002H  2
  Default. . . . . . . . . . . . . . .  MEMBER   -----  INT      0004H  2
_BATT_STATUS_CAPACITY_LOW. . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_DO_AUTO_COLOR. . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_START. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_NOSUPPORT_PS_TO_PS . . .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_NO_BATT . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_MHL_D0_RECONNECT_1K E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_DVR_SHUTDOWN . .  E_CONST  -----  U_CHAR   -----  1
_MODE_STATUS_NONE. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_MHL_D1_RECONNECT_1K E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_CAMERA_VOLTAGE_DECE_CONST  -----  U_CHAR   -----  1
BRIGHTNESS_STATE . . . . . . . . . . .  * TAG *  -----  ENUM     -----  -----
_POWER_STATUS_SAVING . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_KEY_REPEAT_ENABLE. .  E_CONST  -----  U_CHAR   -----  1
_POWER_STATUS_NORMAL . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_NONE. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_GRN_ON_RED_BLINK .  E_CONST  -----  U_CHAR   -----  1
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    03/02/2020 12:07:33 PAGE 89  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_MODE_STATUS_SEARCH. . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
protocol_chksum. . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0003H  1
_POWER_STATUS_SAVING_BATTERY_MODE. . .  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_GRN_RED_BLINK. . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_PANEL_POWER_OFF. . .  E_CONST  -----  U_CHAR   -----  1
_POWER_STATUS_NORMAL_BATTERY_MODE. . .  E_CONST  -----  U_CHAR   -----  1
_MODE_STATUS_POWER_SAVING. . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_STANDBY_MODE . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_FACTORY_MODE . . . .  E_CONST  -----  U_CHAR   -----  1
protocol_param . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0004H  1
LongRegisterInfo . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  6
  Min. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  Max. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
  Default. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0004H  2
_MODE_STATUS_ACTIVE. . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_BATT_STATUS_TEMP_HIGH . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_DCC_HISTOGRAM_THD_  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_CAMERA_VOLTAGE_INCE_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_SHOW_POWER_SAVING E_CONST  -----  U_CHAR   -----  1
RS_rx. . . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_BATT_STATUS_FAST_CHARGE . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_DISPLAY_INFO . . . .  E_CONST  -----  U_CHAR   -----  1
_POWER_STATUS_NORMAL_NO_MATTERY_MODE .  E_CONST  -----  U_CHAR   -----  1
POWER_STATE. . . . . . . . . . . . . .  * TAG *  -----  ENUM     -----  -----
_POWER_STATUS_OFF. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_OSD_SHOW_NO_SIGNAL .  E_CONST  -----  U_CHAR   -----  1
protocol_data. . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    0005H  256
DvrReceivePaser. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  c. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
_SCALER_TIMER_EVENT_TMDS_VIDEO_DETECT.  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_LIGHT_SENSER_ON. . .  E_CONST  -----  U_CHAR   -----  1
_Printf. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_SCALER_TIMER_EVENT_D0_PORT_DIGITAL_SW  E_CONST  -----  U_CHAR   -----  1
_USER_TIMER_EVENT_BURN_IN_ON . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_D1_PORT_DIGITAL_SW  E_CONST  -----  U_CHAR   -----  1
_MODE_STATUS_POWER_OFF . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_MHL_D0_READY_TO_RE  E_CONST  -----  U_CHAR   -----  1
_SYSTEM_TIMER_EVENT_COUNT. . . . . . .  E_CONST  -----  U_CHAR   -----  1
protocol_state . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0105H  1
_POWER_ACTION_NORMAL_TO_OFF. . . . . .  E_CONST  -----  U_CHAR   -----  1
_POWER_ACTION_OFF_TO_NORMAL. . . . . .  E_CONST  -----  U_CHAR   -----  1
_SCALER_TIMER_EVENT_MHL_D1_READY_TO_RE  E_CONST  -----  U_CHAR   -----  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    439    ----
   CONSTANT SIZE    =     88    ----
   XDATA SIZE       =    262       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
