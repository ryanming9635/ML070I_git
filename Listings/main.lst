C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2021 14:24:37 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Output\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Include) DEBUG OBJECTEXTE
                    -ND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Output\main.obj)

line level    source

   1          /*****************************************************************************/
   2          /*                                                                                              */
   3          /*  TELI ML070I   MCU                                             */
   4          /*                                                                                              */
   5          /*  main.c                                                                    */
   6          /*                                                                                              */
   7          /*****************************************************************************/
   8          
   9          
  10          #include <math.h>
  11          #include <stdio.h>
  12          
  13          #include "Config.h"
  14          
  15          #include "reg.h"
  16          #include "typedefs.h"
  17          #include "main.h"
  18          #include "i2c.h"
  19          #include "adc.h"
  20          #include "etc_eep.h"
  21          #include "Printf.h"
  22          #include "KeyRemo.h"
  23          #include "Monitor.h"
  24          #include "CPU.h"
  25          #include "HS_DVRProtocol.h"
  26          
  27          StructBatteryInfoType g_stBatteryInfo = {0};
  28          StructDVRInfoType g_stDVRInfo = {0};
  29          extern DATA  DWORD tic_Init_time;
  30          extern bit  AccessEnable;
  31          
  32          BYTE  PowerFlag;
  33          BYTE  CameraVolt;
  34          BYTE  PWR_START_flag;
  35          BYTE LowBatteryFlag;
  36          BYTE PowerOffToOnFlag;
  37          BYTE DVRChangeCurrent=0;
  38          BYTE Power_down_mode=_DontgoingToPD;
  39          BYTE bytFastEncoderMode=OFF;
  40          float EncorderLen=0;
  41          WORD EncorderLen_Offset=0;
  42          BYTE EncorderLenint=0,EncorderCountPN=0,EncorderCountPN_offset=0;
  43          WORD EncorderLenfloaat=0;
  44          //BYTE Encorder1=0.85,Encorder2=0.8,Encorder3=0.75,Encorder4=0.75;
  45          //float Encorder1=100,Encorder2=100,Encorder3=100,Encorder4=100;
  46          float Encorder1=1,Encorder2=1,Encorder3=1,Encorder4=1;
  47          float Decimal1=0,Decimal2=0,Decimal3=0,Decimal4=0;
  48          
  49          extern WORD BatteryBTH,BatteryVoltage;
  50          
  51          #if (_DEBUG_MESSAGE_BatteryBTH==ON)
              WORD BTH_Temp=250;
              #endif
  54          #if (_DEBUG_MESSAGE_BatteryVoltage==ON)
C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2021 14:24:37 PAGE 2   

              WORD Battery_Voltage_Temp  =835;
              #endif
  57          
  58          //extern BYTE FLASH_FLAG;
  59          //extern WORD LED_FLASH_COUNT;
  60          extern bit ChangeKey;
  61          extern short EncorderCount;
  62          
  63          extern  DATA  WORD  tic_pc;
  64          extern DATA BYTE  RS_in;
  65          extern DATA BYTE  RS2_in;
  66          extern DATA BYTE RS2_out;
  67          extern StructPowerInfoType idata g_stPowerInfo ;
  68          extern DATA WORD keytic;
  69          extern bit RepeatKey;
  70          extern BYTE IE_Temp;
  71          extern BYTE bytHoldOn3SPowerOff;
  72          
  73          struct RegisterInfo UserRange={0,40,21};
  74          struct RegisterInfo AD5110Range={0,40,21};
  75          
  76          BYTE  DebugLevel;
  77          
  78          ///AD5110 step voltage
  79          BYTE  AD5110_setp[]={0x05,0x06,0x08,0x0A,0x0B,0x0D,0x0F,0x10,0x12,0x14,\
  80                    0x16,0x18,0x1a,0x1c,0x1e,0x20,0x22,0x25,0x27,0x2a,\
  81                    0x2c,0x2f,0x32,0x35,0x38,0x3b,0x3e,0x42,0x45,0x48,\
  82                    0x4b,0x50,0x55,0x58,0x5d,0x61,0x66,0x6b,0x70,0x75,\
  83                    0x7a  };
  84          
  85          
  86          void isp_write(unsigned char* buf, unsigned char addr_high, unsigned char addr_low, unsigned char len)
  87          {
  88   1        IFMT = 0x02;
  89   1        IFADRH = addr_high;
  90   1        do
  91   1        {
  92   2          IFADRL = addr_low;
  93   2          IFD = *buf;
  94   2          SCMD = 0x46;
  95   2          SCMD = 0xB9;
  96   2           
  97   2          buf++;
  98   2          addr_low++;
  99   2          if (addr_low == 0)
 100   2          {
 101   3             addr_high++;
 102   3             IFADRH = addr_high;
 103   3          }
 104   2          len--;
 105   2        }
 106   1        while (len != 0);
 107   1      }
 108          
 109          void isp_init(void)
 110          {
 111   1        ISPCR = 0x81;
 112   1      }
 113          
 114          void enter_isp(void)
 115          {
 116   1              // Clear the magic mark
C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2021 14:24:37 PAGE 3   

 117   1              unsigned char mark = 0x00;
 118   1              isp_init();
 119   1              isp_write(&mark, 0xEF, 0xFF, 1);
 120   1              ISPCR = 0x60;
 121   1      }
 122          
 123          
 124          BYTE mcuLib_ProtocolAppend(BYTE *pucBuf, BYTE * piLen, BYTE ucByte) {
 125   1          if (ucByte == 0x7E || ucByte == 0x7D) {
 126   2              pucBuf[*piLen] = 0x7D;
 127   2              (*piLen)++;
 128   2              pucBuf[*piLen] = 0x50 | (ucByte & 0x0F);
 129   2              (*piLen)++;
 130   2          } else {
 131   2              pucBuf[*piLen] = ucByte;
 132   2              (*piLen)++;
 133   2          }
 134   1          return 0;
 135   1      }
 136          
 137          BYTE mcuLib_ProtocolSendCmdWithParamNum(BYTE ucType, BYTE* pucParam, BYTE ucSize) {
 138   1          BYTE ucChecksum = 0;
 139   1          BYTE pucBuf[16];
 140   1          BYTE iLen;
 141   1          BYTE i;
 142   1         
 143   1          pucBuf[0] = 0x7E;
 144   1          iLen = 1;
 145   1          ucChecksum ^= ucType;
 146   1          mcuLib_ProtocolAppend(pucBuf, &iLen, ucType);
 147   1          ucChecksum ^= ucSize;
 148   1          mcuLib_ProtocolAppend(pucBuf, &iLen, ucSize);
 149   1      
 150   1          for (i = 0; i < ucSize; i++) {
 151   2              ucChecksum ^= pucParam[i];
 152   2              mcuLib_ProtocolAppend(pucBuf, &iLen, pucParam[i]);
 153   2          }
 154   1      
 155   1          mcuLib_ProtocolAppend(pucBuf, &iLen, ucChecksum);
 156   1      
 157   1        for (i = 0; i < (iLen); i++) {
 158   2            RS2_tx(pucBuf[i]);
 159   2          }
 160   1      
 161   1        
 162   1          return 0;
 163   1      }
 164          
 165          
 166          void MCU_SendCmdToDVR(BYTE ucType)
 167          {
 168   1        BYTE buf[7]={0,0,0,0,0,0,0};
 169   1        WORD val;
 170   1      switch(ucType)
 171   1      {
 172   2        case MCU_PROTOCOL_CMD_REPLY_MCU_FW: //Reply MCU firmware version
 173   2          buf[0]=ReadEEP(EEP_FWREV_MAJOR);      //FWVER
 174   2          buf[1]=ReadEEP(EEP_FWREV_MINOR1);
 175   2          buf[2]=ReadEEP(EEP_FWREV_MINOR2);
 176   2          mcuLib_ProtocolSendCmdWithParamNum(MCU_PROTOCOL_CMD_REPLY_MCU_FW,buf,3);  
 177   2          break;
 178   2      
C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2021 14:24:37 PAGE 4   

 179   2        case MCU_PROTOCOL_CMD_REGULAR_DATA:     //Regular data
 180   2      
 181   2        //val=(((GET_BATTERY_CAPACITY()*32)/10000)*100)+(((GET_BATTERY_CAPACITY()*32)%10000)/100);
 182   2        //val=(val*54)/100;
 183   2        #if 1
 184   2        val=((((GET_BATTERY_CAPACITY()*59)/*-800*/)/100))+((((GET_BATTERY_CAPACITY()*59)/*-800*/)/100))+((((GET_B
             -ATTERY_CAPACITY()*59)/*-800*/)/100));
 185   2      
 186   2          if((val/1000))
 187   2          val=(val/10)+1;
 188   2          else 
 189   2          val=(val/10);
 190   2      /*
 191   2           if(GET_BATTERY_STATE()==_BATT_STATUS_CAPACITY_LEVEL0)
 192   2          val=121;  
 193   2        else if(GET_BATTERY_STATE()==_BATT_STATUS_CAPACITY_LEVEL1)
 194   2          val=127;  
 195   2        else if(GET_BATTERY_STATE()==_BATT_STATUS_CAPACITY_LEVEL2)
 196   2          val=132;
 197   2        else if(GET_BATTERY_STATE()==_BATT_STATUS_CAPACITY_LEVEL3)
 198   2          val=146;  
 199   2        else   if(GET_BATTERY_STATE()==_BATT_STATUS_CAPACITY_LEVEL4)  
 200   2          val=155;
 201   2        else if(GET_BATTERY_STATE()==_BATT_STATUS_CAPACITY_MIN)
 202   2          val=115;  
 203   2        else if(GET_BATTERY_STATE()==_BATT_STATUS_CAPACITY_MAX)
 204   2          val=160;  
 205   2        else if(GET_BATTERY_STATE()==_BATT_STATUS_CAPACITY_MAX_STOP)
 206   2          val=164;
 207   2        else if(GET_BATTERY_STATE()==_BATT_STATUS_CAPACITY_NO_STARTUP)
 208   2          val=117;
 209   2        else   if(GET_BATTERY_STATE()==_BATT_STATUS_NO_BATT)  
 210   2          val=0;
 211   2      */
 212   2      
 213   2        #else
                val=((((GET_BATTERY_CAPACITY()*(32+1))/*-800*/)/10000)*100)+((((GET_BATTERY_CAPACITY()*(32+1))/*-800*/)%1
             -0000)/100);
                val=(val*(54+1))/100;
                #endif
 217   2          
 218   2          #if 1
 219   2          buf[0]=val;         ///battery info.
 220   2          #else
                  buf[0]=GET_BATTERY_STATE();         ///abttery info.
                  #endif
 223   2          #if 0//for test
                  
                    buf[2]=(BatteryVoltage>>8);
                    
                    buf[3]=(BatteryVoltage&0xff);
              
                  #else
 230   2          buf[2]=(BatteryBTH>>8);
 231   2      
 232   2          buf[3]=(BatteryBTH&0xff);
 233   2          #endif
 234   2          buf[4]=((EncorderLenint/10)<<4)|(EncorderLenint%10);   
 235   2      
 236   2          #if (_2ND_DECIMAL==ON)//ryan@20200505
 237   2          buf[5]=((EncorderLenfloaat/10)<<4)|(EncorderLenfloaat%10);
 238   2          #else
C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2021 14:24:37 PAGE 5   

                  buf[5]=(EncorderLenfloaat<<4);
                  #endif
 241   2          buf[6]=EncorderCountPN;
 242   2      
 243   2          if(GET_AC_PLUG()==_TRUE)
 244   2          buf[1]|=0x01;
 245   2      
 246   2          if(GET_BTH_STATE()==_BATT_STATUS_TEMP_HIGH)
 247   2          buf[1]|=0x02;
 248   2          
 249   2          if(GET_BTH_STATE()==_BATT_STATUS_TEMP_LOW)
 250   2          buf[1]|=0x04;
 251   2      
 252   2          if(GET_NO_BATTERY()==_TRUE)
 253   2          buf[1]|=0x08;
 254   2      
 255   2          if(GET_BATTERY_ABNORMAL()==_TRUE)
 256   2          buf[1]|=0x10;
 257   2          
 258   2          if(GET_BATTERY_HIGH_TMEP_WARN()==_TRUE)
 259   2          buf[1]|=0x20;
 260   2          
 261   2          if(GET_BATTERY_LOW_TMEP_WARN()==_TRUE)
 262   2          buf[1]|=0x40;
 263   2      
 264   2          if(((GET_STAT1()==OFF)&&(GET_STAT2()==ON)&&(BatteryBTH>90))&&(GET_BATTERY_CAPACITY_HIGH_FLAG()==_FALSE)&
             -&( GET_BTH_STATE()==_BATT_STATUS_TEMP_NORMAL)&&(GET_CHARGE_TMEP_ABNORMAL()==_FALSE)&&(GET_NO_BATTERY()==_FALSE))///charg
             -ing
 265   2          buf[1]|=0x80;
 266   2      
 267   2          
 268   2          mcuLib_ProtocolSendCmdWithParamNum(MCU_PROTOCOL_CMD_REGULAR_DATA,buf,7);                        
 269   2          break;
 270   2      
 271   2        case MCU_PROTOCOL_CMD_SYSTEM_SHUTDOWN:    //system shutdown
 272   2          if(GET_AC_PLUG_OUT()==_TRUE)      
 273   2            {
 274   3            buf[0]=1; 
 275   3            CLR_AC_PLUG_OUT();  
 276   3            #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                    GraphicsPrint(RED,"\r\n(AC_PLUG_OUT)");
                    #endif  
 279   3            }
 280   2          mcuLib_ProtocolSendCmdWithParamNum(MCU_PROTOCOL_CMD_SYSTEM_SHUTDOWN,buf,1);                     
 281   2          break;
 282   2      
 283   2        case MCU_PROTOCOL_CMD_ENTRY_FACTORY:  //Entry factory mode
 284   2          mcuLib_ProtocolSendCmdWithParamNum(MCU_PROTOCOL_CMD_ENTRY_FACTORY,buf,1); 
 285   2          break;
 286   2      
 287   2        case MCU_PROTOCOL_CMD_SLEEP_WAKE_UP:
 288   2          mcuLib_ProtocolSendCmdWithParamNum(MCU_PROTOCOL_CMD_SLEEP_WAKE_UP,buf,1); 
 289   2          break;
 290   2      
 291   2      default:
 292   2        break;
 293   2          
 294   2      }
 295   1        
 296   1      }
 297          
 298          
C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2021 14:24:37 PAGE 6   

 299          void InitialTimerEvent(void)
 300          {
 301   1        MCUTimerInitialTimerEvent();  //clear all of timer event  
 302   1        MCUTimerActiveTimerEvent(1, _SYSTEM_TIMER_EVENT_JUDGE_FIRST_GET_BATT_BTH_STATE);
 303   1            MCUTimerActiveTimerEvent(1, _SYSTEM_TIMER_EVENT_JUDGE_BATT_STATE);
 304   1        MCUTimerActiveTimerEvent(SEC(1), _SYSTEM_TIMER_EVENT_JUDGE_AC_MODE);
 305   1          MCUTimerActiveTimerEvent(1, _SYSTEM_TIMER_EVENT_JUDGE_BTH_STATE);
 306   1        MCUTimerActiveTimerEvent(1, _SYSTEM_TIMER_EVENT_GRN_BLINK);
 307   1        MCUTimerActiveTimerEvent(1, _SYSTEM_TIMER_EVENT_JUDGE_CHECK_AC_CABLE);
 308   1        MCUTimerActiveTimerEvent(SEC(10), _SYSTEM_TIMER_EVENT_REPLAY_REGULAR_DATA);
 309   1        MCUTimerActiveTimerEvent(SEC(10), _SYSTEM_TIMER_EVENT_CHECK_CHARGE_STATE);  //check charge
 310   1        SET_AC_PLUG();
 311   1      
 312   1      #if(_DEBUG_MESSAGE_WORKING_TIME == ON)
                MCUTimerActiveTimerEvent(SEC(10), _SYSTEM_TIMER_EVENT_SHOW_WORKING_TIMER);
              #endif
 315   1      
 316   1      }
 317          
 318          BYTE Mapping1( int fromValue, CODE_P struct RegisterInfo *fromRange,
 319                                           int * toValue, CODE_P struct RegisterInfo *toRange ){
 320   1      
 321   1        // calculate intermediate values
 322   1        int a;
 323   1        int b;
 324   1      
 325   1        // perform mapping
 326   1        if ( fromValue <= fromRange->Default ) {
 327   2          a = toRange->Default - toRange->Min;
 328   2          b = fromRange->Default - fromRange->Min;
 329   2          // prevent divide by zero
 330   2          if( b==0 )    return (FALSE);
 331   2          *toValue = (int) ( (DWORD)fromValue- (DWORD)fromRange->Min ) * a / b 
 332   2                  +(DWORD)toRange->Min;
 333   2        }
 334   1        else {
 335   2          a = toRange->Max - toRange->Default;
 336   2          b = fromRange->Max - fromRange->Default;
 337   2          // prevent divide by zero
 338   2          if( b==0 )    return (FALSE);
 339   2              *toValue = (int) ( (DWORD)fromValue - (DWORD)fromRange->Default ) * a / b
 340   2                             + (DWORD)toRange->Default;
 341   2        }
 342   1      
 343   1        return ( TRUE );
 344   1         
 345   1      }
 346          
 347          void SetAD5110Step(BYTE newv) 
 348          {
 349   1      
 350   1        int regv;
 351   1      
 352   1        Mapping1( newv, &UserRange , &regv, &AD5110Range);
 353   1        WriteAD5110(AD5110_CMD_Write_Data_To_RDAC ,AD5110_setp[regv]);
 354   1                  
 355   1      }
 356          
 357          void LoadEEPROM (void)
 358          {
 359   1         PowerFlag = ReadEEP(EEP_Powerflag);
 360   1         CameraVolt= ReadEEP(EEP_CameraVolt);
C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2021 14:24:37 PAGE 7   

 361   1         PWR_START_flag= ReadEEP(EEP_DC12_PWR_START);
 362   1        PowerOffToOnFlag= ReadEEP(EEP_PowerOffToOnflag);
 363   1      
 364   1        Encorder1= ((ReadEEP(EEP_Encorder1)>>4)*10)+(0x0f&ReadEEP(EEP_Encorder1));
 365   1        Decimal1= ((ReadEEP(EEP_Decimal1)>>4)*10)+(0x0f&ReadEEP(EEP_Decimal1));
 366   1      
 367   1        Encorder2= ((ReadEEP(EEP_Encorder2)>>4)*10)+(0x0f&ReadEEP(EEP_Encorder2));
 368   1        Decimal2= ((ReadEEP(EEP_Decimal2)>>4)*10)+(0x0f&ReadEEP(EEP_Decimal2));
 369   1      
 370   1        Encorder3= ((ReadEEP(EEP_Encorder3)>>4)*10)+(0x0f&ReadEEP(EEP_Encorder3));
 371   1        Decimal3= ((ReadEEP(EEP_Decimal3)>>4)*10)+(0x0f&ReadEEP(EEP_Decimal3));
 372   1      
 373   1        Encorder4= ((ReadEEP(EEP_Encorder4)>>4)*10)+(0x0f&ReadEEP(EEP_Encorder4));
 374   1        Decimal4= ((ReadEEP(EEP_Decimal4)>>4)*10)+(0x0f&ReadEEP(EEP_Decimal4));
 375   1      
 376   1        if(ReadEEP(EEP_LowBattery_Flag))
 377   1          SET_BATTERY_CAPACITY_LOW_FLAG();
 378   1      
 379   1        if(PWR_START_flag==ON)
 380   1        {
 381   2          if(PowerFlag==OFF)
 382   2          {
 383   3          WriteEEP(EEP_Powerflag,ON);
 384   3          PowerFlag=ON;
 385   3          }
 386   2          
 387   2          if(PowerOffToOnFlag==ON)
 388   2            {
 389   3            WriteEEP(EEP_PowerOffToOnflag,OFF);
 390   3            PowerOffToOnFlag=OFF;
 391   3            }
 392   2      
 393   2        } 
 394   1        else //PWR_START_flag==OFF
 395   1          {
 396   2            
 397   2            if(PowerOffToOnFlag==ON)
 398   2            {
 399   3            WriteEEP(EEP_Powerflag,ON);
 400   3            PowerFlag=ON;
 401   3      
 402   3            
 403   3            WriteEEP(EEP_PowerOffToOnflag,OFF);
 404   3            PowerOffToOnFlag=OFF;
 405   3            }
 406   2            else if(PowerFlag==ON)
 407   2              {
 408   3              WriteEEP(EEP_Powerflag,OFF);
 409   3              PowerFlag=OFF;        
 410   3              }
 411   2          }
 412   1      
 413   1      }
 414          
 415          WORD GetADCValue(BYTE sel)
 416          {
 417   1          
 418   1      ADCTL=0x80|0x08|sel;  //start adc sampling
 419   1      
 420   1      while(ADCTL&0x08);  // printf("ADC is busying\r\n");  //wating for adc
 421   1      
 422   1      return (WORD)(((ADCVL&0x03) |(ADCV<<2))&0x03ff);
C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2021 14:24:37 PAGE 8   

 423   1      
 424   1      }
 425          
 426          WORD GetBatteryBTH(void)
 427          {
 428   1      WORD max=0;
 429   1      max=GetADCValue(P16_BTH);
 430   1      //max=GetADCValue(P15_BTH);
 431   1      
 432   1      //max=850;
 433   1      
 434   1      return max;
 435   1      }
 436          
 437          WORD GetBatteryVoltage(void)
 438          {
 439   1      WORD max=0;
 440   1      max=GetADCValue(P17_BAT);
 441   1      
 442   1      //max=710;  //low
 443   1      //max=835;    //normal
 444   1      //max=900;  //full
 445   1      
 446   1      return max;
 447   1      }
 448          
 449          
 450          void EncorderHandler(void)
 451          {
 452   1      WORD EncorderCountTemp,temp_val;
 453   1      #if (HS_DEBUG==ON)
              WORD temp_EncorderCountTemp;
              #endif
 456   1      
 457   1      //BYTE param[4];
 458   1      float EncorderParaTemp1,EncorderParaTemp2,EncorderParaTemp3,EncorderParaTemp4;
 459   1      float EncorderOffset1,EncorderOffset2,EncorderOffset3/*,EncorderOffset4*/;
 460   1        
 461   1        if(ChangeKey)
 462   1        { 
 463   2          #if (HS_DEBUG==ON)
                  Printf("\r\nEncorderCount=%d",(WORD)EncorderCount);
                  #endif
 466   2          //Printf("\r\nEncorderLen_Offset0=%d ",(WORD)EncorderLen_Offset);
 467   2          //Printf("\r\nEncorderCountPN0=%d ",(WORD)EncorderCountPN);
 468   2          #if 1//ryan@20200430
 469   2      //    EncorderParaTemp1=(Encorder1+(Decimal1))*0.01f;
 470   2      //    EncorderParaTemp2=(Encorder2+(Decimal2))*0.01f;
 471   2      //    EncorderParaTemp3=(Encorder3+(Decimal3))*0.01f;
 472   2      //    EncorderParaTemp4=(Encorder4+(Decimal4))*0.01f;
 473   2          EncorderParaTemp1=(Encorder1+(Decimal1*0.01));
 474   2          EncorderParaTemp2=(Encorder2+(Decimal2*0.01));
 475   2          EncorderParaTemp3=(Encorder3+(Decimal3*0.01));
 476   2          EncorderParaTemp4=(Encorder4+(Decimal4*0.01));
 477   2      
 478   2          #else
                  EncorderParaTemp1=(Encorder1)*0.01f;
                  EncorderParaTemp2=(Encorder2)*0.01f;
                  EncorderParaTemp3=(Encorder3)*0.01f;
                  EncorderParaTemp4=(Encorder4)*0.01f;
                  #endif
 484   2          //EncorderParaTemp1=(Encorder1*0.01f)+Decimal1;
C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2021 14:24:37 PAGE 9   

 485   2          //EncorderParaTemp2=(Encorder2*0.01f)+Decimal2;
 486   2          //EncorderParaTemp3=(Encorder3*0.01f)+Decimal3;
 487   2          //EncorderParaTemp4=(Encorder4*0.01f)+Decimal4;
 488   2          
 489   2          #if 0
                  Printf("\r\nEncorder1=%d ",(WORD)Encorder1);
                  Printf("\r\nEncorder2=%d ",(WORD)Encorder2);
                  Printf("\r\nEncorder3=%d ",(WORD)Encorder3);
                  Printf("\r\nEncorder4=%d ",(WORD)Encorder4);
                  
                  Printf("\r\nEncorderParaTemp1=%d ",(WORD)(EncorderParaTemp1*100));
                  Printf("\r\nEncorderParaTemp2=%d ",(WORD)(EncorderParaTemp2*100));
                  Printf("\r\nEncorderParaTemp3=%d ",(WORD)(EncorderParaTemp3*100));
                  Printf("\r\nEncorderParaTemp4=%d ",(WORD)(EncorderParaTemp4*100));
                  #endif
 500   2          #if 0
                  EncorderOffset1=(30.625*EncorderParaTemp1*(240-EncorderLen_Offset))/1000;
                  EncorderOffset2=EncorderOffset1+(32.091*EncorderParaTemp2*(450-240-EncorderLen_Offset))/1000;
                  EncorderOffset3=EncorderOffset2+(33.504*EncorderParaTemp3*(780-450-EncorderLen_Offset)/1000);
                  //EncorderOffset4=EncorderOffset3+(33.504*((EncorderParaTemp3+EncorderParaTemp4)/2)*(780-600)/1000);
                  #else
 506   2          
 507   2          EncorderOffset1=(30.625*EncorderParaTemp1*240)/1000;
 508   2          EncorderOffset2=EncorderOffset1+(32.091*EncorderParaTemp2*(450-240))/1000;
 509   2          EncorderOffset3=EncorderOffset2+(33.504*EncorderParaTemp3*(780-450)/1000);
 510   2          #endif
 511   2          #if 0
                  Printf("\r\nEncorderOffset1=%d ",(WORD)(EncorderOffset1*100));
                  Printf("\r\nEncorderOffset2=%d ",(WORD)(EncorderOffset2*100));
                  Printf("\r\nEncorderOffset3=%d ",(WORD)(EncorderOffset3*100));
                  #endif
 516   2          //Printf("\r\nEncorderOffset4=%d ",(WORD)(EncorderOffset4*100));
 517   2          
 518   2          if(EncorderCount>=0)
 519   2            {
 520   3            EncorderCountPN=0;
 521   3            EncorderCountTemp=(EncorderCount/2);
 522   3            }
 523   2          else
 524   2            {
 525   3            EncorderCountPN=1;
 526   3            EncorderCountTemp=(0-EncorderCount)/2;
 527   3            }
 528   2          //EncorderCountTemp+=450;
 529   2          //EncorderCount
 530   2          #if 0
                  if(EncorderCount>=0)
                    EncorderCountPN=0;
                  else
                    EncorderCountPN=1;
                  #endif
 536   2          #if 0
                  if(EncorderCountTemp>EncorderLen_Offset)
                    {
                    EncorderCountPN=0;
                    temp_EncorderCountTemp=EncorderCountTemp-EncorderLen_Offset;
                    }
                  else
                    {
                    EncorderCountPN=1;
                    temp_EncorderCountTemp=EncorderLen_Offset-EncorderCountTemp;
                    }
C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2021 14:24:37 PAGE 10  

                  #endif
 548   2          if(EncorderCountTemp<=240&&EncorderCountTemp>=0)
 549   2            {
 550   3            
 551   3            #if (HS_DEBUG==ON)
                    Printf("\r\nEncorderCountTemp=%d ",(WORD)EncorderCountTemp);
                    Printf("\r\nEncorderLen_Offset=%d ",(WORD)EncorderLen_Offset);
                    Printf("\r\nEncorderCountPN=%d ",(WORD)EncorderCountPN);
                    #endif
 556   3            //if(EncorderCountPN==1)
 557   3            #if 0
                      EncorderLen=(30.625*EncorderParaTemp1*(temp_EncorderCountTemp))/1000;
                    #else
 560   3            EncorderLen=(30.625*EncorderParaTemp1*EncorderCountTemp)/1000;
 561   3            #endif
 562   3              //EncorderLen=(30.625*EncorderParaTemp1*(EncorderCountTemp-EncorderLen_Offset))/1000;
 563   3              
 564   3            //EncorderLen=(30.625*1*EncorderCountTemp)/1000;
 565   3            temp_val=30.625*EncorderParaTemp1*EncorderCountTemp;
 566   3            EncorderLenint=EncorderLen+0.05f;
 567   3            //Printf("\r\nEncorderLenTemp=%d ",(WORD)EncorderLenTemp);
 568   3            //EncorderLenint=EncorderLen;   
 569   3            #if (_2ND_DECIMAL==ON)//ryan@20200505
 570   3            EncorderLenfloaat=(EncorderLen+0.05)*100;
 571   3            EncorderLenfloaat%=100;
 572   3            #else
                    EncorderLenfloaat=(EncorderLen+0.05)*10;
                    EncorderLenfloaat%=10;
                    #endif
 576   3            #if 0
                    Printf("\r\nEncorderCountTemp=%d ",(WORD)EncorderCountTemp);
                    Printf("\r\nEncorderLen=%d ",(WORD)EncorderLen);
                    Printf("\r\nEncorderLenint=%d ",(WORD)EncorderLenint);      
                    Printf("\r\ntemp_val=%d ",(WORD)temp_val);
                    Printf("\r\nEncorderCount=%d ",(WORD)EncorderCount);
                    Printf("\r\nEncorderLenTemp=%d.%dm ",(WORD)EncorderLenint,(WORD)EncorderLenfloaat);
                    #endif
 584   3            }
 585   2          else if(EncorderCountTemp>240&&EncorderCountTemp<=450)
 586   2            {
 587   3        
 588   3            #if 0
                    EncorderLen=EncorderOffset1+(32.091*EncorderParaTemp2*(temp_EncorderCountTemp-(240-EncorderLen_Offset))
             -/1000);
                    #else
 591   3            EncorderLen=EncorderOffset1+(32.091*EncorderParaTemp2*(EncorderCountTemp-240)/1000);
 592   3            #endif
 593   3            
 594   3            #if (HS_DEBUG==ON)
                    Printf("\r\ntemp_EncorderCountTemp=%d ",(WORD)(temp_EncorderCountTemp-(240-EncorderLen_Offset)));
                    Printf("\r\nEncorderLen_Offset=%d ",(WORD)EncorderLen_Offset);
                    Printf("\r\ntemp_EncorderCountTemp=%d ",(WORD)temp_EncorderCountTemp);
                    Printf("\r\nEncorderLen=%d ",(WORD)EncorderLen);
                    //EncorderLen=7.35+(32.091*1*(EncorderCountTemp-240)/1000);
                    Printf("\r\nEncorderCount=%d ",(WORD)EncorderCount);
                    #endif
 602   3            EncorderLenint=EncorderLen+0.05f;     
 603   3            #if (HS_DEBUG==ON)
                    Printf("\r\nEncorderLenint=%d ",(WORD)EncorderLenint);
                    #endif
 606   3            //EncorderLenint=EncorderLen;
 607   3            #if (_2ND_DECIMAL==ON)//ryan@20200505
C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2021 14:24:37 PAGE 11  

 608   3            EncorderLenfloaat=(EncorderLen+0.05)*100;
 609   3            EncorderLenfloaat%=100;
 610   3            #else
                    EncorderLenfloaat=(EncorderLen+0.05)*10;
                    EncorderLenfloaat%=10;
                    #endif
 614   3            
 615   3            #if (HS_DEBUG==ON)
                    Printf("\r\nEncorderLenTemp=%d.%dm ",(WORD)EncorderLenint,(WORD)EncorderLenfloaat);
                    #endif      
 618   3            }
 619   2          #if 1
 620   2          else if(EncorderCountTemp>450&&EncorderCountTemp<=780)
 621   2            {
 622   3            #if 0
                    EncorderLen=EncorderOffset2+(33.504*1*(temp_EncorderCountTemp-(450-EncorderLen_Offset))/1000);
                    #else     
 625   3            EncorderLen=EncorderOffset2+(33.504*EncorderParaTemp3*(EncorderCountTemp-450)/1000);
 626   3            #endif
 627   3            
 628   3            #if (HS_DEBUG==ON)
                    Printf("\r\nEncorderCount=%d ",(WORD)EncorderCount);
                    #endif
 631   3            
 632   3            EncorderLenint=EncorderLen+0.05f;
 633   3            //Printf("\r\nEncorderLenTemp=%d ",(WORD)EncorderLenTemp);
 634   3            //EncorderLenint=EncorderLen;
 635   3            #if (_2ND_DECIMAL==ON)//ryan@20200505
 636   3            EncorderLenfloaat=(EncorderLen+0.05)*100;
 637   3            EncorderLenfloaat%=100;
 638   3            #else
                    EncorderLenfloaat=(EncorderLen+0.05)*10;
                    EncorderLenfloaat%=10;
                    #endif
 642   3            
 643   3            #if (HS_DEBUG==ON)
                    Printf("\r\nEncorderLenTemp=%d.%dm ",(WORD)EncorderLenint,(WORD)EncorderLenfloaat);
                    #endif
 646   3            }
 647   2          #else
                  else if(EncorderCountTemp>450&&EncorderCountTemp<=600)
                    {
                    EncorderLen=14.089+(33.504*EncorderParaTemp3*(EncorderCountTemp-450)/1000);
                    //EncorderLen=14.089+(33.504*1*(EncorderCountTemp-450)/1000);
                    Printf("\r\nEncorderCount=%d ",(WORD)EncorderCount);
              
                    EncorderLenint=EncorderLen+0.05f;
                    //Printf("\r\nEncorderLenTemp=%d ",(WORD)EncorderLenTemp);
                    //EncorderLenint=EncorderLen;
                    EncorderLenfloaat=(EncorderLen+0.05)*10;
                    EncorderLenfloaat%=10;
                    Printf("\r\nEncorderLenTemp=%d.%dm ",(WORD)EncorderLenint,(WORD)EncorderLenfloaat);
                    }   
                  else if(EncorderCountTemp>600&&EncorderCountTemp<=780)
                    {
                    EncorderLen=19.089+(33.504*((EncorderParaTemp3+EncorderParaTemp4)/2)*(EncorderCountTemp-600)/1000);
                    //EncorderLen=14.089+(33.504*1*(EncorderCountTemp-450)/1000);
                    Printf("\r\nEncorderCount=%d ",(WORD)EncorderCount);
              
                    EncorderLenint=EncorderLen+0.05f;
                    //Printf("\r\nEncorderLenTemp=%d ",(WORD)EncorderLenTemp);
                    //EncorderLenint=EncorderLen;
C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2021 14:24:37 PAGE 12  

                    EncorderLenfloaat=(EncorderLen+0.05)*10;
                    EncorderLenfloaat%=10;
                    Printf("\r\nEncorderLenTemp=%d.%dm ",(WORD)EncorderLenint,(WORD)EncorderLenfloaat);
                    }
                  #endif
 675   2          else if(EncorderCountTemp>780)
 676   2            {
 677   3            #if 0
                    EncorderLen=EncorderOffset3+(34.896*1*(EncorderCountTemp-(780-EncorderLen_Offset))/1000);
                    #else
 680   3            EncorderLen=EncorderOffset3+(34.896*EncorderParaTemp4*(EncorderCountTemp-780)/1000);
 681   3            #endif
 682   3      
 683   3            #if (HS_DEBUG==ON)  
                    Printf("\r\nEncorderCount=%d ",(WORD)EncorderCount);
              
                    Printf("\r\nEncorderLen=%d ",(WORD)EncorderLen);
                    #endif
 688   3            EncorderLenint=EncorderLen+0.05f;
 689   3            #if (HS_DEBUG==ON)
                    Printf("\r\nEncorderLenint=%d ",(WORD)EncorderLenint);
                    #endif
 692   3            //EncorderLenint=EncorderLen;
 693   3            #if (_2ND_DECIMAL==ON)//ryan@20200505
 694   3            EncorderLenfloaat=(EncorderLen+0.05)*100;
 695   3            #if (HS_DEBUG==ON)
                    Printf("\r\nEncorderLenfloaat=%d ",(WORD)EncorderLenfloaat);
                    #endif
 698   3            EncorderLenfloaat%=100;
 699   3            #if (HS_DEBUG==ON)    
                    Printf("\r\nEncorderLenTemp=%d.%dm ",(WORD)EncorderLenint,(WORD)EncorderLenfloaat);
                    #endif
 702   3            #else
                    EncorderLenfloaat=(EncorderLen+0.05)*10;
                    #if (HS_DEBUG==ON)
                    Printf("\r\nEncorderLenfloaat=%d ",(WORD)EncorderLenfloaat);
                    #endif
                    EncorderLenfloaat%=10;      
                    #if (HS_DEBUG==ON)
                    Printf("\r\nEncorderLenTemp=%d.%dm ",(WORD)EncorderLenint,(WORD)EncorderLenfloaat);
                    #endif
                    #endif      
 712   3            }
 713   2            
 714   2          ChangeKey=0;
 715   2          //param[0]=EncorderLenint;
 716   2          //param[1]=EncorderLenfloaat;
 717   2          //param[2]=EncorderCountPN;
 718   2          //protocol_send_cmd_with_param_num(0x0a, (BYTE *)param, 3);
 719   2          //protocol_send_cmd_with_param_num(0x80, (BYTE *)param, 3);
 720   2           if(GET_DVR_SystemReadyNotic()==_TRUE)
 721   2            {
 722   3           MCU_SendCmdToDVR(MCU_PROTOCOL_CMD_REGULAR_DATA);
 723   3            MCUTimerCancelTimerEvent( _SYSTEM_TIMER_EVENT_REPLAY_REGULAR_DATA);
 724   3            MCUTimerActiveTimerEvent(SEC(1), _SYSTEM_TIMER_EVENT_REPLAY_REGULAR_DATA);
 725   3            }
 726   2          #if (_DEBUG_EncorderHandler==ON)//ryan@20200505
                  Printf("\r\nEncorderLenint=%d ",(WORD)EncorderLenint);
                  Printf("\r\nEncorderLenfloaat=%d ",(WORD)EncorderLenfloaat);
                  #endif
 730   2        }
 731   1        //GetKey(0);
C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2021 14:24:37 PAGE 13  

 732   1      }
 733          
 734            //bit CCFL_status;  
 735          void main_loop(void)
 736          {
 737   1      
 738   1        Printf("\r\nStart Main Loop...");
 739   1        //---------------------------------------------------------------
 740   1        //                   Main Loop
 741   1        //---------------------------------------------------------------
 742   1        while(1) 
 743   1        {
 744   2      
 745   2          #if (_DEBUG_MESSAGE_Monitor==ON)
                  while( RS_ready() ) 
                    Monitor();        // for new monitor functions    
                  #endif      
 749   2      
 750   2          DvrReceivePaser();  
 751   2          SysTimerHandler();      
 752   2        //  SysJudgeHandler();  
 753   2          SysPowerHandler();  
 754   2          Scankey();
 755   2          EncorderHandler();
 756   2      
 757   2        
 758   2      
 759   2            if(PowerFlag==OFF)   //// POWEROFF
 760   2            break;
 761   2        
 762   2        }
 763   1      
 764   1      }
 765          
 766          void main(void)
 767          {
 768   1      
 769   1      InitCPU();
 770   1      
 771   1      SysPowerInitial();
 772   1      
 773   1      Printf("\r\nStart Boot...");
 774   1      
 775   1      main_init();
 776   1      
 777   1      //set panel 
 778   1      //select UP
 779   1      SET_P_IO1();
 780   1      //Select Left
 781   1      SET_P_IO2();
 782   1      
 783   1      //variable initialize
 784   1      InitVars();
 785   1      
 786   1      //load eeprom data
 787   1      LoadEEPROM();
 788   1      
 789   1      //event initialize
 790   1      InitialTimerEvent();
 791   1      
 792   1      SetAD5110Step(CameraVolt);
 793   1       Printf("\r\n(CameraVolt=%d)",(WORD)CameraVolt);
C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2021 14:24:37 PAGE 14  

 794   1      
 795   1      //if(PWR_START_flag==ON)
 796   1      //  PowerFlag=ON;
 797   1      
 798   1      if((GET_BATTERY_CAPACITY_LOW_FLAG()==_TRUE)&&(Check_ADAP_IN()==_FALSE))
 799   1        PowerFlag=OFF;
 800   1      
 801   1        if(PowerFlag==ON)
 802   1        SET_TARGET_POWER_STATUS(_POWER_STATUS_NORMAL);
 803   1      else
 804   1      {
 805   2        //UserInterfacePowerSwitch(_POWER_ACTION_AC_ON_TO_OFF);
 806   2        SET_POWER_STATUS(_POWER_STATUS_NORMAL); 
 807   2        SET_TARGET_POWER_STATUS(_POWER_STATUS_OFF);
 808   2        
 809   2      }
 810   1        RepeatKey=OFF;  
 811   1      //   SysJudgeStateChangeEvent(_MODE_STATUS_POWER_OFF);    
 812   1      
 813   1        while(1) {
 814   2          if(PowerFlag==ON)
 815   2          main_loop();    //exit when power off
 816   2          
 817   2          WaitPowerOn();
 818   2        }
 819   1      }
 820          
 821          void WaitPowerOn(void)
 822          {
 823   1      
 824   1        Printf("\r\n(Going to power off...)");
 825   1        SET_TARGET_POWER_STATUS(_POWER_STATUS_OFF);
 826   1      
 827   1        if(GET_DVR_EntrySleepMode()==TRUE)
 828   1          CLR_DVR_EntrySleepMode();
 829   1      
 830   1        CLR_DVR_SystemReadyNotic(); 
 831   1        MCUTimerCancelTimerEvent( _SYSTEM_TIMER_EVENT_JUDGE_WDT_ECHO);    
 832   1        CLR_DVR_Shutdown();
 833   1        MCUTimerCancelTimerEvent( _USER_TIMER_EVENT_OSD_DVR_SHUTDOWN);
 834   1      
 835   1        //CLR_BATTERY_CAPACITY_HIGH_FLAG();
 836   1        Power_down_mode=_DontgoingToPD;
 837   1        P3M1=0x00;//p3.4 and P3.5 set output ryan@20210226
 838   1        bytHoldOn3SPowerOff=OFF;
 839   1      
 840   1        while(1) 
 841   1        {
 842   2      
 843   2            
 844   2              #if (_DEBUG_MESSAGE_Monitor==ON)
                      while( RS_ready() ) 
                      Monitor();        // for new monitor functions    
                      #endif  
 848   2      
 849   2            SysPowerHandler();  
 850   2            SysTimerHandler();
 851   2            Scankey();
 852   2            
 853   2            if(PowerFlag==ON)   //// POWER-ON
 854   2            break;
 855   2      
C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2021 14:24:37 PAGE 15  

 856   2            #if (_POWER_DOWN_ENABLE==ON)
 857   2      
 858   2            if((Power_down_mode==_DontgoingToPD)&&(GET_POWER_STATUS()==_POWER_STATUS_OFF)&&(GET_AC_PLUG()/*Check_AD
             -AP_IN()*/==_FALSE))
 859   2            {
 860   3            Power_down_mode=_ReadyToPD;
 861   3            MCUTimerActiveTimerEvent(SEC(10), _SYSTEM_TIMER_POWER_DOWN_MODE);
 862   3            } 
 863   2            else if((Check_ADAP_IN()==_TRUE)||(((~P4>>3)& 0x01) ))
 864   2              {
 865   3              Power_down_mode=_DontgoingToPD;
 866   3              MCUTimerCancelTimerEvent( _SYSTEM_TIMER_POWER_DOWN_MODE);
 867   3              }
 868   2            else  if(Power_down_mode==_GoingToPD)
 869   2              SET_MCU_POWER_DOWN_MODE();        
 870   2      
 871   2            #endif  
 872   2            
 873   2        }
 874   1      
 875   1      
 876   1        WriteEEP(EEP_PowerOffToOnflag,ON);
 877   1        EncorderCount=0;
 878   1        EncorderLenint=0;
 879   1        EncorderLenfloaat=0;
 880   1        EncorderCountPN=0;
 881   1         RS2_in=0; //clean DVR CMD.
 882   1        RS2_out=0;//clean DVR CMD.
 883   1        //CLR_BATTERY_CAPACITY_LOW_FLAG();  
 884   1              CLR_BATTERY_ABNORMAL();
 885   1        SET_BATTERY_CHARGE_STATE(_BATT_STATUS_NONE);
 886   1        SET_TARGET_POWER_STATUS(_POWER_STATUS_NORMAL);  
 887   1        Printf("\r\n(Start up  Power On Mode...)");
 888   1      
 889   1        ISPCR = 0x20;/// reboot to AP.
 890   1      
 891   1      }
 892          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3578    ----
   CONSTANT SIZE    =    119    ----
   XDATA SIZE       =    113      94
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
