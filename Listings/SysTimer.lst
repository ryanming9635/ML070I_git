C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SYSTIMER
OBJECT MODULE PLACED IN .\Output\SysTimer.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE SysTimer.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Include) DEBUG OBJECT
                    -EXTEND PRINT(.\Listings\SysTimer.lst) TABS(2) OBJECT(.\Output\SysTimer.obj)

line level    source

   1          /*****************************************************************************/
   2          /*                                                                                              */
   3          /*  TELI ML070I   MCU                                             */
   4          /*                                                                                              */
   5          /*  SysTimer.c                                                                */
   6          /*                                                                                              */
   7          /*****************************************************************************/
   8          
   9          
  10          #include <math.h>
  11          #include <stdio.h>
  12          
  13          #include "Config.h"
  14          
  15          #include "reg.h"
  16          #include "typedefs.h"
  17          #include "main.h"
  18          #include "i2c.h"
  19          #include "adc.h"
  20          #include "etc_eep.h"
  21          #include "Printf.h"
  22          #include "KeyRemo.h"
  23          #include "Monitor.h"
  24          #include "CPU.h"
  25          #include "HS_DVRProtocol.h"
  26          
  27          
  28          //****************************************************************************
  29          // DEFINITIONS / MACROS
  30          //****************************************************************************
  31          #define GET_EVENT_VALID(x)                      (g_stTimerEvent[x].b1EventValid)
  32          #define SET_EVENT_VALID(x)                      (g_stTimerEvent[x].b1EventValid = _TRUE)
  33          #define CLR_EVENT_VALID(x)                      (g_stTimerEvent[x].b1EventValid = _FALSE)
  34          
  35          #define GET_EVENT_ID(x)                         (g_stTimerEvent[x].b7EventID)
  36          #define SET_EVENT_ID(x, y)                      (g_stTimerEvent[x].b7EventID = y)
  37          
  38          #define GET_EVENT_TIME(x)                       (g_stTimerEvent[x].usTime)
  39          #define SET_EVENT_TIME(x, y)                    (g_stTimerEvent[x].usTime = y)
  40          
  41          
  42          //****************************************************************************
  43          // VARIABLE DECLARATIONS
  44          //****************************************************************************
  45          bit g_bNotifyTimer0Int = _FALSE;
  46          volatile WORD  g_usTimerCounter = 0;
  47          StructTimerEventTableType g_stTimerEvent[_TIMER_EVENT_COUNT];
  48          WORD BatteryBTH=549/*156*//*650*//*880*/,BatteryVoltage=880;
  49          BYTE WDT_Echo_Count=0;
  50          BYTE STAT1_temp=OFF, STAT2_temp=ON,STAT1_Flag=OFF,STAT2_Flag=ON;
  51          
  52          BYTE BattDetect1_COUNT=0, BattDetect2_COUNT=0, BattDetect3_COUNT=0, BattDetect4_COUNT=0,BattDetect5_COUNT=
             -0;
  53          BYTE BattDetectMin_COUNT=0, BattDetectHigh_COUNT=0,BattDetectHighStop_COUNT=0,BattDetectNoStartUp_COUNT=0,
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 2   

             -BattDetectStartUp_COUNT=0;
  54          BYTE  BATERY_STAT=0xFF,BATERY_STAT_TEMP=0xFE;
  55          BYTE TEMP_NORMAL_COUNT=0,TEMP_LOW_COUNT=0, TEMP_LOW_WARN_COUNT=0, TEMP_HIGH_COUNT=0,TEMP_HIGH_WARN_COUNT=0
             -;
  56          BYTE TEMP_STAT=0xFF;
  57          BYTE PWM_TEMP=0;  
  58          BYTE CHARGE_TEMP_ABNORMAL=0;
  59          BYTE CHARGE_TEMP_NORMAL=0;
  60          
  61          #if (_DEBUG_MESSAGE_Monitor==ON)
              bit Monitor_flag=OFF;
              #endif
  64          
  65          extern BYTE PowerFlag;
  66          extern BYTE CameraVolt;
  67          extern BYTE PWR_START_flag;
  68          extern StructBatteryInfoType g_stBatteryInfo;
  69          extern BYTE EncorderCountPN;
  70          extern BYTE EncorderLenint;
  71          extern short EncorderCount;
  72          extern WORD EncorderLenfloaat;
  73          extern StructPowerInfoType idata g_stPowerInfo;
  74          extern BYTE day,hour,minute,second;
  75          extern StructDVRInfoType g_stDVRInfo;
  76          extern BYTE Power_down_mode;
  77          extern DWORD ulongRotateNumber;
  78          extern BYTE bytFastEncoderMode;
  79          
  80          
  81          //--------------------------------------------------
  82          // Definitions of Timer2
  83          //--------------------------------------------------
  84          #define _EVENT_TIME_MAX                         61000 // Please do not modify this value.
  85          
  86          //****************************************************************************
  87          // CODE TABLES
  88          //****************************************************************************
  89          
  90          
  91          //****************************************************************************
  92          // FUNCTION DECLARATIONS
  93          //****************************************************************************
  94          void SysTimerHandler(void);
  95          void SysTimerEventProc(EnumSystemTimerEventID enumEventID);
  96          void MCUTimerInitialTimerEvent(void);
  97          void MCUTimerActiveTimerEvent(WORD usTime, BYTE ucEventID);
  98          void MCUTimerCancelTimerEvent(BYTE ucEventID);
  99          void MCUTimerDelayXms(WORD usNum);
 100          extern WORD GetBatteryBTH(void);
 101          extern WORD GetBatteryVoltage(void);
 102          extern void SetAD5110Step(BYTE newv) ;
 103          extern void UserInterfacePowerSwitch(EnumPowerAction enumSwitch);
 104          extern void SysPowerSwitch(EnumPowerAction enumSwitch);
 105          extern void UserInterfaceBatteryChargeMode(EnumBatteryStatus enumSwitch);
 106          extern void SET_MCU_POWER_DOWN_MODE(void);
 107          
 108          
 109          //****************************************************************************
 110          // FUNCTION DEFINITIONS
 111          //****************************************************************************
 112          //--------------------------------------------------
 113          // Description  : Timer Delay
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 3   

 114          // Input Value  : usNum --> Delay in ms
 115          // Output Value : None
 116          //--------------------------------------------------
 117          void MCUTimerDelayXms(WORD usNum)
 118          {
 119   1          if(usNum)
 120   1          {
 121   2              g_bNotifyTimer0Int = _FALSE;
 122   2      
 123   2              while(_TRUE)
 124   2              {
 125   3                  if(g_bNotifyTimer0Int)
 126   3                  {
 127   4                      g_bNotifyTimer0Int = _FALSE;
 128   4      
 129   4                      if(--usNum)
 130   4                      {
 131   5                      }
 132   4                      else
 133   4                      {
 134   5                          return;
 135   5                      }
 136   4                  }
 137   3              }
 138   2          }
 139   1      }
 140          
 141          //--------------------------------------------------
 142          // Description  : Get Event Time
 143          // Input Value  : ucEventIndex --> Event which time is needed
 144          // Output Value : Event Time
 145          //--------------------------------------------------
 146          WORD MCUTimerGetEventTime(BYTE ucEventIndex)
 147          {
 148   1          return GET_EVENT_TIME(ucEventIndex);
 149   1      }
 150          
 151          //--------------------------------------------------
 152          // Description  : Get Event ID
 153          // Input Value  : Referenced Event Index
 154          // Output Value : Stored Event ID
 155          //--------------------------------------------------
 156          BYTE MCUTimerGetEventID(BYTE ucEventIndex)
 157          {
 158   1          return GET_EVENT_ID(ucEventIndex);
 159   1      }
 160          
 161          //--------------------------------------------------
 162          // Description  : Clear Event Time
 163          // Input Value  : ucEventIndex --> Event which time is needed to be cleared
 164          // Output Value : None
 165          //--------------------------------------------------
 166          
 167          
 168          void MCUTimerClrEventValid(BYTE ucEventIndex)
 169          {
 170   1          CLR_EVENT_VALID(ucEventIndex);
 171   1      }
 172          
 173          //--------------------------------------------------
 174          // Description  : Check if Event is Valid
 175          // Input Value  : ucEventIndex --> Event to be checked
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 4   

 176          // Output Value : Validity(_TRUE/_FALSE)
 177          //--------------------------------------------------
 178          bit MCUTimerCheckEventValid(BYTE ucEventIndex)
 179          {
 180   1          return GET_EVENT_VALID(ucEventIndex);;
 181   1      }
 182          
 183          //--------------------------------------------------
 184          // Description  : Get Timer Counter.
 185          // Input Value  : None
 186          // Output Value : Timer Counter
 187          //--------------------------------------------------
 188          WORD MCUTimerGetTimerCounter(void)
 189          {
 190   1          WORD usPresentTime = g_usTimerCounter;
 191   1         
 192   1          // When get counter,timer interrupt maybe change counter.
 193   1          // Get twice to avoid it.
 194   1          if(abs(g_usTimerCounter - usPresentTime) > 0x7F)
 195   1          {
 196   2              usPresentTime = g_usTimerCounter;
 197   2          } 
 198   1      
 199   1          return usPresentTime;
 200   1      }
 201          //--------------------------------------------------
 202          // Description  : Check timer and events. We have to run this function when setting up a timer for an even
             -t.
 203          // Input Value  : usTime    --> Unit in 1ms, range in 0.001 ~ 61sec
 204          // Output Value : Return usPresentTime
 205          //--------------------------------------------------
 206          WORD MCUTimerCheckTimerEvent(WORD usTime)
 207          {
 208   1          BYTE ucTimerEventCnt = 0;
 209   1          WORD usPresentTime = 0;
 210   1      
 211   1          usPresentTime = MCUTimerGetTimerCounter();
 212   1          
 213   1          if(usTime > _EVENT_TIME_MAX) 
 214   1          {
 215   2              usTime = _EVENT_TIME_MAX;
 216   2          }
 217   1         
 218   1          if(((usPresentTime + usTime) > _EVENT_TIME_MAX) || // Size Limit of Timer Counter             
 219   1             ((usPresentTime + usTime) < usPresentTime)) // Timer Counter Overflow
 220   1          { 
 221   2              g_usTimerCounter = 0;
 222   2          
 223   2              // Reset Timer Event Counter
 224   2              for(ucTimerEventCnt = 0; ucTimerEventCnt < _TIMER_EVENT_COUNT; ucTimerEventCnt++)
 225   2              {
 226   3                  if(GET_EVENT_VALID(ucTimerEventCnt) == _TRUE)
 227   3                  {
 228   4                      if(GET_EVENT_TIME(ucTimerEventCnt) > usPresentTime)
 229   4                      {
 230   5                          SET_EVENT_TIME(ucTimerEventCnt, (GET_EVENT_TIME(ucTimerEventCnt) - usPresentTime));
 231   5                      }
 232   4                      else
 233   4                      {
 234   5                          SET_EVENT_TIME(ucTimerEventCnt, 0);
 235   5                      }
 236   4                  }
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 5   

 237   3              }
 238   2              
 239   2              usPresentTime = 0;
 240   2          }    
 241   1      
 242   1          return usPresentTime;
 243   1      }
 244          
 245          //--------------------------------------------------
 246          // Description  : Initial timer and events. We have to run this function at firmware startup
 247          // Input Value  : None
 248          // Output Value : None
 249          //--------------------------------------------------
 250          void MCUTimerInitialTimerEvent(void)
 251          {
 252   1          BYTE ucTimerEventCnt = 0;
 253   1      
 254   1          for(ucTimerEventCnt = 0; ucTimerEventCnt < _TIMER_EVENT_COUNT; ucTimerEventCnt++)
 255   1          {
 256   2              CLR_EVENT_VALID(ucTimerEventCnt);
 257   2          }
 258   1      
 259   1         // TR2 = 1;
 260   1      }
 261          
 262          //--------------------------------------------------
 263          // Description  : Active Timer Event
 264          // Input Value  : usTime --> Time to active Timer Event
 265          //          ucEventID --> Event to be actived
 266          // Output Value : None
 267          //--------------------------------------------------
 268          void MCUTimerActiveTimerEvent(WORD usTime, BYTE ucEventID)
 269          {
 270   1          BYTE ucEventIndex = 0;
 271   1      
 272   1          // Search for Existing Event with the same Event ID
 273   1          for(ucEventIndex = 0; ucEventIndex < _TIMER_EVENT_COUNT; ucEventIndex++)
 274   1          {
 275   2              if(GET_EVENT_VALID(ucEventIndex) == _TRUE)
 276   2              {
 277   3                  if(GET_EVENT_ID(ucEventIndex) == ucEventID)
 278   3                  {
 279   4                      return;
 280   4                  }
 281   3              }
 282   2          }
 283   1      
 284   1          // Choose any Vacant Storage for Event
 285   1          for(ucEventIndex = 0; ucEventIndex < _TIMER_EVENT_COUNT; ucEventIndex++)
 286   1          {
 287   2              if(GET_EVENT_VALID(ucEventIndex) == _FALSE)
 288   2              {
 289   3                  SET_EVENT_VALID(ucEventIndex);
 290   3                  SET_EVENT_ID(ucEventIndex, ucEventID);
 291   3                  SET_EVENT_TIME(ucEventIndex, (WORD)((DWORD)(MCUTimerCheckTimerEvent(usTime)) + usTime));
 292   3                  return;
 293   3              }
 294   2          }
 295   1      
 296   1          //Printf("No More Available Storage for Simultaneous Event!!!!!!");
 297   1      }
 298          
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 6   

 299          //--------------------------------------------------
 300          // Description  : Cancel an event
 301          // Input Value  : Event     --> Event which we want to cancel
 302          // Output Value : None
 303          //--------------------------------------------------
 304          void MCUTimerCancelTimerEvent(BYTE ucEventID)
 305          {
 306   1          BYTE ucEventIndex = 0;
 307   1          
 308   1          // Search for Existing Event with the same Event ID
 309   1          for(ucEventIndex = 0; ucEventIndex < _TIMER_EVENT_COUNT; ucEventIndex++)
 310   1          {
 311   2              if(GET_EVENT_VALID(ucEventIndex) == _TRUE)
 312   2              {
 313   3                  if(GET_EVENT_ID(ucEventIndex) == ucEventID)
 314   3                  {
 315   4                      CLR_EVENT_VALID(ucEventIndex);
 316   4                      return;
 317   4                  }
 318   3              }
 319   2          }      
 320   1      }
 321          
 322          //--------------------------------------------------
 323          // Description  : Reactive a timer for an event. If the event is exist,
 324          //                this function will reset the executing time and restart.
 325          // Input Value  : usTime    --> Unit in 1ms, range in 0.01 ~ 61 sec
 326          //                Event     --> Execute Event while timeup
 327          // Output Value : None
 328          //--------------------------------------------------
 329          void MCUTimerReactiveTimerEvent(WORD usTime, BYTE ucEventID)
 330          {
 331   1          BYTE ucEventIndex = 0;
 332   1      
 333   1          // Search for Existing Event with the same Event ID
 334   1          for(ucEventIndex = 0; ucEventIndex < _TIMER_EVENT_COUNT; ucEventIndex++)
 335   1          {
 336   2              if(GET_EVENT_VALID(ucEventIndex) == _TRUE)
 337   2              {
 338   3                  if(GET_EVENT_ID(ucEventIndex) == ucEventID)
 339   3                  {
 340   4                      SET_EVENT_TIME(ucEventIndex, (WORD)((DWORD)(MCUTimerCheckTimerEvent(usTime)) + usTime));
 341   4                      return;
 342   4                  }
 343   3              }
 344   2          }    
 345   1      
 346   1          // Choose any Vacant Storage for Event
 347   1          for(ucEventIndex = 0; ucEventIndex < _TIMER_EVENT_COUNT; ucEventIndex++)
 348   1          {
 349   2              if(GET_EVENT_VALID(ucEventIndex) == _FALSE)
 350   2              {
 351   3                  SET_EVENT_VALID(ucEventIndex);
 352   3                  SET_EVENT_ID(ucEventIndex, ucEventID);
 353   3                  SET_EVENT_TIME(ucEventIndex, (WORD)((DWORD)(MCUTimerCheckTimerEvent(usTime)) + usTime));
 354   3                  return;
 355   3              }
 356   2          }   
 357   1      }
 358          
 359          
 360          void UserInterfaceTimerEventProc(BYTE ucEventID)
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 7   

 361          {
 362   1      
 363   1      switch(ucEventID)
 364   1      {
 365   2      
 366   2        case _USER_TIMER_EVENT_OSD_CAMERA_VOLTAGE_INC:
 367   2            SetAD5110Step(CameraVolt);
 368   2            WriteEEP(EEP_CameraVolt, CameraVolt);  
 369   2            #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                    GraphicsPrint(YELLOW,"(CAM_INC %d)",(WORD)(CameraVolt));  
                    #endif
 372   2              break;
 373   2      
 374   2        case _USER_TIMER_EVENT_OSD_CAMERA_VOLTAGE_DEC:
 375   2            SetAD5110Step(CameraVolt);  
 376   2            WriteEEP(EEP_CameraVolt, CameraVolt);  
 377   2            #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                    GraphicsPrint(YELLOW,"(CAM_DEC %d)",(WORD)(CameraVolt));  
                    #endif
 380   2            break;
 381   2              case _USER_TIMER_EVENT_OSD_SET_CAMERA_VOLTAGE:
 382   2            SetAD5110Step(CameraVolt);  
 383   2            WriteEEP(EEP_CameraVolt, CameraVolt);     
 384   2            #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                    GraphicsPrint(MAGENTA,"(CAM_VOLT_LEVEL=%d)",(WORD)(CameraVolt));  
                    #endif
 387   2            break;
 388   2              case _USER_TIMER_EVENT_OSD_GET_MCU_VERSION:
 389   2            MCU_SendCmdToDVR(MCU_PROTOCOL_CMD_REPLY_MCU_FW);  
 390   2            #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                    GraphicsPrint(YELLOW,"(GET_MCU_VERSION)");  
                    #endif
 393   2            break;
 394   2        case _USER_TIMER_EVENT_REPLY_ENCODER_COUNT:
 395   2            MCU_SendCmdToDVR(MCU_PROTOCOL_CMD_REPLY_ENCODER_COUNT); 
 396   2            #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                    GraphicsPrint(YELLOW,"(REPLY_ENCODER_COUNT)");  
                    #endif
 399   2            break;
 400   2        case _USER_TIMER_EVENT_RESET_ENCODER_COUNT:
 401   2            #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                    GraphicsPrint(YELLOW,"(RESET_ENCODER_COUNT)");  
                    #endif
 404   2            if(bytFastEncoderMode==ON)
 405   2              {
 406   3            WriteEEP(EEP_RotateNumberL,0);
 407   3            WriteEEP(EEP_RotateNumberM,0);
 408   3            WriteEEP(EEP_RotateNumberH,0);
 409   3            ulongRotateNumber=0;
 410   3              }
 411   2            else
 412   2              {
 413   3              WriteEEP(EEP_RotateNumberRL,0);
 414   3              WriteEEP(EEP_RotateNumberRM,0);
 415   3              WriteEEP(EEP_RotateNumberRH,0);
 416   3              ulongRotateNumber=0;
 417   3              }
 418   2            break;
 419   2        case _USER_TIMER_EVENT_OSD_DVR_FACTORY_MODE:
 420   2      
 421   2              if(GET_AC_PLUG()==_TRUE)
 422   2              {
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 8   

 423   3              MCU_SendCmdToDVR(MCU_PROTOCOL_CMD_ENTRY_FACTORY);     
 424   3              #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                      GraphicsPrint(RED,"(DVR_FACTORY_MODE)");  
                      #endif
 427   3              }
 428   2            #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                    else
                      {
                      GraphicsPrint(RED,"(DVR_FACTORY_FAIL)");      
                      }
                    #endif
 434   2            
 435   2            break;
 436   2      
 437   2             case _USER_TIMER_EVENT_OSD_MCU_ENTRY_SLEEP_MODE:
 438   2          
 439   2              if(GET_DVR_EntrySleepMode()==_FALSE)
 440   2              {
 441   3              SET_TARGET_POWER_STATUS(_POWER_STATUS_SAVING);
 442   3              SET_DVR_EntrySleepMode();
 443   3              #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                        GraphicsPrint(YELLOW,"(MCU_NORMAL_TO_SLEEP_MODE)");    
                      #endif        
 446   3              }
 447   2              break;
 448   2      
 449   2        case _USER_TIMER_EVENT_OSD_DISTANCE_RESET:
 450   2          EncorderCount=0;
 451   2          EncorderLenint=0;
 452   2          EncorderLenfloaat=0;
 453   2          EncorderCountPN=0;
 454   2          #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                  GraphicsPrint(YELLOW,"\r\n ClearEncorder ",0);
                  #endif
 457   2             //Printf("(DISTANCE_RESET)");   
 458   2             break;
 459   2      
 460   2         case _USER_TIMER_EVENT_OSD_DVR_REBOOT:
 461   2            #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                     GraphicsPrint(YELLOW,"(DVR_REBOOT)");  
                     #endif
 464   2              if(GET_DVR_Reboot()==_TRUE) 
 465   2                {
 466   3                CLR_DVR_Reboot();
 467   3                CLR_DVR_SystemReadyNotic();
 468   3                 UserInterfaceBatteryChargeMode(_BATT_STATUS_DVR_OFF);
 469   3                MCUTimerActiveTimerEvent(SEC(3), _USER_TIMER_EVENT_OSD_DVR_REBOOT);
 470   3      
 471   3                P3M1=0x00;//p3.4 and P3.5 set output ryan@20210226
 472   3                }
 473   2              else
 474   2              {
 475   3                 UserInterfaceBatteryChargeMode(_BATT_STATUS_DVR_ON);
 476   3              }
 477   2              break;
 478   2      
 479   2         case _USER_TIMER_EVENT_OSD_DVR_SHUTDOWN:
 480   2            #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                     GraphicsPrint(YELLOW,"(DVR_SHUTDOWN)");  
                    #endif
 483   2            SET_DVR_Shutdown();
 484   2            MCU_SendCmdToDVR(MCU_PROTOCOL_CMD_SYSTEM_SHUTDOWN);
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 9   

 485   2             MCUTimerActiveTimerEvent(SEC(15), _USER_TIMER_EVENT_OSD_DVR_SHUTDOWN);
 486   2             break;
 487   2      
 488   2            case  _USER_TIMER_EVENT_OSD_DVR_ENTER_ISP_MODE:
 489   2          #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                     GraphicsPrint(YELLOW,"(MCU_ENTER_ISP_MODE)");      
                  #endif
 492   2              enter_isp();
 493   2             break;
 494   2      
 495   2        case _USER_TIMER_EVENT_OSD_ENCODER_DEVIATION_SETTING:     
 496   2            #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                    GraphicsPrint(YELLOW,"(ENCODER_SET)");  
                    #endif
 499   2            break;
 500   2      
 501   2        case _USER_TIMER_EVENT_PANEL_BACKLIGHT_ON:
 502   2          SET_PWCTRL();
 503   2          #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                  GraphicsPrint(YELLOW,"(Panel_ON)"); 
                  #endif
 506   2             UserInterfacePowerSwitch(_POWER_ACTION_PANEL_POWER_ON);    
 507   2          break;
 508   2      
 509   2        case _USER_TIMER_EVENT_OSD_DVR_STOP_REBOOT:
 510   2          #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                  GraphicsPrint(YELLOW,"(DVR STOP REBOOT)");  
                  #endif
 513   2          break;
 514   2      
 515   2        #if (_DEBUG_MESSAGE_Monitor==ON)
                case _USER_TIMER_EVENT_Monitor_ON:
                 Monitor_flag=_FALSE;
                  break;
                #endif
 520   2      
 521   2         default:   break;
 522   2         
 523   2      
 524   2      }
 525   1        
 526   1      }
 527          
 528          //--------------------------------------------------
 529          // Description  : Timer Handler
 530          // Input Value  : None
 531          // Output Value : None
 532          //--------------------------------------------------
 533          void SysTimerHandler(void)
 534          {
 535   1          BYTE ucTimerEventIndex = 0;
 536   1          BYTE ucTimerEventID = 0;    
 537   1          WORD usPresentTime = 0;
 538   1      
 539   1          for(ucTimerEventIndex = 0; ucTimerEventIndex < _TIMER_EVENT_COUNT; ucTimerEventIndex++)
 540   1          {
 541   2              usPresentTime = MCUTimerGetTimerCounter();
 542   2      
 543   2              if(MCUTimerCheckEventValid(ucTimerEventIndex) == _FALSE)
 544   2              {
 545   3                  continue;
 546   3              }         
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 10  

 547   2              
 548   2              if(usPresentTime > MCUTimerGetEventTime(ucTimerEventIndex))
 549   2              {
 550   3                  MCUTimerClrEventValid(ucTimerEventIndex);
 551   3      
 552   3                  // Get Event ID From Event Index
 553   3                  ucTimerEventID = MCUTimerGetEventID(ucTimerEventIndex);
 554   3                  
 555   3                  if(ucTimerEventID < _USER_TIMER_EVENT_END)
 556   3                  {
 557   4                      UserInterfaceTimerEventProc(ucTimerEventID);
 558   4                      
 559   4                      continue;
 560   4                  }
 561   3      
 562   3                  if(ucTimerEventID < _SYSTEM_TIMER_EVENT_END)
 563   3                  {
 564   4                      SysTimerEventProc(ucTimerEventID);
 565   4                      
 566   4                      continue;
 567   4                  }
 568   3                  
 569   3               //   MCUTimerEventProc(ucTimerEventID);
 570   3              }
 571   2          }
 572   1      
 573   1      }
 574          
 575          //--------------------------------------------------
 576          // Description  : Timer Event Process
 577          // Input Value  : enumEventID --> Event to be processed
 578          // Output Value : None
 579          //--------------------------------------------------
 580          void SysTimerEventProc(EnumSystemTimerEventID enumEventID)
 581          {
 582   1      
 583   1      switch(enumEventID)
 584   1         { 
 585   2         case _SYSTEM_TIMER_EVENT_GRN_RED_OFF:
 586   2           PowerLED(_SYSTEM_TIMER_EVENT_GRN_RED_OFF);
 587   2        break;
 588   2      
 589   2         case _SYSTEM_TIMER_EVENT_GRN_ON_RED_OFF:
 590   2         PowerLED(_SYSTEM_TIMER_EVENT_GRN_ON_RED_OFF);
 591   2        break;
 592   2      
 593   2         case _SYSTEM_TIMER_EVENT_GRN_OFF_RED_ON: 
 594   2          PowerLED(_SYSTEM_TIMER_EVENT_GRN_OFF_RED_ON);
 595   2        break;
 596   2      
 597   2         case _SYSTEM_TIMER_EVENT_GRN_RED_ON:
 598   2            PowerLED(_SYSTEM_TIMER_EVENT_GRN_RED_ON);
 599   2          break;
 600   2      
 601   2         case _SYSTEM_TIMER_EVENT_GRN_BLINK:
 602   2           PowerLED(_SYSTEM_TIMER_EVENT_GRN_BLINK);
 603   2           MCUTimerActiveTimerEvent(SEC(0.25), _SYSTEM_TIMER_EVENT_GRN_BLINK);
 604   2          break;
 605   2      
 606   2         case _SYSTEM_TIMER_EVENT_GRN_2S_BLINK:
 607   2           PowerLED(_SYSTEM_TIMER_EVENT_GRN_BLINK);
 608   2           MCUTimerActiveTimerEvent(SEC(1), _SYSTEM_TIMER_EVENT_GRN_2S_BLINK);
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 11  

 609   2          break;
 610   2      
 611   2         case _SYSTEM_TIMER_EVENT_RED_BLINK:
 612   2           PowerLED(_SYSTEM_TIMER_EVENT_RED_BLINK);
 613   2           MCUTimerActiveTimerEvent(SEC(1), _SYSTEM_TIMER_EVENT_RED_BLINK);
 614   2      
 615   2          break;  
 616   2      
 617   2        case _SYSTEM_TIMER_EVENT_GRN_RED_BLINK:
 618   2           PowerLED(_SYSTEM_TIMER_EVENT_GRN_RED_BLINK);
 619   2           MCUTimerActiveTimerEvent(SEC(1), _SYSTEM_TIMER_EVENT_GRN_RED_BLINK);
 620   2      
 621   2         break; 
 622   2      
 623   2         case _SYSTEM_TIMER_EVENT_GRN_ON_RED_BLINK:
 624   2          PowerLED(_SYSTEM_TIMER_EVENT_GRN_ON_RED_BLINK);
 625   2          MCUTimerActiveTimerEvent(SEC(1), _SYSTEM_TIMER_EVENT_GRN_ON_RED_BLINK);
 626   2          break; 
 627   2          break;
 628   2      
 629   2         case _SYSTEM_TIMER_EVENT_GRN_2S_BLINK_RED_ON:
 630   2           PowerLED(_SYSTEM_TIMER_EVENT_GRN_2S_BLINK_RED_ON);
 631   2           MCUTimerActiveTimerEvent(SEC(1), _SYSTEM_TIMER_EVENT_GRN_2S_BLINK_RED_ON);
 632   2              break;
 633   2       case _SYSTEM_TIMER_EVENT_BATT_LOW_RED_BLINK:
 634   2        PowerLED(_SYSTEM_TIMER_EVENT_GRN_RED_OFF);
 635   2        PowerLED(_SYSTEM_TIMER_EVENT_GRN_OFF_RED_ON);
 636   2        MCUTimerDelayXms(500);
 637   2        PowerLED(_SYSTEM_TIMER_EVENT_GRN_RED_OFF);
 638   2        MCUTimerDelayXms(500);
 639   2      
 640   2        PowerLED(_SYSTEM_TIMER_EVENT_GRN_OFF_RED_ON);
 641   2        MCUTimerDelayXms(500);
 642   2        PowerLED(_SYSTEM_TIMER_EVENT_GRN_RED_OFF);
 643   2        MCUTimerDelayXms(500);
 644   2      
 645   2        PowerLED(_SYSTEM_TIMER_EVENT_GRN_OFF_RED_ON);
 646   2        MCUTimerDelayXms(500);
 647   2        PowerLED(_SYSTEM_TIMER_EVENT_GRN_RED_OFF);
 648   2        MCUTimerDelayXms(500);
 649   2      
 650   2        SET_BATTERY_CHARGE_STATE(_BATT_STATUS_NONE);//reset battery state.
 651   2        break;
 652   2        
 653   2         case _SYSTEM_TIMER_EVENT_JUDGE_CHECK_AC_CABLE:
 654   2        
 655   2          if(Check_ADAP_IN()==_TRUE)    
 656   2          {
 657   3            
 658   3                  if(GET_AC_PLUG()==_FALSE)
 659   3                  { 
 660   4          
 661   4                  if(MCUTimerCheckEventValid(_SYSTEM_TIMER_EVENT_JUDGE_BATT_MODE)==_TRUE)
 662   4                    {
 663   5                      #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                              GraphicsPrint(BLUE,"(AC1)");
                              #endif  
 666   5      
 667   5                    MCUTimerCancelTimerEvent( _SYSTEM_TIMER_EVENT_JUDGE_BATT_MODE);  
 668   5                    MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_JUDGE_BATT_MODE); 
 669   5                    }
 670   4          
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 12  

 671   4                  if(MCUTimerCheckEventValid(_SYSTEM_TIMER_EVENT_JUDGE_AC_MODE)==_TRUE)
 672   4                    {
 673   5                    MCUTimerCancelTimerEvent( _SYSTEM_TIMER_EVENT_JUDGE_AC_MODE);  
 674   5                    MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_JUDGE_AC_MODE); 
 675   5                    #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                            GraphicsPrint(BLUE,"(AC2)");
                            #endif  
 678   5                    }
 679   4          
 680   4                  }
 681   3            
 682   3          }
 683   2          else
 684   2            {
 685   3              if(GET_AC_PLUG()==_TRUE)
 686   3              {
 687   4                    if(MCUTimerCheckEventValid(_SYSTEM_TIMER_EVENT_JUDGE_BATT_MODE)==_TRUE)
 688   4                    {
 689   5                    MCUTimerCancelTimerEvent( _SYSTEM_TIMER_EVENT_JUDGE_BATT_MODE);  
 690   5                    MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_JUDGE_BATT_MODE); 
 691   5                    #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                            GraphicsPrint(BLUE,"(AC3)");
                            #endif
 694   5                    }
 695   4          
 696   4                  if(MCUTimerCheckEventValid(_SYSTEM_TIMER_EVENT_JUDGE_AC_MODE)==_TRUE)
 697   4                    {
 698   5                    #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                            GraphicsPrint(BLUE,"(AC4)");
                            #endif  
 701   5                    MCUTimerCancelTimerEvent( _SYSTEM_TIMER_EVENT_JUDGE_AC_MODE);  
 702   5                    MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_JUDGE_AC_MODE); 
 703   5                    }
 704   4              }
 705   3            }
 706   2                
 707   2            MCUTimerActiveTimerEvent(SEC(1), _SYSTEM_TIMER_EVENT_JUDGE_CHECK_AC_CABLE);   
 708   2            break;
 709   2       case _SYSTEM_TIMER_EVENT_REPLAY_REGULAR_DATA:
 710   2      
 711   2          if(GET_DVR_SystemReadyNotic()==_TRUE)          
 712   2           MCU_SendCmdToDVR(MCU_PROTOCOL_CMD_REGULAR_DATA);
 713   2          
 714   2           MCUTimerActiveTimerEvent(SEC(1), _SYSTEM_TIMER_EVENT_REPLAY_REGULAR_DATA);
 715   2           
 716   2        break;
 717   2        case _SYSTEM_TIMER_EVENT_POWER_OFF_ON_DELAY:
 718   2              #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                      GraphicsPrint(RED,"(CLR_DVR_PowerOFFDelay)");
                      #endif
 721   2            CLR_DVR_PowerOFFDelay();
 722   2          break;
 723   2          case _SYSTEM_TIMER_EVENT_JUDGE_FIRST_GET_BATT_BTH_STATE:
 724   2            #if (_DEBUG_MESSAGE_BATTERY_TEST)
                    #else
 726   2            BatteryVoltage=GetBatteryVoltage();
 727   2      //      BatteryBTH=GetBatteryBTH()+7;
 728   2            BatteryBTH=GetBatteryBTH();
 729   2            #endif
 730   2      
 731   2            if(BatteryVoltage<=BATTERY_CAPACITY_MIN) //<11.6V
 732   2              BATERY_STAT=_BATT_STATUS_CAPACITY_MIN;
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 13  

 733   2              else if((BatteryVoltage>BATTERY_CAPACITY_MIN)&&(BatteryVoltage<=BATTERY_CAPACITY_NO_STARTUP))
 734   2                BATERY_STAT=_BATT_STATUS_CAPACITY_NO_STARTUP;       
 735   2              else if((BatteryVoltage>BATTERY_CAPACITY_NO_STARTUP)&&(BatteryVoltage<=BATTERY_CAPACITY_LEVEL0))
 736   2                BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL0;
 737   2              else if((BatteryVoltage>BATTERY_CAPACITY_LEVEL0)&&(BatteryVoltage<=BATTERY_CAPACITY_LEVEL1))
 738   2                BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL1;
 739   2              else if((BatteryVoltage>BATTERY_CAPACITY_LEVEL1)&&(BatteryVoltage<=BATTERY_CAPACITY_LEVEL2))
 740   2                BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL2;
 741   2              else if((BatteryVoltage>BATTERY_CAPACITY_LEVEL2)&&(BatteryVoltage<=BATTERY_CAPACITY_LEVEL3))
 742   2                BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL3;
 743   2              else if((BatteryVoltage>BATTERY_CAPACITY_LEVEL3)&&(BatteryVoltage<=BATTERY_CAPACITY_HIGH))
 744   2                BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL4;
 745   2              else if((BatteryVoltage>BATTERY_CAPACITY_HIGH)&&(BatteryVoltage<=BATTERY_CAPACITY_HIGH_STOP)&&(PowerFl
             -ag==ON))
 746   2                BATERY_STAT=_BATT_STATUS_CAPACITY_MAX;
 747   2              else if((BatteryVoltage>BATTERY_CAPACITY_HIGH)&&(BatteryVoltage<=(BATTERY_CAPACITY_HIGH_STOP+9))&&(Pow
             -erFlag==OFF))
 748   2                BATERY_STAT=_BATT_STATUS_CAPACITY_MAX;
 749   2              else          
 750   2                BATERY_STAT=_BATT_STATUS_CAPACITY_MAX_STOP;
 751   2      
 752   2            SET_BATTERY_STATE(BATERY_STAT);
 753   2          
 754   2            SET_BATTERY_CAPACITY(BatteryVoltage);
 755   2      
 756   2      
 757   2            if((BatteryBTH<=BTH_TEMP_HIGH)&&(BatteryBTH>BTH_TEMP_MIN)) //High temperature.
 758   2              TEMP_STAT=_BATT_STATUS_TEMP_HIGH;
 759   2              else if((BatteryBTH>BTH_TEMP_HIGH)&&(BatteryBTH<=BTH_TEMP_HIGH_WARN))//50~55 warnning
 760   2                TEMP_STAT=_BATT_STATUS_TEMP_HIGH_WARN;
 761   2              else if((BatteryBTH>BTH_TEMP_HIGH_WARN)&&(BatteryBTH<=BTH_TEMP_LOW_WARN))
 762   2                TEMP_STAT=_BATT_STATUS_TEMP_NORMAL;
 763   2              else if((BatteryBTH>BTH_TEMP_LOW_WARN)&&(BatteryBTH<=BTH_TEMP_LOW))  //0~-5 warnning
 764   2                TEMP_STAT=_BATT_STATUS_TEMP_LOW_WARN;
 765   2              else if((BatteryBTH>BTH_TEMP_LOW)&&(BatteryBTH<=BATTERY_ACD_no_battery)) /// if(BatteryBTH>BTH_TEMP_LO
             -W)  //-5~-10 warnning
 766   2                TEMP_STAT=_BATT_STATUS_TEMP_LOW;
 767   2              else{
 768   3                SET_NO_BATTERY();
 769   3                SET_BATTERY_STATE(_BATT_STATUS_NO_BATT);
 770   3                TEMP_STAT=_BATT_STATUS_TEMP_NORMAL; ///no DC12V input
 771   3                }
 772   2      
 773   2              if(GET_BATTERY_CHARGE_STATE()==_BATT_STATUS_NO_BATT)  
 774   2              TEMP_STAT=_BATT_STATUS_TEMP_NORMAL;
 775   2      
 776   2              SET_BTH_STATE(TEMP_STAT); 
 777   2      
 778   2              STAT1_temp=GET_STAT1(); 
 779   2              if(STAT1_Flag!=STAT1_temp)
 780   2              STAT1_Flag=STAT1_temp;
 781   2                    
 782   2              STAT2_temp=GET_STAT2(); 
 783   2              if(STAT2_Flag!=STAT2_temp)
 784   2              STAT2_Flag=STAT2_temp;        
 785   2      
 786   2            /*
 787   2            if((BatteryBTH<=CHARGE_TEMP_HIGH)&&(BatteryBTH>CHARGE_TEMP_LOW))  
 788   2              {
 789   2              if(GET_AC_PLUG()==_TRUE)  
 790   2                SET_CHARGE_TMEP_ABNORMAL();
 791   2      
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 14  

 792   2              if(GET_BATTERY_CHARGE_STATE()==_BATT_STATUS_NO_BATT)  
 793   2                    CLR_CHARGE_TMEP_ABNORMAL();
 794   2              }
 795   2            */
 796   2            break;
 797   2          case _SYSTEM_TIMER_EVENT_JUDGE_BATT_STATE:  
 798   2      
 799   2          #if (_DEBUG_MESSAGE_BATTERY_TEST)
                  #else
 801   2            BatteryVoltage=GetBatteryVoltage();
 802   2          #endif
 803   2          
 804   2            #if 1
 805   2          SET_BATTERY_CAPACITY(BatteryVoltage);
 806   2            
 807   2      //   if((GET_BATTERY_CAPACITY()<200)||(BatteryBTH>=935)) //no battery  <3.3V
 808   2      //     if(((GET_BATTERY_CAPACITY()<BATTERY_ACD_MIN)||(STAT1_Flag==1))&&(GET_AC_PLUG()==_TRUE)) //no battery
             -  <3.3V
 809   2      /*     if((GET_BATTERY_CAPACITY()<BATTERY_ACD_MIN)&&(GET_AC_PLUG()==_TRUE)) //no battery  <3.3V
 810   2              {
 811   2            SET_NO_BATTERY();
 812   2            SET_BATTERY_STATE(_BATT_STATUS_NO_BATT); 
 813   2              }
 814   2          else 
 815   2          */  
 816   2          {
 817   3            if(GET_NO_BATTERY()==_TRUE)
 818   3              {
 819   4              BattDetect1_COUNT=0;
 820   4              BattDetect2_COUNT=0;
 821   4              BattDetect3_COUNT=0;
 822   4              BattDetect4_COUNT=0;
 823   4              BattDetect5_COUNT=0;
 824   4              BattDetectMin_COUNT=0;
 825   4              BattDetectHigh_COUNT=0;
 826   4              BattDetectHighStop_COUNT=0;
 827   4              BattDetectNoStartUp_COUNT=0;
 828   4              BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL4;
 829   4              }
 830   3              #if (_DEBUG_MESSAGE_Power_Supply_TEST==ON)
                      CLR_NO_BATTERY(); 
                      #endif
 833   3            if(BatteryVoltage<=BATTERY_CAPACITY_MIN) //<11.6V
 834   3            {
 835   4                  BattDetect1_COUNT=0;
 836   4                  BattDetect2_COUNT=0;
 837   4              BattDetect3_COUNT=0;
 838   4              BattDetect4_COUNT=0;
 839   4              BattDetect5_COUNT=0;              
 840   4              BattDetectMin_COUNT++;
 841   4              BattDetectHigh_COUNT=0;
 842   4              BattDetectHighStop_COUNT=0;
 843   4              BattDetectNoStartUp_COUNT=0;
 844   4            }
 845   3            else if((BatteryVoltage>BATTERY_CAPACITY_MIN)&&(BatteryVoltage<=BATTERY_CAPACITY_NO_STARTUP))
 846   3            {
 847   4            //_BATT_STATUS_CAPACITY_NO_STARTUP
 848   4                  BattDetect1_COUNT=0;
 849   4                  BattDetect2_COUNT=0;
 850   4              BattDetect3_COUNT=0;
 851   4              BattDetect4_COUNT=0;
 852   4              BattDetect5_COUNT=0;              
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 15  

 853   4              BattDetectMin_COUNT=0;
 854   4              BattDetectHigh_COUNT=0;
 855   4              BattDetectHighStop_COUNT=0;               
 856   4              BattDetectNoStartUp_COUNT++;
 857   4            } 
 858   3            else if((BatteryVoltage>BATTERY_CAPACITY_NO_STARTUP)&&(BatteryVoltage<=BATTERY_CAPACITY_LEVEL0))
 859   3            {
 860   4            //_BATT_STATUS_CAPACITY_LEVEL0
 861   4                  BattDetect1_COUNT++;
 862   4                  BattDetect2_COUNT=0;
 863   4              BattDetect3_COUNT=0;
 864   4              BattDetect4_COUNT=0;
 865   4              BattDetect5_COUNT=0;              
 866   4              BattDetectMin_COUNT=0;
 867   4              BattDetectHigh_COUNT=0;
 868   4              BattDetectHighStop_COUNT=0;               
 869   4              BattDetectNoStartUp_COUNT=0;
 870   4            }     
 871   3            else if((BatteryVoltage>BATTERY_CAPACITY_LEVEL0)&&(BatteryVoltage<=BATTERY_CAPACITY_LEVEL1))
 872   3            {
 873   4              // _BATT_STATUS_CAPACITY_LEVEL1
 874   4                BattDetect1_COUNT=0;
 875   4                    BattDetect2_COUNT++;
 876   4              BattDetect3_COUNT=0;
 877   4              BattDetect4_COUNT=0;
 878   4              BattDetect5_COUNT=0;
 879   4              BattDetectMin_COUNT=0;
 880   4              BattDetectHigh_COUNT=0;
 881   4              BattDetectNoStartUp_COUNT=0;
 882   4              
 883   4            }
 884   3            else if((BatteryVoltage>BATTERY_CAPACITY_LEVEL1)&&(BatteryVoltage<=BATTERY_CAPACITY_LEVEL2))
 885   3            {
 886   4            //_BATT_STATUS_CAPACITY_LEVEL2
 887   4                BattDetect1_COUNT=0;
 888   4                    BattDetect2_COUNT=0;
 889   4              BattDetect3_COUNT++;
 890   4              BattDetect4_COUNT=0;
 891   4              BattDetect5_COUNT=0;
 892   4              BattDetectMin_COUNT=0;
 893   4              BattDetectHigh_COUNT=0;
 894   4              BattDetectHighStop_COUNT=0;
 895   4              BattDetectNoStartUp_COUNT=0;
 896   4              
 897   4            }
 898   3            else if((BatteryVoltage>BATTERY_CAPACITY_LEVEL2)&&(BatteryVoltage<=BATTERY_CAPACITY_LEVEL3))
 899   3            {
 900   4              //_BATT_STATUS_CAPACITY_LEVEL3
 901   4                BattDetect1_COUNT=0;
 902   4                  BattDetect2_COUNT=0;
 903   4              BattDetect3_COUNT=0;
 904   4              BattDetect4_COUNT++;
 905   4              BattDetect5_COUNT=0;
 906   4              BattDetectMin_COUNT=0;
 907   4              BattDetectHigh_COUNT=0;
 908   4              BattDetectHighStop_COUNT=0;
 909   4              BattDetectNoStartUp_COUNT=0;
 910   4              
 911   4            }
 912   3            else if((BatteryVoltage>BATTERY_CAPACITY_LEVEL4)&&(BatteryVoltage<=BATTERY_CAPACITY_HIGH))
 913   3            {
 914   4              //_BATT_STATUS_CAPACITY_LEVEL4
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 16  

 915   4                BattDetect1_COUNT=0;
 916   4              BattDetect2_COUNT=0;
 917   4              BattDetect3_COUNT=0;
 918   4              BattDetect4_COUNT=0;
 919   4              BattDetect5_COUNT++;
 920   4              BattDetectMin_COUNT=0;
 921   4              BattDetectHigh_COUNT=0;
 922   4              BattDetectHighStop_COUNT=0;
 923   4              BattDetectNoStartUp_COUNT=0;
 924   4              
 925   4          
 926   4            }
 927   3            else if((BatteryVoltage>BATTERY_CAPACITY_HIGH)&&(BatteryVoltage<=BATTERY_CAPACITY_HIGH_STOP)&&(PowerFla
             -g==ON))      
 928   3            {
 929   4              BattDetect1_COUNT=0;
 930   4              BattDetect2_COUNT=0;
 931   4              BattDetect3_COUNT=0;
 932   4              BattDetect4_COUNT=0;
 933   4              BattDetect5_COUNT=0;
 934   4              BattDetectMin_COUNT=0;
 935   4              BattDetectHigh_COUNT++; 
 936   4              BattDetectHighStop_COUNT=0;
 937   4              BattDetectNoStartUp_COUNT=0;
 938   4              
 939   4            }
 940   3            else if((BatteryVoltage>BATTERY_CAPACITY_HIGH)&&(BatteryVoltage<=(BATTERY_CAPACITY_HIGH_STOP+9))&&(Powe
             -rFlag==OFF))      
 941   3            {
 942   4              BattDetect1_COUNT=0;
 943   4              BattDetect2_COUNT=0;
 944   4              BattDetect3_COUNT=0;
 945   4              BattDetect4_COUNT=0;
 946   4              BattDetect5_COUNT=0;
 947   4              BattDetectMin_COUNT=0;
 948   4              BattDetectHigh_COUNT++; 
 949   4              BattDetectHighStop_COUNT=0;
 950   4              BattDetectNoStartUp_COUNT=0;
 951   4              
 952   4            }
 953   3            else///>BATTERY_CAPACITY_HIGH_STOP
 954   3            {
 955   4              BattDetect1_COUNT=0;
 956   4              BattDetect2_COUNT=0;
 957   4              BattDetect3_COUNT=0;
 958   4              BattDetect4_COUNT=0;
 959   4              BattDetect5_COUNT=0;
 960   4              BattDetectMin_COUNT=0;
 961   4              BattDetectHigh_COUNT=0; 
 962   4              BattDetectHighStop_COUNT++;
 963   4              BattDetectNoStartUp_COUNT=0;
 964   4            }
 965   3      
 966   3            if(BatteryVoltage>=BATTERY_CAPACITY_STARTUP)
 967   3            BattDetectStartUp_COUNT++;
 968   3            else    
 969   3            BattDetectStartUp_COUNT=0;
 970   3            
 971   3            if(BattDetect1_COUNT==20)
 972   3            {
 973   4              BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL0;
 974   4              BattDetect1_COUNT=0;
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 17  

 975   4            }
 976   3            if(BattDetect2_COUNT==20)
 977   3            {
 978   4              BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL1;
 979   4              BattDetect2_COUNT=0;
 980   4            }
 981   3            if(BattDetect3_COUNT==20)
 982   3            {
 983   4              BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL2;
 984   4              BattDetect3_COUNT=0;
 985   4            }
 986   3            if(BattDetect4_COUNT==20)
 987   3            {
 988   4              BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL3;
 989   4              BattDetect4_COUNT=0;
 990   4            }
 991   3            if(BattDetect5_COUNT==20)
 992   3            {
 993   4              BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL4;
 994   4              BattDetect5_COUNT=0;
 995   4            }
 996   3      
 997   3            if(BattDetectMin_COUNT==20)
 998   3            {
 999   4            BATERY_STAT=_BATT_STATUS_CAPACITY_MIN;
1000   4            BattDetectMin_COUNT=0;
1001   4            }
1002   3            
1003   3            if(BattDetectHigh_COUNT==20)
1004   3            {
1005   4            BATERY_STAT=_BATT_STATUS_CAPACITY_MAX;
1006   4            BattDetectHigh_COUNT=0;
1007   4            }
1008   3      
1009   3            if(BattDetectNoStartUp_COUNT==20)
1010   3            {
1011   4            BATERY_STAT=_BATT_STATUS_CAPACITY_NO_STARTUP;
1012   4            BattDetectNoStartUp_COUNT=0;
1013   4            }
1014   3      
1015   3                if(BattDetectHigh_COUNT==20)
1016   3                {
1017   4                BATERY_STAT=_BATT_STATUS_CAPACITY_MAX;
1018   4                BattDetectHigh_COUNT=0;
1019   4                }
1020   3      
1021   3              if(BattDetectHighStop_COUNT==20)
1022   3              {
1023   4              BATERY_STAT=_BATT_STATUS_CAPACITY_MAX_STOP;
1024   4              BattDetectHighStop_COUNT=0;
1025   4              }
1026   3      
1027   3              if(BATERY_STAT_TEMP!=BATERY_STAT)
1028   3              {
1029   4              BATERY_STAT_TEMP=BATERY_STAT;
1030   4              SET_BATTERY_CHARGE_STATE(_BATT_STATUS_NONE);//reset battery state. 
1031   4              }
1032   3      
1033   3            if(BattDetectStartUp_COUNT==20)
1034   3            { 
1035   4              if(GET_BATTERY_CAPACITY_LOW_FLAG()==_TRUE)
1036   4                {
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 18  

1037   5                #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                         GraphicsPrint(RED,"(Normal Voltage Charge >12.5V)");
                        #endif
1040   5                CLR_BATTERY_CAPACITY_LOW_FLAG();
1041   5                SET_BATTERY_CHARGE_STATE(_BATT_STATUS_NONE);//reset battery state.  
1042   5      
1043   5                  if(ReadEEP(EEP_LowBattery_Flag))
1044   5                    WriteEEP(EEP_LowBattery_Flag,OFF);
1045   5                }
1046   4              
1047   4            BattDetectStartUp_COUNT=0;
1048   4            }
1049   3      
1050   3            SET_BATTERY_STATE(BATERY_STAT);
1051   3        }
1052   2          //#if (_DEBUG_MESSAGE_SysTimerEvent==ON)
1053   2          //GraphicsPrint(CYAN,">");
1054   2          //#endif
1055   2              if(PowerFlag==OFF)
1056   2              MCUTimerActiveTimerEvent(SEC(0.1/*1*/), _SYSTEM_TIMER_EVENT_JUDGE_BATT_STATE);
1057   2              else
1058   2          MCUTimerActiveTimerEvent(SEC(0.3/*1*/), _SYSTEM_TIMER_EVENT_JUDGE_BATT_STATE);
1059   2            #else
                    SET_BATTERY_CAPACITY(BatteryVoltage);
                
                      
                     if((GET_BATTERY_CAPACITY()<200)||(BatteryBTH>=935)) //no battery  <3.3V
                      {
                    SET_NO_BATTERY();
                    SET_BATTERY_STATE(_BATT_STATUS_NO_BATT); 
                      }
                  else 
                    {
                    CLR_NO_BATTERY();   
                    
                  if(GET_BATTERY_CAPACITY()<=BATTERY_CAPACITY_LEVEL0)//<12V
                       SET_BATTERY_STATE(_BATT_STATUS_CAPACITY_LEVEL0);        
                  else if((GET_BATTERY_CAPACITY()>BATTERY_CAPACITY_LEVEL0)&&(GET_BATTERY_CAPACITY()<=BATTERY_CAPACITY_LEVE
             -L1))//12V-13.5V
                    SET_BATTERY_STATE(_BATT_STATUS_CAPACITY_LEVEL1);      
                  else if((GET_BATTERY_CAPACITY()>BATTERY_CAPACITY_LEVEL1)&&(GET_BATTERY_CAPACITY()<=BATTERY_CAPACITY_LEVE
             -L2))//14.2V-13.5V
                    SET_BATTERY_STATE(_BATT_STATUS_CAPACITY_LEVEL2);
                  else if((GET_BATTERY_CAPACITY()>BATTERY_CAPACITY_LEVEL2)&&(GET_BATTERY_CAPACITY()<=BATTERY_CAPACITY_LEVE
             -L3))//15V-14.2V
                    SET_BATTERY_STATE(_BATT_STATUS_CAPACITY_LEVEL3);  
                  else    
                    SET_BATTERY_STATE(_BATT_STATUS_CAPACITY_LEVEL4);//>15V
                    }   
              
                  MCUTimerActiveTimerEvent(SEC(5), _SYSTEM_TIMER_EVENT_JUDGE_BATT_STATE);
              
                  #endif
1087   2      
1088   2          break;
1089   2      
1090   2          case _SYSTEM_TIMER_EVENT_JUDGE_PSW_STATE:
1091   2          #if (_DEBUG_MESSAGE_Scankey_CHECK==ON)
                  GraphicsPrint(CYAN,"\r\nPOWER key pressed");
                  #endif
1094   2      
1095   2            if(GET_DVR_EntrySleepMode()==_TRUE)
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 19  

1096   2            {
1097   3              SET_TARGET_POWER_STATUS(_POWER_STATUS_NORMAL);
1098   3              //CLR_DVR_EntrySleepMode();
1099   3              //MCU_SendCmdToDVR(MCU_PROTOCOL_CMD_SLEEP_WAKE_UP);
1100   3              #if (_DEBUG_MESSAGE_Scankey_CHECK==ON)
                        GraphicsPrint(YELLOW,"(MCU_SLEEP_TO_NORMAL_MODE)");    
                      #endif        
1103   3      
1104   3            }
1105   2            #if 0 //for test
                    else if(PowerFlag==ON)    
                      {
                    MCUTimerActiveTimerEvent(SEC(0.1), _USER_TIMER_EVENT_OSD_DVR_SHUTDOWN);
                    PowerFlag=OFF;
                    WriteEEP(EEP_Powerflag,PowerFlag);
                      }
                    #else
1113   2            else if(PowerFlag==ON)    
1114   2            MCUTimerActiveTimerEvent(SEC(0.1), _USER_TIMER_EVENT_OSD_DVR_SHUTDOWN);
1115   2            #endif
1116   2            else
1117   2            {
1118   3                if(GET_DVR_PowerOFFDelay()==_FALSE)
1119   3                {
1120   4                  if((GET_BATTERY_CAPACITY_LOW_FLAG()==_FALSE)||(Check_ADAP_IN()/*GET_AC_PLUG()*/==_TRUE))
1121   4                  {
1122   5                  PowerFlag=ON;
1123   5                  WriteEEP(EEP_Powerflag,PowerFlag);
1124   5                  }
1125   4                  else
1126   4                    {
1127   5                    #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                            GraphicsPrint(RED,"\r\n(Battery voltage low <12.5V...)");
                            #endif
1130   5                    MCUTimerActiveTimerEvent(SEC(0.01), _SYSTEM_TIMER_EVENT_BATT_LOW_RED_BLINK);
1131   5                    }
1132   4                  
1133   4                #if (_DEBUG_MESSAGE_Scankey_CHECK==ON)
                        if(PWR_START_flag==ON)
                            GraphicsPrint(YELLOW,"(DC12V to Power on)");    
                        #endif
1137   4                }
1138   3                else
1139   3                MCUTimerActiveTimerEvent(SEC(3), _SYSTEM_TIMER_EVENT_JUDGE_PSW_STATE);
1140   3                
1141   3            }
1142   2          
1143   2            break;
1144   2      case _SYSTEM_TIMER_EVENT_BATTERY_LOW_PWR_OFF:
1145   2           if(PowerFlag==ON)  
1146   2          MCUTimerActiveTimerEvent(SEC(0.1), _USER_TIMER_EVENT_OSD_DVR_SHUTDOWN);
1147   2        break;
1148   2          case _SYSTEM_TIMER_EVENT_JUDGE_BTH_STATE:
1149   2        
1150   2          #if (_DEBUG_MESSAGE_BATTERY_TEST)
                  #else
1152   2          BatteryBTH=GetBatteryBTH();
1153   2      
1154   2      //    if(GET_BATTERY_CHARGE_STATE()==_BATT_STATUS_NO_BATT)
1155   2      //      BatteryBTH=549;
1156   2          #endif
1157   2          
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 20  

1158   2          //if((GET_BATTERY_CHARGE_STATE()==_BATT_STATUS_STOP_CHARGE)&&(GET_BTH_STATE()==_BATT_STATUS_TEMP_NORMAL)
             -)
1159   2          //SET_BTH_STATE(_BATT_STATUS_TEMP_NORMAL);
1160   2          //else
1161   2          //{
1162   2      
1163   2          #if 1
1164   2          if((BatteryBTH<=BTH_TEMP_HIGH)&&(BatteryBTH>BTH_TEMP_MIN)) //<11.6V
1165   2            {     
1166   3            TEMP_NORMAL_COUNT=0;
1167   3              TEMP_LOW_COUNT=0;
1168   3            TEMP_LOW_WARN_COUNT=0;
1169   3            TEMP_HIGH_COUNT++;
1170   3            TEMP_HIGH_WARN_COUNT=0;
1171   3            }
1172   2            else if((BatteryBTH>BTH_TEMP_HIGH)&&(BatteryBTH<=BTH_TEMP_HIGH_WARN))//50~55 warnning
1173   2            {
1174   3            TEMP_NORMAL_COUNT=0;
1175   3              TEMP_LOW_COUNT=0;
1176   3            TEMP_LOW_WARN_COUNT=0;
1177   3            TEMP_HIGH_COUNT=0;
1178   3            TEMP_HIGH_WARN_COUNT++;
1179   3            }   
1180   2            else if((BatteryBTH>BTH_TEMP_HIGH_WARN)&&(BatteryBTH<=BTH_TEMP_LOW_WARN))
1181   2            {
1182   3            TEMP_NORMAL_COUNT++;
1183   3            TEMP_LOW_COUNT=0;
1184   3            TEMP_LOW_WARN_COUNT=0;
1185   3            TEMP_HIGH_COUNT=0;
1186   3            TEMP_HIGH_WARN_COUNT=0;
1187   3            }
1188   2            else if((BatteryBTH>BTH_TEMP_LOW_WARN)&&(BatteryBTH<=BTH_TEMP_LOW))  //0~-5 warnning
1189   2              {
1190   3              TEMP_NORMAL_COUNT=0;
1191   3              TEMP_LOW_COUNT=0;
1192   3              TEMP_LOW_WARN_COUNT++;
1193   3              TEMP_HIGH_COUNT=0;
1194   3              TEMP_HIGH_WARN_COUNT=0;
1195   3      
1196   3              }
1197   2            else if((BatteryBTH>BTH_TEMP_LOW)&&(BatteryBTH<=BATTERY_ACD_no_battery))  //-5~-10 warnning
1198   2              {
1199   3              TEMP_NORMAL_COUNT=0;
1200   3              TEMP_LOW_COUNT++;
1201   3              TEMP_LOW_WARN_COUNT=0;
1202   3              TEMP_HIGH_COUNT=0;
1203   3              TEMP_HIGH_WARN_COUNT=0;
1204   3              }
1205   2            else
1206   2              {
1207   3              #if (_DEBUG_MESSAGE_Power_Supply_TEST==ON)
                      #else
1209   3              SET_NO_BATTERY();
1210   3              SET_BATTERY_STATE(_BATT_STATUS_NO_BATT);
1211   3              #endif
1212   3              TEMP_STAT=_BATT_STATUS_TEMP_NORMAL; ///no DC12V input
1213   3            TEMP_NORMAL_COUNT=0;
1214   3              TEMP_LOW_COUNT=0;
1215   3            TEMP_LOW_WARN_COUNT=0;
1216   3            TEMP_HIGH_COUNT=0;
1217   3            TEMP_HIGH_WARN_COUNT=0;         
1218   3              }
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 21  

1219   2      
1220   2          if(((TEMP_NORMAL_COUNT>3)||(TEMP_LOW_COUNT>3)||(TEMP_LOW_WARN_COUNT>3)||(TEMP_HIGH_COUNT>3)||(TEMP_HIGH_
             -WARN_COUNT>3)\
1221   2            )&&(PWR_START_flag==ON)&&(PowerFlag==OFF)&&(GET_NO_BATTERY()==_TRUE))
1222   2          PowerFlag=ON;
1223   2      
1224   2            
1225   2          if(TEMP_HIGH_COUNT==TempADC_Counts)
1226   2          {
1227   3            TEMP_STAT=_BATT_STATUS_TEMP_HIGH;
1228   3            TEMP_HIGH_COUNT=0;
1229   3            CLR_BATTERY_HIGH_TMEP_WARN();
1230   3            CLR_BATTERY_LOW_TMEP_WARN();  
1231   3            CLR_NO_BATTERY();
1232   3          }
1233   2      
1234   2          if(TEMP_HIGH_WARN_COUNT==TempADC_Counts)
1235   2          {
1236   3            TEMP_STAT=_BATT_STATUS_TEMP_HIGH_WARN;
1237   3            TEMP_HIGH_WARN_COUNT=0;
1238   3            SET_BATTERY_HIGH_TMEP_WARN();
1239   3            CLR_BATTERY_LOW_TMEP_WARN();
1240   3            CLR_NO_BATTERY();   
1241   3          }
1242   2      
1243   2          if(TEMP_NORMAL_COUNT==TempADC_Counts)
1244   2          {
1245   3            TEMP_STAT=_BATT_STATUS_TEMP_NORMAL;
1246   3            TEMP_NORMAL_COUNT=0;
1247   3            CLR_BATTERY_LOW_TMEP_WARN();
1248   3            CLR_BATTERY_HIGH_TMEP_WARN();
1249   3            CLR_NO_BATTERY();   
1250   3          }
1251   2      
1252   2          if(TEMP_LOW_WARN_COUNT==TempADC_Counts)
1253   2          {
1254   3            TEMP_STAT=_BATT_STATUS_TEMP_LOW_WARN;
1255   3            TEMP_LOW_WARN_COUNT=0;
1256   3            SET_BATTERY_LOW_TMEP_WARN();
1257   3            CLR_BATTERY_HIGH_TMEP_WARN();
1258   3            CLR_NO_BATTERY();     
1259   3          }
1260   2      
1261   2          if(TEMP_LOW_COUNT==TempADC_Counts)
1262   2          {
1263   3            TEMP_STAT=_BATT_STATUS_TEMP_LOW;
1264   3            TEMP_LOW_COUNT=0;
1265   3            CLR_BATTERY_LOW_TMEP_WARN();
1266   3            CLR_BATTERY_HIGH_TMEP_WARN(); 
1267   3            CLR_NO_BATTERY();   
1268   3          }
1269   2      /*
1270   2          if(GET_BATTERY_CHARGE_STATE()==_BATT_STATUS_NO_BATT)
1271   2            {
1272   2              TEMP_STAT=_BATT_STATUS_TEMP_NORMAL;
1273   2              CLR_BATTERY_LOW_TMEP_WARN();
1274   2              CLR_BATTERY_HIGH_TMEP_WARN();
1275   2      
1276   2            }
1277   2          */
1278   2          SET_BTH_STATE(TEMP_STAT);
1279   2      
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 22  

1280   2      
1281   2            if((BatteryBTH<=CHARGE_TEMP_HIGH)||(BatteryBTH>CHARGE_TEMP_LOW))  
1282   2              {
1283   3              CHARGE_TEMP_ABNORMAL++;
1284   3              CHARGE_TEMP_NORMAL=0;
1285   3              }
1286   2              else
1287   2              {
1288   3              CHARGE_TEMP_ABNORMAL=0;
1289   3              CHARGE_TEMP_NORMAL++;
1290   3              //CLR_CHARGE_TMEP_ABNORMAL();
1291   3              }
1292   2              
1293   2              if(CHARGE_TEMP_ABNORMAL==TempADC_Counts)
1294   2                {
1295   3                CHARGE_TEMP_ABNORMAL=0;
1296   3                  if((GET_AC_PLUG()==_TRUE)&&(GET_NO_BATTERY()==_FALSE))      
1297   3                  SET_CHARGE_TMEP_ABNORMAL();
1298   3                
1299   3                //  if(GET_BATTERY_CHARGE_STATE()==_BATT_STATUS_NO_BATT)  
1300   3                //    CLR_CHARGE_TMEP_ABNORMAL();                     
1301   3                }
1302   2              else  if(CHARGE_TEMP_NORMAL==TempADC_Counts)
1303   2                {
1304   3                CHARGE_TEMP_NORMAL=0;
1305   3                CLR_CHARGE_TMEP_ABNORMAL();
1306   3                }
1307   2          #else
                      if((BatteryBTH<=BTH_TEMP_HIGH)&&(BatteryBTH>BTH_TEMP_MIN)) //>55
                      SET_BTH_STATE(_BATT_STATUS_TEMP_HIGH);          
                    else if((BatteryBTH>BTH_TEMP_HIGH)&&(BatteryBTH<=BTH_TEMP_HIGH_WARN))//50~55 warnning
                      {
                      SET_BATTERY_HIGH_TMEP_WARN();   
                      CLR_BATTERY_LOW_TMEP_WARN();  
                      }
                    else if((BatteryBTH>BTH_TEMP_HIGH_WARN)&&(BatteryBTH<=BTH_TEMP_LOW_WARN))
                      {
                      SET_BTH_STATE(_BATT_STATUS_TEMP_NORMAL);        
                      CLR_BATTERY_LOW_TMEP_WARN();
                      CLR_BATTERY_HIGH_TMEP_WARN();
                      }
                    else if((BatteryBTH>BTH_TEMP_LOW_WARN)&&(BatteryBTH<=BTH_TEMP_LOW))  //0~-5 warnning
                      {
                      //SET_BATTERY_LOW_TMEP_WARN();
                      //CLR_BATTERY_HIGH_TMEP_WARN(); 
                      }
                    else if(BatteryBTH>BTH_TEMP_LOW)  //-5~-10 warnning
                      {
                      SET_BTH_STATE(_BATT_STATUS_TEMP_LOW);       
                      CLR_BATTERY_LOW_TMEP_WARN();
                      CLR_BATTERY_HIGH_TMEP_WARN();
                      }
                    else 
                      SET_BTH_STATE(_BATT_STATUS_TEMP_NORMAL);
                    
              
                    #endif  
1337   2          //}
1338   2            if(PowerFlag==OFF)
1339   2              MCUTimerActiveTimerEvent(SEC(0.1/*1*/), _SYSTEM_TIMER_EVENT_JUDGE_BTH_STATE);
1340   2              else
1341   2          MCUTimerActiveTimerEvent(SEC(0.2/*0.3*//*1*/), _SYSTEM_TIMER_EVENT_JUDGE_BTH_STATE);
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 23  

1342   2          break;
1343   2      
1344   2          case _SYSTEM_TIMER_EVENT_JUDGE_WDT_ECHO:
1345   2      
1346   2      
1347   2            if(GET_DVR_WDTkickDisable()==_FALSE)
1348   2            {
1349   3            #if(_DEBUG_MESSAGE_WDT_KICK_CHECK == ON)    
                    GraphicsPrint(RED,"\r\n(WDT kick over 10 seconds, Try to reboot the DVR)"); 
                    #endif
1352   3            SET_DVR_Reboot();
1353   3            SET_DVR_RebootAndPower();
1354   3            MCUTimerActiveTimerEvent(SEC(1), _USER_TIMER_EVENT_OSD_DVR_REBOOT);
1355   3            }
1356   2          break;
1357   2      
1358   2          case _SYSTEM_TIMER_EVENT_JUDGE_AC_MODE:
1359   2          
1360   2              #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                      GraphicsPrint(CYAN,"(AC)");
                      if(GET_STAT1()==ON)
                        GraphicsPrint(GREEN,"(S1=1)");
                      else
                        GraphicsPrint(GREEN,"(S1=0)");
                      
                      if(GET_STAT2()==ON)
                        GraphicsPrint(MAGENTA,"(S2=1)");
                      else
                        GraphicsPrint(MAGENTA,"(S2=0)");
                        
                      #endif
1373   2              
1374   2                  if(Check_ADAP_IN()==_TRUE)
1375   2                  {
1376   3                    if(GET_AC_PLUG()!=_TRUE)
1377   3                    {
1378   4                      SET_AC_PLUG();
1379   4                      //SET_AC_MODE();  // turn on AC mode
1380   4                      CLR_AC_MODE();  // turn on AC mode
1381   4                      //MCUTimerDelayXms(100);//delay 50ms    
1382   4                      //CLR_BAT_SYS();// turn off battery output              
1383   4                      //SET_PWM(_CHG_CURR,Low_Current);
1384   4      
1385   4                      STAT1_temp=GET_STAT1(); 
1386   4                      if(STAT1_Flag!=STAT1_temp)
1387   4                      STAT1_Flag=STAT1_temp;
1388   4                      
1389   4                      STAT2_temp=GET_STAT2(); 
1390   4                      if(STAT2_Flag!=STAT2_temp)
1391   4                      STAT2_Flag=STAT2_temp;
1392   4      
1393   4                    }         
1394   3                  
1395   3                  if(GET_NO_BATTERY()==_TRUE)
1396   3                    {
1397   4                  MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_NO_BATT);                
1398   4                    }
1399   3                  else
1400   3                    {
1401   4                    
1402   4                  if(GET_POWER_STATUS()==_POWER_STATUS_NORMAL)
1403   4                  {
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 24  

1404   5                    
1405   5                    if((GET_BTH_STATE()==_BATT_STATUS_TEMP_NORMAL)&&(GET_BATTERY_CAPACITY_HIGH_FLAG()==_FALSE)&&(GET_BA
             -TTERY_ABNORMAL()==_FALSE)&&(GET_CHARGE_TMEP_ABNORMAL()==_FALSE)/*&&(GET_CHARGE_START_FLAG()==_TRUE)*/)
1406   5                      {
1407   6                        if(GET_BATTERY_CAPACITY_LOW_FLAG()==_FALSE)
1408   6                        MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_BATT_NORMAL_CHARGE);                   
1409   6                        else
1410   6                        MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_BATT_LOW_CHARGE);  
1411   6                      }
1412   5                    else if(GET_BATTERY_CHARGE_STATE()==_BATT_STATUS_NO_BATT)
1413   5                    MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_NO_BATT); 
1414   5                    else
1415   5                    MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_BATT_NO_CHARGE);   
1416   5                  }
1417   4                  else if(GET_POWER_STATUS()==_POWER_STATUS_SAVING)
1418   4                    {
1419   5                    
1420   5                    if((GET_BTH_STATE()==_BATT_STATUS_TEMP_NORMAL)&&(GET_BATTERY_CAPACITY_HIGH_FLAG()==_FALSE)&&(GET_BA
             -TTERY_ABNORMAL()==_FALSE)&&(GET_CHARGE_TMEP_ABNORMAL()==_FALSE)/*&&(GET_CHARGE_START_FLAG()==_TRUE)*/)
1421   5                      {
1422   6                      if(GET_BATTERY_CAPACITY_LOW_FLAG()==_FALSE)
1423   6                      MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_BATT_NORMAL_CHARGE);                   
1424   6                      else
1425   6                      MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_BATT_LOW_CHARGE);
1426   6                      }
1427   5                      else if(GET_BATTERY_CHARGE_STATE()==_BATT_STATUS_NO_BATT)
1428   5                      MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_NO_BATT); 
1429   5                      else
1430   5                      MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_BATT_NO_CHARGE); 
1431   5                    }
1432   4                  else if(GET_POWER_STATUS()==_POWER_STATUS_OFF)
1433   4                    {
1434   5                      
1435   5                      if((GET_BTH_STATE()==_BATT_STATUS_TEMP_NORMAL)&&(GET_BATTERY_CAPACITY_HIGH_FLAG()==_FALSE)&&(GET_B
             -ATTERY_ABNORMAL()==_FALSE)&&(GET_CHARGE_TMEP_ABNORMAL()==_FALSE)/*&&(GET_CHARGE_START_FLAG()==_TRUE)*/)
1436   5                        {
1437   6                        if(GET_BATTERY_CAPACITY_LOW_FLAG()==_FALSE)
1438   6                          MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_BATT_HIGH_CHARGE); 
1439   6                        else
1440   6                          MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_BATT_LOW_CHARGE);  
1441   6                        }
1442   5                      else if(GET_BATTERY_CHARGE_STATE()==_BATT_STATUS_NO_BATT)
1443   5                      MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_NO_BATT); 
1444   5                      else
1445   5                      MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_BATT_NO_CHARGE); 
1446   5                    }
1447   4                          
1448   4                  
1449   4                    }
1450   3                
1451   3                  MCUTimerActiveTimerEvent(SEC(5), _SYSTEM_TIMER_EVENT_JUDGE_AC_MODE);   //repeat on AC mode
1452   3      
1453   3      
1454   3                  }
1455   2                else
1456   2                  {
1457   3                  CLR_AC_PLUG();
1458   3                  CLR_AC_MODE();  // turn off AC mode
1459   3                  SET_AC_PLUG_OUT();
1460   3                  CLR_BATTERY_CAPACITY_HIGH_FLAG(); 
1461   3                  if((PWR_START_flag==ON)&&(PowerFlag==ON))
1462   3                  MCU_SendCmdToDVR(MCU_PROTOCOL_CMD_SYSTEM_SHUTDOWN);///SET_AC_PLUG_OUT             
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 25  

1463   3                  MCUTimerActiveTimerEvent(SEC(0.5), _SYSTEM_TIMER_EVENT_BATT_NO_CHARGE);  //change battery mode          
1464   3                  MCUTimerActiveTimerEvent(SEC(0.5), _SYSTEM_TIMER_EVENT_JUDGE_BATT_MODE);  //going to battery mode
1465   3                  }
1466   2      
1467   2                CLR_AC_MODE();  
1468   2                    //CLR_BAT_SYS();
1469   2          break;
1470   2                      case _SYSTEM_TIMER_EVENT_CHECK_CHARGE_STATE:
1471   2      
1472   2                    STAT1_temp=GET_STAT1();
1473   2                    STAT2_temp=GET_STAT2();
1474   2                  
1475   2                    #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                            GraphicsPrint(YELLOW,"(STAT1_temp=%02x)",(WORD)STAT1_temp);
                            #endif  
1478   2                    #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                            GraphicsPrint(GREEN,"(STAT2_temp=%02x)",(WORD)STAT2_temp);
                            #endif  
1481   2                    
1482   2                    if((STAT1_Flag!=STAT1_temp)&&(GET_NO_BATTERY()==_FALSE))
1483   2                      {
1484   3                      STAT1_Flag=STAT1_temp;
1485   3                      SET_BATTERY_CHARGE_STATE(_BATT_STATUS_NONE);//reset battery state.              
1486   3                      }
1487   2                    
1488   2                      if((STAT2_Flag!=STAT2_temp)&&(GET_NO_BATTERY()==_FALSE))
1489   2                      {
1490   3                      STAT2_Flag=STAT2_temp;
1491   3                      SET_BATTERY_CHARGE_STATE(_BATT_STATUS_NONE);//reset battery state.              
1492   3                      }
1493   2            
1494   2                #if 1
1495   2                    if(GET_BATTERY_ABNORMAL()==_FALSE)
1496   2                    { 
1497   3                        if(GET_BATTERY_CAPACITY()>=BATTERY_ACD_MAX)//>17    
1498   3                        {
1499   4                        #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                                GraphicsPrint(RED,"( HigH Voltage >17V shut down)");
                                #endif
1502   4                        SET_BATTERY_ABNORMAL();
1503   4                        MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_JUDGE_PSW_STATE);            
1504   4                        }
1505   3                  
1506   3                    }
1507   2      
1508   2                        switch(GET_BATTERY_STATE())
1509   2                        {
1510   3      
1511   3                      case _BATT_STATUS_CAPACITY_MAX_STOP:
1512   3                        
1513   3                          if(GET_BATTERY_CAPACITY_HIGH_FLAG()==_FALSE)
1514   3                          {
1515   4                          #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                                  GraphicsPrint(RED,"(HIGH Voltage >16.4V stop charge)");
                                  #endif  
1518   4                          SET_BATTERY_CAPACITY_HIGH_FLAG();   
1519   4                          }
1520   3                          
1521   3                         if(GET_BATTERY_CAPACITY_LOW_FLAG()==_TRUE)
1522   3                         {     
1523   4                          #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                                   GraphicsPrint(RED,"(2.Normal Voltage Charge >12V)");
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 26  

                                  #endif
1526   4                         CLR_BATTERY_CAPACITY_LOW_FLAG();  
1527   4                         SET_BATTERY_CHARGE_STATE(_BATT_STATUS_NONE);//reset battery state.  
1528   4                          if(ReadEEP(EEP_LowBattery_Flag))
1529   4                            WriteEEP(EEP_LowBattery_Flag,OFF);
1530   4                         }
1531   3                         CLR_CHARGE_START_FLAG();
1532   3                        break;
1533   3                      case _BATT_STATUS_CAPACITY_MIN:
1534   3                      case _BATT_STATUS_CAPACITY_NO_STARTUP:
1535   3                          if((GET_BATTERY_CAPACITY_LOW_FLAG()==_FALSE)&&(GET_DVR_SystemReadyNotic()==_FALSE)&&(GET_AC_PLUG
             -()==_FALSE))
1536   3                          {
1537   4                          SET_BATTERY_CAPACITY_LOW_FLAG();  
1538   4                          
1539   4                          if(ReadEEP(EEP_LowBattery_Flag)==OFF)
1540   4                          WriteEEP(EEP_LowBattery_Flag,ON);
1541   4                          
1542   4                          #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                                  GraphicsPrint(RED,"( Low Voltage <11.8V or < 11.6V shut down)");
                                  #endif  
1545   4                          MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_JUDGE_PSW_STATE);  
1546   4                          }
1547   3                          else  if((GET_BATTERY_STATE()==_BATT_STATUS_CAPACITY_MIN)&&(PowerFlag==ON)&&(GET_AC_PLUG()==_FALS
             -E))
1548   3                          {
1549   4                          PowerFlag=OFF;
1550   4                          WriteEEP(EEP_Powerflag,PowerFlag);
1551   4                        
1552   4                          if(GET_DVR_EntrySleepMode()==TRUE)
1553   4                          CLR_DVR_EntrySleepMode();
1554   4                          }
1555   3      
1556   3                          if(GET_DVR_EntrySleepMode()==_TRUE)
1557   3                          {
1558   4                          SET_TARGET_POWER_STATUS(_POWER_STATUS_NORMAL);
1559   4                          #if (_DEBUG_MESSAGE_SysTimerEvent==ON)
                                    GraphicsPrint(RED,"(MCU_SLEEP_TO_NORMAL_MODE: Low Voltage <12V)");    
                                  #endif  
1562   4                          }
1563   3                          
1564   3                          CLR_BATTERY_CAPACITY_HIGH_FLAG();       
1565   3                          SET_CHARGE_START_FLAG();
1566   3                        break;
1567   3      
1568   3                       case _BATT_STATUS_CAPACITY_LEVEL0:
1569   3                         CLR_BATTERY_CAPACITY_HIGH_FLAG();   
1570   3                        //  CLR_BATTERY_CAPACITY_LOW_FLAG();  
1571   3                          if(GET_DVR_EntrySleepMode()==_TRUE)
1572   3                          {
1573   4                          SET_TARGET_POWER_STATUS(_POWER_STATUS_NORMAL);
1574   4                          #if (_DEBUG_MESSAGE_SysTimerEvent==ON)
                                    GraphicsPrint(RED,"(MCU_SLEEP_TO_NORMAL_MODE: Low Voltage <12V)");    
                                  #endif  
1577   4                          }
1578   3                        break;
1579   3                       case _BATT_STATUS_CAPACITY_LEVEL1:                 
1580   3                       case _BATT_STATUS_CAPACITY_LEVEL2:
1581   3                       case _BATT_STATUS_CAPACITY_LEVEL3:
1582   3                       case _BATT_STATUS_CAPACITY_LEVEL4:
1583   3                       case _BATT_STATUS_CAPACITY_MAX:
1584   3      
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 27  

1585   3                         SET_CHARGE_START_FLAG();
1586   3                         /*
1587   3                         if(GET_BATTERY_CAPACITY_LOW_FLAG()==_TRUE)
1588   3                         {     
1589   3                          #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
1590   3                           GraphicsPrint(RED,"(Normal Voltage Charge >12V)");
1591   3                          #endif
1592   3                         CLR_BATTERY_CAPACITY_LOW_FLAG();  
1593   3                         SET_BATTERY_CHARGE_STATE(_BATT_STATUS_NONE);//reset battery state.  
1594   3                         }  
1595   3                         */
1596   3                         CLR_BATTERY_CAPACITY_HIGH_FLAG();   
1597   3                          break;
1598   3                      //case _BATT_STATUS_CAPACITY_MAX:
1599   3                      //  CLR_CHARGE_START_FLAG();
1600   3                        
1601   3                        //break;
1602   3                        }
1603   2            #else
                            if(GET_BATTERY_CAPACITY_LOW_FLAG()==_FALSE)
                            { 
                              if(GET_BATTERY_STATE()==_BATT_STATUS_CAPACITY_MIN)//<11.6V    
                              {
                              SET_BATTERY_CAPACITY_LOW_FLAG();                                      
                              #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                              GraphicsPrint(RED,"( Low Voltage <11.6V shut down)");
                              #endif                                      
                              MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_JUDGE_PSW_STATE);            
                              }             
                              
                            }
              
                
                            if(GET_BATTERY_ABNORMAL()==_FALSE)
                            { 
                                if(GET_BATTERY_CAPACITY()>=BATTERY_ACD_MAX)//>17    
                                {
                                #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                                GraphicsPrint(RED,"( HigH Voltage >17V shut down)");
                                #endif
                                SET_BATTERY_ABNORMAL();
                                MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_JUDGE_PSW_STATE);            
                                }
                          
                            }
                      //}
              
                              if(GET_BATTERY_CAPACITY_LOW_FLAG()==_TRUE)
                              {   
                                if(GET_BATTERY_STATE()!=_BATT_STATUS_CAPACITY_MIN)//<11.6V    
                                {
                                #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                                GraphicsPrint(RED,"(Normal Voltage Charge >12V)");
                                #endif
                                CLR_BATTERY_CAPACITY_LOW_FLAG();  
                                SET_BATTERY_CHARGE_STATE(_BATT_STATUS_NONE);//reset battery state.  
                                }         
                              }
                          //  if(((GET_BATTERY_CAPACITY()>675)||(GET_BATTERY_CAPACITY()<1023))&&(GET_BATTERY_ABNORMAL()==_TRUE)
             -)    
                            //      CLR_BATTERY_ABNORMAL();
              
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 28  

                            if(GET_BATTERY_STATE()==_BATT_STATUS_CAPACITY_MAX)//>16.4V
                            {
                                  if(GET_BATTERY_CAPACITY_HIGH_FLAG()==_FALSE)
                                  {
                                  #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                                  GraphicsPrint(RED,"(HIGH Voltage >15.5V stop charge)");
                                  #endif  
                                  SET_BATTERY_CAPACITY_HIGH_FLAG();   
                                  //SET_BATTERY_CHARGE_STATE(_BATT_STATUS_NONE);//reset battery state.
                                  }
                                  
                            }
                            else
                              CLR_BATTERY_CAPACITY_HIGH_FLAG(); 
                            
                    #endif        
1662   2                MCUTimerActiveTimerEvent(SEC(10-5), _SYSTEM_TIMER_EVENT_CHECK_CHARGE_STATE);  //check charge
1663   2                break;
1664   2          case     _SYSTEM_TIMER_EVENT_JUDGE_BATT_MODE:
1665   2            #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                    GraphicsPrint(CYAN,"(BATT)");
                      if(GET_STAT1()==ON)
                        GraphicsPrint(MAGENTA,"(S1=1)");
                      else
                        GraphicsPrint(GREEN,"(S1=0)");
                      
                      if(GET_STAT2()==ON)
                        GraphicsPrint(MAGENTA,"(S2=1)");
                      else
                        GraphicsPrint(GREEN,"(S2=0)");
                    #endif
1677   2          
1678   2            if(Check_ADAP_IN()==_TRUE)
1679   2              {
1680   3      
1681   3                if((PWR_START_flag==ON)&&(PowerFlag==OFF))
1682   3                {
1683   4                MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_JUDGE_PSW_STATE);
1684   4                }
1685   3      
1686   3              SET_BATTERY_CHARGE_STATE(_BATT_STATUS_NONE);//reset battery state.
1687   3              MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_JUDGE_AC_MODE);  
1688   3              }
1689   2            else 
1690   2              {
1691   3              if(GET_BAT_SYS()!=ON)
1692   3                {
1693   4                //SET_BAT_SYS();   // turn on  battery mode
1694   4                //CLR_BAT_SYS();   // turn on  battery mode
1695   4                //MCUTimerDelayXms(100);//delay 50ms          
1696   4                CLR_AC_MODE();  // turn off AC mode
1697   4                }
1698   3      
1699   3                //if((GET_BATTERY_STATE()==_BATT_STATUS_CAPACITY_LEVEL0)&&(PowerFlag==ON))
1700   3                //MCUTimerActiveTimerEvent(SEC(0.1), _USER_TIMER_EVENT_OSD_DVR_SHUTDOWN);
1701   3      
1702   3                MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_BATT_NO_CHARGE);       
1703   3      
1704   3      
1705   3              MCUTimerActiveTimerEvent(SEC(5), _SYSTEM_TIMER_EVENT_JUDGE_BATT_MODE);
1706   3              }
1707   2      
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 29  

1708   2                CLR_AC_MODE();  
1709   2                    //CLR_BAT_SYS();
1710   2            break;
1711   2      
1712   2            case _SYSTEM_TIMER_EVENT_BATT_LOW_CHARGE: 
1713   2              if(GET_BATTERY_CHARGE_STATE()!=_BATT_STATUS_LOW_CHARGE)
1714   2              UserInterfaceBatteryChargeMode(_BATT_STATUS_LOW_CHARGE);
1715   2          break;
1716   2      
1717   2        case  _SYSTEM_TIMER_EVENT_BATT_HIGH_CHARGE:   
1718   2              if(GET_BATTERY_CHARGE_STATE()!=_BATT_STATUS_HIGH_CHARGE)
1719   2              UserInterfaceBatteryChargeMode(_BATT_STATUS_HIGH_CHARGE);         
1720   2              break;
1721   2        case  _SYSTEM_TIMER_EVENT_BATT_NORMAL_CHARGE:   
1722   2            if(GET_BATTERY_CHARGE_STATE()!=_BATT_STATUS_NORMAL_CHARGE)
1723   2              UserInterfaceBatteryChargeMode(_BATT_STATUS_NORMAL_CHARGE);             
1724   2            break;
1725   2      
1726   2        case  _SYSTEM_TIMER_EVENT_BATT_NO_CHARGE:   
1727   2              if(GET_BATTERY_CHARGE_STATE()!=_BATT_STATUS_STOP_CHARGE)
1728   2              UserInterfaceBatteryChargeMode(_BATT_STATUS_STOP_CHARGE);         
1729   2            break;
1730   2      
1731   2      
1732   2        case  _SYSTEM_TIMER_EVENT_NO_BATT:  
1733   2              if(GET_BATTERY_CHARGE_STATE()!=_BATT_STATUS_NO_BATT)
1734   2              UserInterfaceBatteryChargeMode(_BATT_STATUS_NO_BATT);         
1735   2              break;
1736   2            
1737   2      
1738   2              case _SYSTEM_TIMER_EVENT_SHOW_WORKING_TIMER:
1739   2        
1740   2            second+=10;
1741   2          
1742   2            if(second==60)
1743   2            {
1744   3              second=0;
1745   3              minute++;
1746   3            }
1747   2        
1748   2            if(minute==60)
1749   2            {
1750   3              minute=0;
1751   3              hour++;
1752   3            }
1753   2        
1754   2            if(hour==24)
1755   2            {
1756   3              hour=0;
1757   3              day++;
1758   3            } 
1759   2      
1760   2          ShowWorkingTimer();
1761   2      
1762   2          MCUTimerActiveTimerEvent(SEC(10), _SYSTEM_TIMER_EVENT_SHOW_WORKING_TIMER);
1763   2             break;
1764   2      #if (_POWER_DOWN_ENABLE==ON)
1765   2          case _SYSTEM_TIMER_POWER_DOWN_MODE:
1766   2          //SET_MCU_POWER_DOWN_MODE();
1767   2          Power_down_mode=2;
1768   2              
1769   2          break;
C51 COMPILER V9.60.0.0   SYSTIMER                                                          04/22/2021 09:18:53 PAGE 30  

1770   2      #endif
1771   2         default:
1772   2                  break;
1773   2       }
1774   1      }
1775          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5117    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     92      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
